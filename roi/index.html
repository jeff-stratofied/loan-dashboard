<!doctype html>
<html lang="en" data-theme="light">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Loan Portfolio â€” ROI</title>

  <!-- ====================================
       Styles (organized, with dark mode)
       ==================================== -->
  <style>
  
:root {
  --bg:#f8fafc;
  --surface:#f1f5f9;
  --card:#ffffff;
  --border:#e2e8f0;
  --text:#0f172a;
  --muted:#64748b;

  --brand:#0ea5e9;
  --accent:#7c3aed;

  --shadow:0 12px 30px rgba(15,23,42,0.06);

  --page-gradient: linear-gradient(180deg, var(--surface), var(--bg));

  --chart-bg:linear-gradient(180deg,#ffffff,#fcfeff);
  --grad-top:#f1f5f9;
  --grad-bottom:#ffffff;

  --tooltip-bg:#0f172a;
  --tooltip-text:#f8fafc;

  --table-header:var(--surface);
  --table-border:rgba(148,163,184,0.35);
}

html {
  color-scheme: light;
}

html[data-theme="dark"] {
   color-scheme: dark; 
  --bg:#0f172a;
  --surface:#1e293b;
  --card:#1e293b;
  --border:#334155;
  --text:#f1f5f9;
  --muted:#94a3b8;

  --brand:#38bdf8;
  --accent:#c4b5fd;

  --grad-top:#1e293b;
  --grad-bottom:#0f172a;

  --shadow:rgba(0,0,0,0.45);

  --chart-bg:linear-gradient(180deg,#1e293b,#0f172a);

  --tooltip-bg:#0f172a;
  --tooltip-text:#f1f5f9;

  --table-header:#1e293b;
  --table-border:#334155;
}


.info-hover {
  display: inline-block;
  margin-left: 6px;
  font-size: 11px;
  cursor: help;
  color: var(--muted);
  background: var(--surface);
  border: 1px solid var(--border);
  padding: 1px 5px;
  border-radius: 50%;
  line-height: 14px;
  text-align: center;
  transition: background-color .2s ease, color .2s ease, border-color .2s ease;
}

.info-hover:hover {
  color: var(--text);
  border-color: var(--text);
}

    
    /* Smooth theme transitions (copied from amortization page) */
    html, body,
    .app,
    header,
    .kpi, .tile,
    .drawer, .drawer-head, .drawer-body, .drawer-footer,
    .info-card, .drawer-chart,
    table, thead th, td,
    .tooltip,
    .theme-icon,
    svg text {
      transition:
    background-color .25s ease,
    color .25s ease,
    border-color .25s ease,
    box-shadow .25s ease,
    fill .25s ease;
    }

html,body{
  height:100%;
  margin:0;
  font-family:Inter, system-ui, -apple-system, "Segoe UI", Roboto, Arial;
  color:var(--text);
  -webkit-font-smoothing: antialiased;
}

.loan-filters {
  display: flex;
  gap: 10px;
  align-items: center;
  margin: 0 0 14px;
  flex-wrap: wrap;
}

.loan-filters select {
  padding: 6px 10px;
  border-radius: 8px;
  border: 1px solid var(--border);
  background: var(--card);
  color: var(--text);
  font-size: 13px;
}

  /* Compact view toggle */
.compact-toggle {
  display: flex;
  align-items: center;
  gap: 6px;
  font-size: 13px;
  color: var(--muted);
  cursor: pointer;
  user-select: none;
}

.compact-toggle input {
  accent-color: var(--brand);
  cursor: pointer;
}

    
/* Force layout to match Amort: body does NOT scroll */
html, body {
  height: 100%;
  overflow: hidden;
}

/* ROI matches Earnings:
   Page does NOT scroll; grid owns scrolling */
.app {
  height: 100%;
  overflow: hidden;
  background: var(--surface);
}

#app,
.app {
  background: var(--surface);
}



    
body{
  background: linear-gradient(180deg, var(--grad-top) 0%, var(--grad-bottom) 100%);
  background-color: var(--bg);
  transition: background-color .25s ease, color .25s ease;
}

/* Dark mode gradient (match Amort exactly) */
html[data-theme="dark"] body {
  background: linear-gradient(180deg,#0b1224 0%, #0f172a 100%);
}

    .app{
      max-width:1200px;
      margin:20px auto 0 auto;
      padding:16px 16px 0 16px;
    }

    /* Match amort layout */
    body > .app {
       background: transparent;
      padding-top: 16px;
      margin-top: 0;
    }


    header {
      display:flex;
      flex-direction:column;
      gap:8px;
      margin-bottom:8px;   /* match amort */
      padding:0;           /* remove invisible offset */
    }

    .header-top{display:flex;align-items:center;justify-content:space-between}
    .header-controls {
      display:flex;
      gap:10px;
      align-items:center;
    }

    h1{ font-size:20px; margin:0 }
    p.lead{ margin:0; color:var(--muted); font-size:13px }
    .current-date{ font-size:13px; color:var(--muted); margin-top:4px }
    

    
    /* =========================
       Buttons (unified with Amort Page)
       ========================= */
    .actions { display:flex; gap:8px; align-items:center }
    .btn{ padding:8px 12px; border-radius:8px; border:1px solid var(--border); background:transparent; cursor:pointer; font-weight:600; color:var(--text); transition:background .2s ease, color .2s ease, border-color .2s ease }
    .btn.primary{
    background:var(--brand);
    color:white;
    border:none;
    box-shadow:var(--shadow);
  }

    .btn.secondary{ background:var(--surface); color:var(--text); }
    .close-btn{ background:var(--surface); border:1px solid var(--border); padding:8px; border-radius:8px; cursor:pointer; }
    .btn:hover, .close-btn:hover{ border-color:rgba(15,23,42,0.14); }

    /* =========================
       KPI row + tiles (unified hover)
       ========================= */
     .kpis {
      display:grid;
      grid-template-columns:repeat(4,1fr);
      gap:12px;
      margin:14px 0 18px;
    }

  .kpi{
    background:var(--card);
    padding:12px;
    border-radius:10px;
    box-shadow:var(--shadow);
    border:1px solid var(--border);
    cursor:pointer;
    transition: transform .18s, box-shadow .18s,
              background-color .25s ease, color .25s ease,
              border-color .25s ease;
    }
  .kpi:hover {
    transform: translateY(-2px);
    box-shadow: 0 6px 16px rgba(0,0,0,0.15);
    }

    /* KPI drawer table row hover (match Earnings) */
    #drawerExtra table tbody tr:hover {
      background: rgba(148, 163, 184, 0.12); /* same subtle gray */
    }


  .kpi h3 { margin:0; font-size:12px; color:var(--muted); }
  .kpi p  { margin:8px 0 0; font-size:18px; font-weight:700; }


/* ROI matches Earnings:
   Loan grid is the ONLY scroll container */
.grid {
  display: grid;
  grid-template-columns: repeat(2,1fr);
  grid-auto-rows: min-content;
  gap: 12px;

  height: calc(100vh - 320px);
  overflow-y: auto;
  overflow-x: hidden;

  padding-right: 6px;
}


    /* =========================
   Compact loan tiles
   ========================= */
.grid.compact .tile {
  min-height: 64px;           /* ~Â½ current height */
  padding: 8px 10px;
}

.grid.compact .tile-left {
  padding-right: 0;
}

.grid.compact .loan-sub,
.grid.compact .loan-meta {
  display: none;              /* hide details */
}

.grid.compact .chart-wrap svg {
  display: none;              /* hide sparkline */
}

.grid.compact .chart-wrap {
  width: auto;
}

.grid.compact .mini-label {
  margin: 0;
  font-weight: 700;
  font-size: 13px;
}
.grid.compact .loan-name {
  font-size: 13px;
}

    
  
    @media(max-width:900px){ .grid{ grid-template-columns:1fr; height:auto } .kpis{ grid-template-columns:repeat(2,1fr) } }

    /* =========================================
   Loan event badges (ROI tiles)
   ========================================= */
.loan-badges {
  display: flex;
  gap: 6px;
  margin-top: 6px;
  flex-wrap: wrap;
}

.loan-badge {
  display: inline-flex;
  align-items: center;
  gap: 4px;
  padding: 2px 6px;
  font-size: 11px;
  font-weight: 600;
  border-radius: 999px;
  border: 1px solid var(--border);
  background: var(--surface);
  color: var(--text);
}

.loan-badge.default {
  background: rgba(239, 68, 68, 0.15);
  color: #b91c1c;
  border-color: rgba(239, 68, 68, 0.35);
}

.loan-badge.deferral {
  background: rgba(234, 179, 8, 0.18);
  color: #92400e;
  border-color: rgba(234, 179, 8, 0.35);
}

.loan-badge.prepayment {
  background: rgba(34, 197, 94, 0.18);
  color: #166534;
  border-color: rgba(34, 197, 94, 0.35);
}

/* Event badge tooltip */
.badge-tooltip {
  position: absolute;
  background: var(--tooltip-bg);
  color: var(--tooltip-text);
  padding: 6px 10px;
  border-radius: 6px;
  font-size: 12px;
  line-height: 1.3;
  white-space: nowrap;
  pointer-events: none;
  opacity: 0;
  transition: opacity 0.2s ease;
  z-index: 2000;  /* Increased from 100 to layer above drawer (z=1000) and tiles */
  box-shadow: 0 4px 12px rgba(0,0,0,0.3);
  transform: translateY(-8px);
}

.badge-tooltip.visible {
  opacity: 1;
}

    
/* MATCH AMORT TILE HOVER BEHAVIOR */
.tile {
  display:flex;
  align-items:center;
  justify-content:space-between;
  padding:10px 12px;
  border-radius:12px;
  background:var(--card);
  min-height:110px;
  cursor:pointer;
  overflow:hidden;
  border:1px solid var(--border);
  transition: transform .18s ease, box-shadow .18s ease, background-color .25s ease, color .25s ease, border-color .25s ease;
}

.tile:hover {
  transform: translateY(-6px);
  box-shadow: var(--shadow);
}

    .tile-left{ flex:1; padding-right:10px }
    .loan-name{ font-weight:700; font-size:14px }
    .loan-sub{ font-size:12px; color:var(--muted); margin-top:6px }
    .loan-meta{ display:flex; gap:8px; font-size:12px; color:var(--muted); margin-top:8px }

    .chart-wrap{ width:170px; flex-shrink:0; display:flex; flex-direction:column; align-items:flex-end }
    .mini-label{ font-size:12px; color:var(--muted); margin-bottom:6px }
    svg.sparkline{ width:170px; height:48px; display:block }

/* ============================================
   DRAWER (copied from amort, widened for ROI)
   ============================================ */
.drawer{
  position:fixed;
  right:0;
  top:0;
  height:100vh;
  max-width:760px;
  width:760px;
  background:var(--card);
  border-left:1px solid var(--border);
  box-shadow:-28px 0 80px var(--drawer-shadow);
  transform:translateX(110%);
  transition:transform .28s cubic-bezier(.2,.9,.3,1),
             background-color .25s ease, color .25s ease,
             border-color .25s ease, box-shadow .25s ease;
  display:flex;
  flex-direction:column;
  z-index:120;
}
.drawer.open{ transform:translateX(0); }

.drawer-head{
  padding:20px;
  display:flex;
  align-items:flex-start;
  justify-content:space-between;
  gap:8px;
  background:var(--card);   /* MATCH AMORT */
  border-bottom:1px solid var(--border);
}

.drawer-body,
#drawerBody{
  flex: 1 1 auto;
  overflow-y: auto;
  overflow-x: hidden !important;
  padding: 0 20px 20px;   /* KEY: no top padding */
  display: flex;
  flex-direction: column;
  gap: 20px;
}


.drawer-footer{
  padding:20px;
  border-top:1px solid var(--border);
  background:var(--surface);
}

.drawer-footer .actions{
  justify-content:flex-start;
}

/* Chart box */
.drawer-chart{
  height:260px;
  background:var(--chart-bg);
  border-radius:8px;
  border:1px solid rgba(15,23,42,0.06);
  display:block;
  position:relative;
  padding:8px;
  margin-bottom:12px;
  box-shadow:0 6px 18px rgba(15,23,42,0.06);
}

/* Legend same as amort */
.legend{
  display:flex;
  gap:10px;
  align-items:center;
  font-size:12px;
  margin-top:6px;
}

/* Dark theme behavior */
html[data-theme="dark"] .drawer{
  background:var(--drawer-bg);
  border-left:1px solid var(--border);
  box-shadow:-28px 0 80px var(--drawer-shadow);
}
html[data-theme="dark"] .drawer-chart{
  border-color:var(--border);
}

    .drawer h2 {
  margin: 0 0 6px;
  font-size: 20px;
  font-weight: 600;
}

.drawer .muted {
  font-size: 13px;
  margin-bottom: 10px;
  line-height: 1.25;
}


    /* Drawer info row */
    .drawer-info-row { display:flex; gap:12px; margin-bottom:8px; align-items:center }
    .info-card{ flex:1; background:var(--bg); padding:12px; border-radius:8px; display:flex; flex-direction:column; justify-content:center; min-height:56px; border:1px solid var(--border) }
    .info-card.small{ width:160px; align-items:flex-end }
    .muted-small{ font-size:12px; color:var(--muted); margin-bottom:6px }
    .main-val{ font-weight:800; font-size:18px }

    .amort-wrap{ border:1px solid var(--border); border-radius:8px; padding:8px; max-height:40vh; overflow:auto; background:var(--card) }
    table{ width:100%; border-collapse:collapse; font-size:13px; background:var(--card); }
    thead th{ position:sticky; top:0; background:var(--table-header); padding:8px; text-align:left; color:var(--muted); font-weight:700; border-bottom:1px solid var(--table-border) }
    td{ padding:8px; border-bottom:1px dashed var(--table-border); text-align:right }
    td:first-child, th:first-child{ text-align:left }

/* =========================================
   ROI table event highlights (MATCH AMORT)
   ========================================= */
tr.event-prepayment td {
  background: rgba(34, 197, 94, 0.16);
}

tr.event-deferral td {
  background: rgba(234, 179, 8, 0.20);
}

tr.event-default td {
  background: rgba(239, 68, 68, 0.20);
  font-weight: 600;
}

    
  .tooltip{
    position:fixed;
    pointer-events:none;
    background:var(--tooltip-bg);
    color:var(--tooltip-text);
    padding:6px 8px;
    border-radius:6px;
    font-size:12px;
    transform:translate(-50%,-120%);
    box-shadow:0 6px 18px rgba(2,6,23,0.2);
    display:none;
    z-index:9999;
    line-height:1.12;
    border:1px solid rgba(148,163,184,0.3);
    transition:background-color .25s ease, color .25s ease,
             border-color .25s ease, box-shadow .25s ease;
    }

    .small{ font-size:12px; color:var(--muted) }

    /* tiny responsive tweaks */
    @media(max-width:760px){
      .drawer{ width:100%; min-width:0; }
      .kpis{ grid-template-columns:repeat(2,1fr) }
    }

    /* Theme toggle icon */
  .theme-icon {
    width:38px;
    height:38px;
    display:flex;
    align-items:center;
    justify-content:center;
    border-radius:12px;
    border:1px solid var(--border);
    background:var(--card);
    color:var(--text);
    cursor:pointer;
    font-size:16px;
    transition:background .2s ease, color .2s ease, 
             border-color .2s ease, transform .15s ease;
    box-shadow:0 8px 18px rgba(15,23,42,0.06);
    }
  .theme-icon:hover{
    transform:translateY(-1px);
    border-color:rgba(15,23,42,0.14);
    }

    /* ============================================================
   EMBED MODE â€” UNIFIED DRAWER LAYOUT (ALIGN ALL IFRAMES)
   ============================================================ */

.embed-mode .drawer-head {
  padding: 20px !important;
  min-height: 64px;
  border-bottom: 1px solid var(--border);
  background: var(--card);
}

/* Chart: same height everywhere */
.embed-mode .drawer-chart {
  height: 220px !important;
  margin-bottom: 12px !important;
}

/* Stat boxes row */
.embed-mode .stat-boxes,
.embed-mode .drawer-info-row {
  margin-bottom: 12px !important;
  min-height: 56px;
}
 
/* Drawer body spacing */
.embed-mode .drawer-body {
  gap: 12px !important;
  padding-left: 16px !important;
  padding-right: 16px !important;
}

/* Table container */
.embed-mode .amort-wrap {
  max-height: 40vh !important;
}

    /* ============================================================
   EMBED MODE â€” ALIGN CHART START TO EARNINGS
   ============================================================ */

/* Remove any spacer before the chart */
.embed-mode .drawer-body {
  padding-top: 0 !important;
}

/* Kill gap stacking before first block */
.embed-mode .drawer-body > * {
  margin-top: 0 !important;
}

/* Remove legend completely from flow */
.embed-mode .legend,
.embed-mode #drawerLegend {
  display: none !important;
  height: 0 !important;
  margin: 0 !important;
}

    /* Chart must behave like earnings */
.embed-mode .drawer-chart {
  display: block !important;
  padding: 8px !important;
  margin-top: 0 !important;
}

    /* Ensure chart is always first */
.embed-mode .drawer-chart {
  order: 0;
}

.embed-mode .drawer-info-row,
.embed-mode .stat-boxes,
.embed-mode #drawerExtra {
  order: 1;
}

    /* ============================================================
   EMBED MODE â€” UNIFIED LAYOUT (ALIGN WITH EARNINGS & AMORT)
   ============================================================ */
.embed-mode body,
.embed-mode .app,
.embed-mode .drawer {
  height: 100% !important;
  margin: 0 !important;
  padding: 0 !important;
  background: var(--card) !important;
}

.embed-mode .drawer {
  position: static !important;
  width: 100% !important;
  height: 100% !important;
  max-width: none !important;
  box-shadow: none !important;
  border: none !important;
  border-radius: 0 !important;
  display: flex !important;
  flex-direction: column !important;
}

.embed-mode .drawer-head {
  padding: 20px !important;
  min-height: 64px !important;
  border-bottom: 1px solid var(--border) !important;
  background: var(--card) !important;
  flex-shrink: 0 !important;
}

.embed-mode .drawer-body {
  padding: 0 20px 20px !important;
  display: flex !important;
  flex-direction: column !important;
  gap: 20px !important;
  flex: 1 1 auto !important;
  overflow-y: auto !important;
}

.embed-mode .drawer-chart {
  height: 240px !important;
  margin: 0 !important;
  padding: 8px !important;
  order: 0 !important;
  background: var(--chart-bg) !important;
}

.embed-mode .drawer-info-row {
  margin: 0 !important;
  min-height: 56px !important;
  order: 1 !important;
}

.embed-mode .legend {
  display: none !important;
}

.embed-mode .drawer-footer {
  display: none !important;
}

.embed-mode .drawer-body > * {
  margin-top: 0 !important;
}

.badge-tooltip {
  position: fixed !important;  /* Change from absolute to fixed to avoid clipping */
  z-index: 10000 !important;   /* Higher than .drawer (120) and other elements */
  transform: none !important;  /* Remove translateY; we'll handle in JS */
  white-space: pre-wrap;       /* Allow wrapping if text is long */
}

.badge-tooltip.visible {
  opacity: 1 !important;
}

    
  </style>
</head>
<body>
  <div class="app" role="main">

      <!-- Header here -->
  <header>
    <div class="header-top">
      <div>
        <h1>Loan Portfolio â€” ROI</h1>
       <p class="lead">
    ROI to Date = (Loan Value Today â€“ Purchase Price) / Purchase Price
    <span class="info-hover" title="ROI to Date measures your current return so far. It includes all principal and interest already received, minus fees, plus the Mark-to-Market discounted value (95%) of the outstanding loan balance.">â“˜</span>
    </p>

    <p class="lead">
    Projected ROI = (Final Loan Value â€“ Purchase Price) / Purchase Price
    <span class="info-hover" title="Projected ROI measures the total return expected if the loan performs as scheduled through maturity. It uses the full amortization schedule of principal, interest, and fees.">â“˜</span>
    </p>
      </div>
  
      <div class="header-controls">
        <div style="font-size:13px;color:var(--muted)">
          Name: <strong id="currentUserLabel" style="color:var(--brand)"></strong>
        </div>
        <button id="themeToggle" class="theme-icon" title="Toggle dark mode">ðŸŒ™</button>
      </div>
    </div>

    <div class="current-date" id="currentDateLabel">
      Current Date: <span id="currentDate"></span>
    </div>
  </header>



    <!-- KPI Row -->
   <section class="kpis" id="kpis"></section>
  
  <!-- Loan Filters -->
<section class="loan-filters" id="loanFilters">
  <select id="filterName">
    <option value="">All loan names</option>
  </select>

  <select id="filterSchool">
    <option value="">All schools</option>
  </select>

  <select id="filterRate">
    <option value="">All interest rates</option>
    <option value="low">Below 5%</option>
    <option value="mid">5% â€“ 8%</option>
    <option value="high">Above 8%</option>
  </select>

  <!-- ðŸ”½ ADD SORT HERE -->
  <select id="sortLoans">
    <option value="purchase_asc">Purchase date â†‘</option>
    <option value="purchase_desc">Purchase date â†“</option>
    <option value="start_asc">Loan start date â†‘</option>
    <option value="start_desc">Loan start date â†“</option>
    <option value="amount_asc">Orig amount â†‘</option>
    <option value="amount_desc">Orig amount â†“</option>
    <option value="rate_asc">Interest rate â†‘</option>
    <option value="rate_desc">Interest rate â†“</option>
  </select>

<label class="compact-toggle">
  <input type="checkbox" id="toggleCompact" />
  <span>Compact</span>
</label>

  
  <button class="btn secondary" id="resetFilters">Reset filters</button>
</section>

  
  <!-- Loan grid -->
  <section class="grid compact" id="loanGrid" aria-live="polite"></section>
  
    <!-- Drawer -->
   <aside id="drawer" class="drawer" aria-hidden="true">

  
   <div class="drawer-head">
  <div>
    <h2 id="drawerTitle"></h2>
    <div class="muted" id="drawerSub"></div>
  </div>

  <div style="display:flex;gap:8px;align-items:center">
    <button class="btn" id="downloadCsvBtn">Download CSV</button>
    <button class="close-btn" id="closeBtn">âœ•</button>
  </div>
</div>

  

  <div id="drawerBody" class="drawer-body">

    <!-- Chart container (matches amort exactly) -->
    <div class="drawer-chart">
      <div id="drawerChartArea" style="width:100%;height:100%;"></div>
    </div>
    <div class="legend" id="drawerLegend" style="display:none"></div>

   <!-- Correct Primary / Secondary cards block (matches amort exactly) -->
<div style="display:flex; gap:10px; margin-bottom:12px;">

  <div style="
    flex:1;
    background:var(--surface);
    padding:10px;
    border-radius:8px;
    border:1px solid var(--border);
  ">
    <div class="muted-small" id="drawerPrimaryTitle"></div>
    <div class="main-val" id="drawerPrimary"></div>
  </div>

  <div style="
    width:120px;
    background:var(--surface);
    padding:10px;
    border-radius:8px;
    border:1px solid var(--border);
  ">
    <div class="muted-small" id="drawerSecondaryTitle"></div>
    <div class="main-val" id="drawerSecondary"></div>
  </div>

</div>

    <!-- For KPI drawers or custom loan content -->
    <div id="drawerExtra"></div>

    <!-- The ROI table wrapper -->
    <div id="drawerAmortContainer">

      <div class="amort-wrap" id="amortWrap">
        <table>
          <thead>
            <tr>
              <th>Month</th>
              <th>Balance</th>
              <th>Loan Value</th>
              <th>ROI</th>
            </tr>
          </thead>
          <tbody id="amortBody"></tbody>
        </table>
      </div>
    </div>

  </div>

  <div class="drawer-footer">
    <div class="actions">
      <button class="btn" id="printBtn">Print</button>
      <button class="btn primary" id="copyCsvBtn">Copy CSV</button>
    </div>
  </div>

</aside>


  <div id="tooltip" class="tooltip" role="status" aria-live="polite"></div>

  <!-- ====================================
       Script (organized with sections)
       ==================================== -->
  <script type="module">
    import { buildAmortSchedule } from "../js/loanEngine.js";

  const PAGE_USER =
  new URLSearchParams(window.location.search).get("user") || "jeff";

    const USER_LABELS = {
  jeff: "Jeff Customer",
  nick: "Nick Lender",
  john: "John Investor"
};

    
    function addMonths(date, months) {
      const d = new Date(date);
      d.setMonth(d.getMonth() + months);
      return d;
    }

    function formatDate(date) {
      return date.toLocaleDateString("en-US", {
        year: "numeric",
        month: "short",
        day: "numeric"
      });
    }

    function formatMonthYear(date) {
      return date.toLocaleDateString("en-US", {
        year: "numeric",
        month: "short"
      });
    }

function formatCurrency(val) {
  return Number(val ?? 0).toLocaleString("en-US", {
    minimumFractionDigits: 2,
    maximumFractionDigits: 2
  });
}

function createBadgeTooltip(badge, text) {
  const tooltip = document.createElement('div');
  tooltip.className = 'badge-tooltip';
  tooltip.textContent = text;
  document.body.appendChild(tooltip);  // Append to body to escape clipping

  badge.addEventListener('mouseenter', (e) => {
    const badgeRect = badge.getBoundingClientRect();
    const tooltipRect = tooltip.getBoundingClientRect();
    const margin = 8;  // Space above badge

    // Position above the badge, centered horizontally
    let left = badgeRect.left + (badgeRect.width / 2) - (tooltipRect.width / 2);
    let top = badgeRect.top - tooltipRect.height - margin;

    // Clamp to viewport (prevent off-screen)
    left = Math.max(0, Math.min(left, window.innerWidth - tooltipRect.width));
    top = Math.max(0, top);  // Don't go above top edge

    tooltip.style.left = `${left}px`;
    tooltip.style.top = `${top}px`;
    tooltip.classList.add('visible');
  });

  badge.addEventListener('mouseleave', () => {
    tooltip.classList.remove('visible');
  });

  // Clean up on removal (optional, but good practice)
  badge.addEventListener('remove', () => tooltip.remove());
}
    
  function getLoanMaturityFromAmort(loan) {
  if (!loan.amort || !loan.amort.schedule || !loan.amort.schedule.length) {
    return null;
  }

  const lastRow = loan.amort.schedule[loan.amort.schedule.length - 1];
  return lastRow.loanDate ? new Date(lastRow.loanDate) : null;
}

    
    function monthDiff(d1, d2) {
      return (d2.getFullYear() - d1.getFullYear()) * 12 +
             (d2.getMonth() - d1.getMonth());
    }

function buildGlobalDatesFromLoans(loans) {
  const set = new Set();

  loans.forEach(l => {
    if (!l.scheduleWithOwnership) return;

    l.scheduleWithOwnership
      .filter(r => r.isOwned && r.displayDate)
      .forEach(r => set.add(+r.displayDate));
  });

  return Array.from(set)
    .sort((a, b) => a - b)
    .map(ms => new Date(ms));
}

function getLoanEventBadges(loan) {
  const badges = [];
  if (!Array.isArray(loan.events) || loan.events.length === 0) return badges;

  const types = new Set(loan.events.map(e => e.type));

  if (types.has("prepayment")) {
    badges.push({
      type: "prepayment",
      label: "ðŸ’° Prepay"
    });
  }

  if (types.has("deferral")) {
    badges.push({
      type: "deferral",
      label: "â¸ Deferral"
    });
  }

  if (types.has("default")) {
    badges.push({
      type: "default",
      label: "âš ï¸ Default"
    });
  }

  return badges;
}


function getEventRowClass(loan, row) {
  if (!row || !row.displayDate) return "";

  // ----------------------------------
  // DEFERRAL â€” authoritative from engine
  // ----------------------------------
  if (row.isOwned && row.isDeferred === true) {
    return "event-deferral";
  }

  // ----------------------------------
  // DEFAULT / PREPAYMENT (single month)
  // ----------------------------------
  if (Array.isArray(loan.events)) {
    const rowKey =
      row.displayDate.getFullYear() * 12 + row.displayDate.getMonth();

    for (const e of loan.events) {
      if (!e.date) continue;

      const d = new Date(e.date);
      const eventKey =
        d.getFullYear() * 12 + d.getMonth();

      if (rowKey === eventKey) {
        if (e.type === "default") return "event-default";
        if (e.type === "prepayment") return "event-prepayment";
      }
    }
  }

  return "";
}


    // ----------------------------
    // Bind current user label
    // ----------------------------
    document.getElementById("currentUserLabel").textContent =
      USER_LABELS[PAGE_USER] || "Unknown User";
        
    /* -------------------------
       Settings & data
       ------------------------- */
    // Dynamic loans loaded from backend
    let loans = [];

    async function loadLoans() {
      const res = await fetch("https://loan-dashboard-api.jeff-263.workers.dev/loans");
      const data = await res.json();
      loans = (data.loans || []).map(l => ({
        ...l,
        id: l.loanId,
        name: l.loanName ?? `Loan ${l.loanId}`,
        school: l.school ?? "",
        loanStartDate: l.loanStartDate || "",
        termYears: Number(l.termYears ?? 0),
        graceYears: Number(l.graceYears ?? 0),
        purchasePrice: Number(l.purchasePrice ?? 0),
        nominalRate: Number(l.nominalRate ?? 0),
        upfrontFee: Number(l.upfrontFee ?? 150),
        monthlyFeeStart: Number(l.monthlyFeeStart ?? 9),
      }));
    }
  
    async function initROI() {
      const TODAY = new Date();
      const formatLoanLabel = (loan) => `Loan ${loan.id} â€” ${loan.name} (${loan.school})`;
      // --------------------------------------------------
// FILTER TO CURRENT USER â€” SINGLE SOURCE OF TRUTH
// --------------------------------------------------
const userLoans = loans
  .map(l => ({
    ...l,
    user: l.user ?? "jeff",
    visible: l.visible !== false
  }))
  .filter(l => l.user === PAGE_USER && l.visible === true);

// --------------------------------------------------
// Normalize numeric fields (ONLY user loans)
// --------------------------------------------------
const formattedLoans = userLoans.map(l => ({
  ...l,
  purchasePrice: Number(l.purchasePrice ?? 0),
  nominalRate: Number(l.rate ?? l.nominalRate ?? 0)
}));

      const loansWithAmort = formattedLoans.map(l => {
    
const rawAmort = buildAmortSchedule(l);

const amortSchedule = rawAmort;

      // Attach ownership flags
      const purchase = new Date(l.purchaseDate);
      const scheduleWithOwnership = amortSchedule.map(r => ({
        ...r,
        isOwned: r.loanDate >= purchase,
        ownershipMonthIndex: r.loanDate >= purchase
          ? monthDiff(purchase, r.loanDate) + 1
        : 0,
      ownershipDate: r.loanDate >= purchase ? r.loanDate : null
    }));

        
    // Build cumulative values only for owned rows
      let cumP = 0, cumI = 0, cumFees = 0;
      const cumSchedule = scheduleWithOwnership.map(r => {
        if (r.isOwned) {
        cumP += r.principalPaid;
        cumI += r.interest;
        const feeThisMonth = Number(r.feeThisMonth ?? 0);
        cumFees += feeThisMonth;
      }
      return {
        ...r,
      cumPrincipal: +cumP.toFixed(2),
      cumInterest: +cumI.toFixed(2),
      cumFees: +cumFees.toFixed(2)
    };
    });

    // Compute proper ROI timeline using correct amort + fees
    const purchasePrice = Number(l.purchasePrice ?? 0);
    const roiSeries = cumSchedule
      .filter(r => r.isOwned)
.map(r => {
  const realized = (r.cumPrincipal + r.cumInterest) - r.cumFees;
  const unrealized = r.balance * 0.95;
  const loanValue = realized + unrealized;
  const roi = (loanValue - purchasePrice) / purchasePrice;
  return {
    month: r.ownershipMonthIndex,
    date: r.displayDate,        // ðŸ”‘ canonical date
    roi,
    loanValue,
    cumFees: r.cumFees,
    realized,
    remainingBalance: r.balance,
    unrealized
  };
});


    // Return updated loan object
    return {
    ...l,
    amort: { schedule: amortSchedule },
    scheduleWithOwnership,
    cumSchedule,
    balanceAtPurchase: amortSchedule.find(r => r.loanDate >= purchase)?.balance ?? 0,
    roiSeries
  };
});

      const currentLoans = loansWithAmort;

      
    /* -------------------------
       KPI computations
       ------------------------- */

      // -------------------------------------
      // KPI COLOR MAP â€” HIGH-CONTRAST FIRST
      // -------------------------------------
      window.KPI_COLOR_MAP = {};
      
      // 1) Hand-picked, visually maximized contrast palette
      // Carefully ordered to avoid adjacent hue confusion
      const BASE_DISTINCT_COLORS = [
        '#2563eb', // blue
        '#dc2626', // red
        '#16a34a', // green
        '#7c3aed', // purple
        '#ea580c', // orange
        '#0891b2', // cyan
        '#ca8a04', // amber
        '#be185d', // rose
        '#15803d', // dark green
        '#1d4ed8', // deep blue
        '#9333ea', // violet
        '#b91c1c'  // dark red
      ];
      
      // 2) Fallback generator ONLY if loans exceed base palette
      function generateExtraColors(n) {
        const colors = [];
        for (let i = 0; i < n; i++) {
          const hue = (i * 137.508) % 360;
          colors.push(`hsl(${hue.toFixed(0)} 80% 55%)`);
        }
        return colors;
      }
      
      // 3) Stable ordering (important!)
      const sortedLoansForColors = currentLoans
      .slice()
      .sort((a, b) => (a.id ?? a.loanId) - (b.id ?? b.loanId));

      
      // 4) Build final palette
      const extraNeeded = Math.max(0, sortedLoansForColors.length - BASE_DISTINCT_COLORS.length);
      const palette = BASE_DISTINCT_COLORS.concat(generateExtraColors(extraNeeded));
      
      // 5) Assign colors deterministically
      sortedLoansForColors.forEach((loan, i) => {
        const id = loan.id ?? loan.loanId;
        window.KPI_COLOR_MAP[id] = palette[i];
      });
      
function getCurrentOwnedRoiEntry(loan){
  const today = new Date();
  const ownedEntries = loan.roiSeries.filter(
    r => r.date && r.date <= today
  );
  if (!ownedEntries.length) {
    return { roi: 0, loanValue: loan.purchasePrice };
  }
  return ownedEntries[ownedEntries.length - 1];
}


    function getLastOwnedRoiEntry(loan){
      if (!loan.roiSeries || !loan.roiSeries.length) return { roi: 0, loanValue: loan.purchasePrice };
      return loan.roiSeries[loan.roiSeries.length - 1];
    }

function computeKPIs(list) {
  const total = list.reduce((s, l) => s + l.purchasePrice, 0);

  // -------------------------------------
  // Weighted ROI to Date (unchanged)
  // -------------------------------------
  const weightedROI =
    list.reduce((s, l) => {
      const entry = getCurrentOwnedRoiEntry(l);
      return s + l.purchasePrice * (entry.roi || 0);
    }, 0) / Math.max(1, total);

  // -------------------------------------
  // Projected Weighted ROI (unchanged)
  // -------------------------------------
  const projectedWeightedROI =
    list.reduce(
      (s, l) =>
        s +
        l.purchasePrice *
          ((l.roiSeries[l.roiSeries.length - 1] || {}).roi || 0),
      0
    ) / Math.max(1, total);

    // -------------------------------------
    // Capital Recovery (TO TODAY, FIXED)
    // -------------------------------------
    const TODAY = new Date();
    TODAY.setHours(23, 59, 59, 999);
    
    let recoveredPrincipalTotal = 0;
    let investedPrincipalTotal = 0;
    
    list.forEach(l => {
      if (!l.amort || !l.amort.schedule) return;
    
      // âœ… only owned rows through TODAY
      const recovered = l.amort.schedule
        .filter(r => r.isOwned && r.loanDate && r.loanDate <= TODAY)
        .reduce((s, r) => s + (r.principalPaid || 0), 0);
    
      recoveredPrincipalTotal += recovered;
      investedPrincipalTotal += (l.purchasePrice || 0);
    });
    
    const capitalRecoveryPct =
      investedPrincipalTotal > 0
        ? recoveredPrincipalTotal / investedPrincipalTotal
        : 0;

    
        return {
      total,
      weightedROI,
      projectedWeightedROI,
      capitalRecoveredAmount: recoveredPrincipalTotal,
      capitalRecoveryPct
    };

}

    const kpis = computeKPIs(currentLoans);
      
    /* -------------------------
       Small chart utilities (line & bar with hover)
       ------------------------- */
    function createLineChart(containerEl, series, opts = {}) {
      containerEl.innerHTML = '';
      const svgNS = "http://www.w3.org/2000/svg";
      const rect = containerEl.getBoundingClientRect();
      const w = Math.max(360, rect.width || 600);
      const h = opts.h || 260;
      const pad = opts.pad || 48;
      const svg = document.createElementNS(svgNS, "svg");
      svg.setAttribute("viewBox", `0 0 ${w} ${h}`);
      svg.setAttribute("width", "100%");
      svg.setAttribute("height", "100%");
      svg.style.display = "block";

      const data = series.length ? series.slice() : [{ x: 0, y: 0 }];
      const ys = data.map(d => d.y);
      const minY = Math.min(...ys);
      const maxY = Math.max(...ys);
      const rangeY = Math.max(1e-6, maxY - minY);
      const stepX = (w - pad * 2) / Math.max(1, data.length - 1);
      const xForMonth = month => pad + (Math.min(Math.max(month, 1), data.length) - 1) * stepX;
      function toXY(d, i) {
        const x = pad + i * stepX;
        const y = pad + (h - pad * 2) - ((d.y - minY) / rangeY) * (h - pad * 2);
        return [x, y];
      }

      for (let gy = 0; gy < 5; gy++) {
        const y = pad + gy * ((h - pad * 2) / 4);
        const line = document.createElementNS(svgNS, 'line');
        line.setAttribute('x1', pad);
        line.setAttribute('x2', w - pad);
        line.setAttribute('y1', y);
        line.setAttribute('y2', y);
        line.setAttribute('stroke', '#eef2f7');
        svg.appendChild(line);
      }

      let path = '';
      data.forEach((p, i) => {
        const xy = toXY(p, i);
        path += (i === 0 ? ('M ' + xy[0] + ' ' + xy[1]) : (' L ' + xy[0] + ' ' + xy[1]));
      });
      const el = document.createElementNS(svgNS, 'path');
      el.setAttribute('d', path);
      el.setAttribute('fill', 'none');
      el.setAttribute('stroke', opts.color || '#0ea5e9');
      el.setAttribute('stroke-width', '2');
      svg.appendChild(el);

      // Static vertical line at "today" based on ownershipDate
      const today = new Date();
      let todayIdx = -1;
      data.forEach((d, i) => {
  if (d.date && d.date <= today) {
    todayIdx = i;
  }
});

      if (todayIdx === -1) todayIdx = 0;
      const todayX = pad + todayIdx * stepX;
      const todayLine = document.createElementNS(svgNS, "line");
      todayLine.setAttribute("x1", todayX);
      todayLine.setAttribute("x2", todayX);
      todayLine.setAttribute("y1", pad);
      todayLine.setAttribute("y2", h - pad);
      todayLine.setAttribute("stroke", "#111827");
      todayLine.setAttribute("stroke-dasharray", "3 3");
      todayLine.setAttribute("stroke-opacity", "0.6");
      svg.appendChild(todayLine);

      const vLine = document.createElementNS(svgNS, 'line');
      vLine.setAttribute('stroke', '#111827');
      vLine.setAttribute('stroke-dasharray', '3 4');
      vLine.setAttribute('stroke-opacity', '0.6');
      svg.appendChild(vLine);
      const hoverG = document.createElementNS(svgNS, 'g');
      hoverG.setAttribute('class', 'hover');
      svg.appendChild(hoverG);
      svg.addEventListener('mousemove', function (ev) {
        const rect = svg.getBoundingClientRect();
        const svgX = ev.clientX - rect.left;
        let idx = Math.round((svgX - pad) / stepX);
        idx = Math.max(0, Math.min(data.length - 1, idx));
        const point = data[idx];
        const [cx, cy] = toXY(point, idx);
        vLine.setAttribute('x1', cx);
        vLine.setAttribute('x2', cx);
        vLine.setAttribute('y1', pad);
        vLine.setAttribute('y2', h - pad);
        hoverG.innerHTML = '';
        const c = document.createElementNS(svgNS, 'circle');
        c.setAttribute('cx', cx);
        c.setAttribute('cy', cy);
        c.setAttribute('r', 4);
        c.setAttribute('fill', opts.color || '#0ea5e9');
        c.setAttribute('stroke', 'var(--card)');
        c.setAttribute('stroke-width', '1');
        hoverG.appendChild(c);
        tooltip.style.display = 'block';
        tooltip.style.left = (rect.left + cx) + 'px';
        tooltip.style.top = (rect.top + cy - 28) + 'px';
        tooltip.innerHTML = (opts.labelFn ? opts.labelFn(point, idx) : (point.date
  ? `Date: ${formatDate(point.date)} â€¢ ${(point.y * 100).toFixed(2)}%`
: (`M${point.x} â€¢ ${(point.y * 100).toFixed(2)}%`)));
      });
     svg.addEventListener('mouseleave', function () {
    hoverG.innerHTML = '';
    tooltip.style.display = 'none';
    vLine.setAttribute('x1', -9999); 
    vLine.setAttribute('x2', -9999);
});
    // -----------------------------------
    // X AXIS (Month / Year)
    // -----------------------------------
    const xAxis = document.createElementNS(svgNS, 'g');
    const tickEvery = opts.tickEvery || 6;
  
    data.forEach((p, i) => {
      if (i % tickEvery !== 0) return;
  
      const x = pad + i * stepX;
      const lbl = document.createElementNS(svgNS, 'text');
      lbl.setAttribute('x', x);
      lbl.setAttribute('y', h - 8);
      lbl.setAttribute('text-anchor', 'middle');
      lbl.setAttribute('font-size', '10');
      lbl.setAttribute('fill', 'var(--muted)');
      lbl.textContent = p.date
  ? formatMonthYear(p.date)
  : `M${i + 1}`;

  
      xAxis.appendChild(lbl);
    });
  
    svg.appendChild(xAxis);
  
    // -----------------------------------
    // Y AXIS LABEL (% ROI)
    // -----------------------------------
    const yLabel = document.createElementNS(svgNS, 'text');
    yLabel.setAttribute('x', 14);
    yLabel.setAttribute('y', pad - 10);
    yLabel.setAttribute('font-size', '10');
    yLabel.setAttribute('fill', 'var(--muted)');
    yLabel.setAttribute('text-anchor', 'start');
    yLabel.textContent = 'ROI %';
    svg.appendChild(yLabel);

      containerEl.appendChild(svg); return svg;
    }
      
/* ============================================================
   Multi-Series ROI Chart (Aligned by Purchase Date, Smoothed)
   ============================================================ */

function createMultiSeriesChart(containerEl, loanSeriesList, weightedSeries, opts = {}) {
  containerEl.innerHTML = "";
  const svgNS = "http://www.w3.org/2000/svg";

  const rect = containerEl.getBoundingClientRect();
  const w = Math.max(360, rect.width || 700);
  const h = opts.h || (isEmbed ? 240 : 260);
  const pad = opts.pad || (isEmbed ? 20 : 48);

  const svg = document.createElementNS(svgNS, "svg");
  svg.setAttribute("viewBox", `0 0 ${w} ${h}`);
  svg.setAttribute("width", "100%");
  svg.setAttribute("height", "100%");
  svg.style.display = "block";

  // -------------------------
  // Build a unified date axis
  // -------------------------
  const globalDates = opts.dates || [];
  if (!globalDates.length) {
    containerEl.appendChild(svg);
    return;
  }

  const ms0 = globalDates[0].getTime();
  const ms1 = globalDates[globalDates.length - 1].getTime();
  const msRange = ms1 - ms0 || 1;

  const dateToX = (d) => {
    const ratio = (d.getTime() - ms0) / msRange;
    return pad + ratio * (w - pad * 2);
  };

  // -------------------------
  // Y scale (shared)
  // -------------------------
  let ys = [];

  if (!opts.hideWeighted && Array.isArray(weightedSeries)) {
    weightedSeries.forEach(p => ys.push(p.y));
  }

  loanSeriesList.forEach(ls =>
    ls.data.forEach(p => ys.push(p.y))
  );

  const minY = Math.min(...ys);
  const maxY = Math.max(...ys);
  const rangeY = maxY - minY || 1;

  const yScale = (yVal) =>
    pad + (h - pad * 2) - ((yVal - minY) / rangeY) * (h - pad * 2);

  // -----------------------------------
  // Grid + Y labels
  // -----------------------------------
  const steps = 4;
  for (let i = 0; i <= steps; i++) {
    const y = pad + (i / steps) * (h - pad * 2);

    const grid = document.createElementNS(svgNS, "line");
    grid.setAttribute("x1", pad);
    grid.setAttribute("x2", w - pad);
    grid.setAttribute("y1", y);
    grid.setAttribute("y2", y);
    grid.setAttribute("stroke", "var(--border)");
    grid.setAttribute("stroke-opacity", "0.16");
    svg.appendChild(grid);

    const val = maxY - (i / steps) * rangeY;
    const label = document.createElementNS(svgNS, "text");
    label.setAttribute("x", pad - 4);
    label.setAttribute("y", y);
    label.setAttribute("text-anchor", "end");
    label.setAttribute("dominant-baseline", "middle");
    label.setAttribute("font-size", "10");
    label.setAttribute("fill", "var(--muted)");
    label.textContent = (val * 100).toFixed(1) + "%";
    svg.appendChild(label);
  }

  function smoothPathFromPointsCubic(points) {
    if (points.length < 2) return "";
    let d = `M ${points[0][0]} ${points[0][1]}`;
    for (let i = 1; i < points.length; i++) {
      const [x0, y0] = points[i - 1];
      const [x1, y1] = points[i];
      d += ` Q ${x0} ${y0}, ${(x0 + x1) / 2} ${(y0 + y1) / 2}`;
    }
    d += ` T ${points.at(-1)[0]} ${points.at(-1)[1]}`;
    return d;
  }

  // -----------------------------------
  // Loan lines (ALWAYS draw)
  // -----------------------------------
  loanSeriesList.forEach(ls => {
    const pts = ls.data
      .filter(p => p.y != null)
      .map(p => [dateToX(p.date), yScale(p.y)]);

    if (!pts.length) return;

    const path = document.createElementNS(svgNS, "path");
    path.setAttribute("d", smoothPathFromPointsCubic(pts));
    path.setAttribute("fill", "none");
    path.setAttribute("stroke", ls.color || "#888");
    path.setAttribute("stroke-width", "1.2");
    path.setAttribute("stroke-opacity", "0.9");
    path.dataset.type = "loan";
    path.dataset.loanId = String(ls.id);
    svg.appendChild(path);
  });

  // -----------------------------------
  // Weighted line (OPTIONAL)
  // -----------------------------------
  if (!opts.hideWeighted && Array.isArray(weightedSeries) && weightedSeries.length) {
    const pts = weightedSeries.map(p => [dateToX(p.date), yScale(p.y)]);
    const path = document.createElementNS(svgNS, "path");
    path.setAttribute("d", smoothPathFromPointsCubic(pts));
    path.setAttribute("fill", "none");
    path.setAttribute("stroke", opts.weightedColor || "#000");
    path.setAttribute("stroke-width", opts.weightedWidth || "2.6");
    path.dataset.type = "weighted";
    svg.appendChild(path);
  }

  // -----------------------------------
  // TODAY vertical reference line
  // -----------------------------------
  const today = new Date();
  let todayIdx = -1;
  globalDates.forEach((d, i) => {
    if (d <= today) todayIdx = i;
  });

  if (todayIdx >= 0) {
    const todayX = dateToX(globalDates[todayIdx]);
    const todayLine = document.createElementNS(svgNS, "line");
    todayLine.setAttribute("x1", todayX);
    todayLine.setAttribute("x2", todayX);
    todayLine.setAttribute("y1", pad);
    todayLine.setAttribute("y2", h - pad);
    todayLine.setAttribute("stroke", "#111827");
    todayLine.setAttribute("stroke-dasharray", "4 4");
    todayLine.setAttribute("stroke-opacity", "0.55");
    svg.appendChild(todayLine);
  }

  // -----------------------------------
  // X-axis
  // -----------------------------------
  const axis = document.createElementNS(svgNS, "g");
  const tickSpacing = opts.tickSpacingX || 24;

  globalDates.forEach((d, i) => {
    if (i % tickSpacing !== 0) return;
    const t = document.createElementNS(svgNS, "text");
    t.setAttribute("x", dateToX(d));
    t.setAttribute("y", h - 4);
    t.setAttribute("text-anchor", "middle");
    t.setAttribute("font-size", "10");
    t.setAttribute("fill", "var(--muted)");
    t.textContent = formatMonthYear(d);
    axis.appendChild(t);
  });

// -----------------------------------
// Hover interaction (REFINED)
// -----------------------------------
const tooltip = document.getElementById("tooltip");

const vLine = document.createElementNS(svgNS, "line");
vLine.setAttribute("stroke", "#111827");
vLine.setAttribute("stroke-dasharray", "3 4");
vLine.setAttribute("stroke-opacity", "0.6");
svg.appendChild(vLine);

svg.addEventListener("mousemove", ev => {
  const rect = svg.getBoundingClientRect();
  const svgX = ev.clientX - rect.left;

  // snap to nearest date index
  let idx = Math.round(
    ((svgX - pad) / (w - pad * 2)) * (globalDates.length - 1)
  );
  idx = Math.max(0, Math.min(globalDates.length - 1, idx));

  const date = globalDates[idx];
  const x = dateToX(date);

  // vertical hover line
  vLine.setAttribute("x1", x);
  vLine.setAttribute("x2", x);
  vLine.setAttribute("y1", pad);
  vLine.setAttribute("y2", h - pad);

  // -------------------------
  // Build tooltip content
  // -------------------------
  let html = `
    <div style="font-weight:700;margin-bottom:6px">
      ${formatMonthYear(date)}
    </div>
  `;

  // weighted series
  if (!opts.hideWeighted && Array.isArray(weightedSeries)) {
    const wPt = weightedSeries[idx];
    if (wPt && wPt.y != null) {
      html += `
        <div style="margin-bottom:6px">
          <span style="font-weight:600">Weighted:</span>
          ${(wPt.y * 100).toFixed(2)}%
        </div>
      `;
    }
  }

  // per-loan series (SQUARE swatches)
loanSeriesList.forEach(ls => {
  // find last owned point at or before hovered date
  const pt = ls.data
    .filter(p => p.date && p.date <= date && p.y != null)
    .slice(-1)[0];

  // ðŸš« not owned yet â†’ do not show
  if (!pt) return;

  html += `
    <div style="display:flex;gap:8px;align-items:center;margin-bottom:2px">
      <span style="
        width:10px;
        height:10px;
        background:${ls.color || "#888"};
        display:inline-block;
        flex-shrink:0;
      "></span>
      <span>${(pt.y * 100).toFixed(2)}%</span>
    </div>
  `;
});


  tooltip.innerHTML = html;
  tooltip.style.display = "block";

  // -------------------------
  // Cursor-based smart positioning (FIXED)
  // -------------------------
  const ttRect = tooltip.getBoundingClientRect();
  const margin = 12;

  // start from cursor position
  let left = ev.clientX + 14;
  let top  = ev.clientY + 14;

  // flip horizontally if overflowing right edge
  if (left + ttRect.width > window.innerWidth - margin) {
    left = ev.clientX - ttRect.width - 14;
  }

  // flip vertically if overflowing bottom edge
  if (top + ttRect.height > window.innerHeight - margin) {
    top = ev.clientY - ttRect.height - 14;
  }

  // final clamp (safety)
  left = Math.max(margin, Math.min(left, window.innerWidth - ttRect.width - margin));
  top  = Math.max(margin, Math.min(top, window.innerHeight - ttRect.height - margin));

  tooltip.style.left = `${left}px`;
  tooltip.style.top  = `${top}px`;

});

svg.addEventListener("mouseleave", () => {
  tooltip.style.display = "none";
  vLine.setAttribute("x1", -9999);
  vLine.setAttribute("x2", -9999);
});
  
  svg.appendChild(axis);
  containerEl.appendChild(svg);
}

      function smoothMonotonic(points) {
  if (points.length < 2) return "";

  let d = `M ${points[0][0]} ${points[0][1]}`;
  for (let i = 1; i < points.length; i++) {
    const [x0, y0] = points[i - 1];
    const [x1, y1] = points[i];
    const cx = (x0 + x1) / 2;
    d += ` Q ${cx} ${y0}, ${x1} ${y1}`;
  }
  return d;
}

// ============================================================
// ROI SPREAD CHART (loan lines ONLY â€” no weighted line)
// ============================================================
function createROISpreadChart(containerEl, loanSeriesList, opts = {}) {
  containerEl.innerHTML = "";
  const svgNS = "http://www.w3.org/2000/svg";
  const rect = containerEl.getBoundingClientRect();
  const w = Math.max(360, rect.width || 700);
  const h = opts.h || 260;
  const pad = opts.pad || 48;
  const svg = document.createElementNS(svgNS, "svg");
  svg.setAttribute("viewBox", `0 0 ${w} ${h}`);
  svg.setAttribute("width", "100%");
  svg.setAttribute("height", "100%");
  svg.style.display = "block";

  // -------------------------
  // Unified date axis
  // -------------------------
  const globalDates = opts.dates || [];
  if (!globalDates.length) {
    containerEl.appendChild(svg);
    return;
  }
  const ms0 = globalDates[0].getTime();
  const ms1 = globalDates[globalDates.length - 1].getTime();
  const msRange = ms1 - ms0 || 1;
  const dateToX = (d) =>
    pad + ((d.getTime() - ms0) / msRange) * (w - pad * 2);

  // -------------------------
  // Y scale (loan data only)
  // -------------------------
  let ys = [];
  loanSeriesList.forEach(ls => ls.data.forEach(p => {
    if (p.y != null) ys.push(p.y);
  }));
  const minY = Math.min(...ys);
  const maxY = Math.max(...ys);
  const rangeY = maxY - minY || 1;
  const yScale = (yVal) =>
    pad + (h - pad * 2) - ((yVal - minY) / rangeY) * (h - pad * 2);

  // -------------------------
  // Grid + Y labels
  // -------------------------
  const steps = 4;
  for (let i = 0; i <= steps; i++) {
    const y = pad + (i / steps) * (h - pad * 2);
    const grid = document.createElementNS(svgNS, "line");
    grid.setAttribute("x1", pad);
    grid.setAttribute("x2", w - pad);
    grid.setAttribute("y1", y);
    grid.setAttribute("y2", y);
    grid.setAttribute("stroke", "var(--border)");
    grid.setAttribute("stroke-opacity", "0.16");
    svg.appendChild(grid);
    const val = maxY - (i / steps) * rangeY;
    const label = document.createElementNS(svgNS, "text");
    label.setAttribute("x", pad - 4);
    label.setAttribute("y", y);
    label.setAttribute("text-anchor", "end");
    label.setAttribute("dominant-baseline", "middle");
    label.setAttribute("font-size", "10");
    label.setAttribute("fill", "var(--muted)");
    label.textContent = (val * 100).toFixed(1) + "%";
    svg.appendChild(label);
  }

  // -------------------------
  // Draw loan lines ONLY (+ line hover tooltip)
  // -------------------------
  const loanById = new Map(currentLoans.map(l => [String(l.id ?? l.loanId), l]));
  const loanPaths = [];

  function setActiveLoan(activeId){
    loanPaths.forEach(p => {
      const isActive = (p.dataset.loanId === String(activeId));
      p.setAttribute("stroke-opacity", isActive ? "1" : "0.15");
      p.setAttribute("stroke-width", isActive ? "2.6" : "1.2");
    });
  }
  function clearActiveLoan(){
    loanPaths.forEach(p => {
      p.setAttribute("stroke-opacity", "0.9");
      p.setAttribute("stroke-width", "1.2");
    });
    tooltip.style.display = "none";
  }

  loanSeriesList.forEach(ls => {
    const raw = ls.data.filter(p => p.y != null);
if (!raw.length) return;

// Anchor at purchase date to prevent spikes
const anchored = [
  {
    date: raw[0].date,
    y: raw[0].y
  },
  ...raw
];

// Build points
const pts = anchored.map(p => [
  dateToX(p.date),
  yScale(p.y)
]);

    if (!pts.length) return;

    // *** SMOOTH PATH GENERATION ***
    const pathD = smoothMonotonic(pts);
 

    // visible line
    const path = document.createElementNS(svgNS, "path");
    path.setAttribute("d", pathD);
    path.setAttribute("fill", "none");
    path.setAttribute("stroke", ls.color || "#888");
    path.setAttribute("stroke-width", "1.2");
    path.setAttribute("stroke-opacity", "0.9");
    path.dataset.type = "loan";
    path.dataset.loanId = String(ls.id);
    svg.appendChild(path);
    loanPaths.push(path);

    // wide invisible hit target
    const hit = document.createElementNS(svgNS, "path");
    hit.setAttribute("d", pathD);
    hit.setAttribute("fill", "none");
    hit.setAttribute("stroke", "transparent");
    hit.setAttribute("stroke-width", "12");
    hit.setAttribute("stroke-linecap", "round");
    hit.style.pointerEvents = "stroke";
    hit.dataset.loanId = String(ls.id);
    hit.addEventListener("mouseenter", () => setActiveLoan(ls.id));
    hit.addEventListener("mousemove", (ev) => {
      const rect2 = svg.getBoundingClientRect();
      const mouseX = ev.clientX - rect2.left;
      let t = (mouseX - pad) / (w - pad * 2);
      t = Math.max(0, Math.min(1, t));
      let idx = Math.round(t * (globalDates.length - 1));
      idx = Math.max(0, Math.min(globalDates.length - 1, idx));
      const d = globalDates[idx];
      let point = ls.data[idx];
      if (!point || point.y == null) {
        point = ls.data
          .filter(p => p.y != null)
          .reduce((best, p) => {
            if (!best) return p;
            return Math.abs(p.date - d) < Math.abs(best.date - d) ? p : best;
          }, null);
      }
      const loan = loanById.get(String(ls.id));
      const roiPct = point?.y != null ? (point.y * 100) : null;
      tooltip.style.display = "block";
      tooltip.style.left = ev.clientX + "px";
      tooltip.style.top = (ev.clientY - 12) + "px";
      tooltip.innerHTML =
        `<div style="font-weight:800;margin-bottom:2px;">${loan?.name ?? ("Loan " + ls.id)}</div>` +
        `<div style="opacity:.9;margin-bottom:4px;">${loan?.school ?? ""}</div>` +
        `<div style="opacity:.95;">${formatMonthYear(d)}${roiPct == null ? "" : ` â€¢ ${roiPct.toFixed(2)}%`}</div>` +
        `<div style="opacity:.85;margin-top:4px;">Purchased: ${loan?.purchaseDate ?? ""}</div>`;
    });
    hit.addEventListener("mouseleave", clearActiveLoan);
    svg.appendChild(hit);
  });

  // -------------------------
  // X-axis labels
  // -------------------------
  const axis = document.createElementNS(svgNS, "g");
  const tickSpacing = opts.tickSpacingX || 24;
  globalDates.forEach((d, i) => {
    if (i % tickSpacing !== 0) return;
    const t = document.createElementNS(svgNS, "text");
    t.setAttribute("x", dateToX(d));
    t.setAttribute("y", h - 4);
    t.setAttribute("text-anchor", "middle");
    t.setAttribute("font-size", "10");
    t.setAttribute("fill", "var(--muted)");
    t.textContent = formatMonthYear(d);
    axis.appendChild(t);
  });
  svg.appendChild(axis);

  containerEl.appendChild(svg);
}

    /* -------------------------
       UI: Render KPI tiles
       ------------------------- */
    const kpisEl = document.getElementById('kpis');
    kpisEl.innerHTML = `
      <div class="kpi" data-kpi="tpv">
        <h3>Weighted ROI to Date</h3>
        <p id="wroi">${(kpis.weightedROI * 100).toFixed(2)}%</p>
      </div>
    
      <div class="kpi" data-kpi="rates">
        <h3>Projected Weighted ROI</h3>
        <p id="wproj">${(kpis.projectedWeightedROI * 100).toFixed(2)}%</p>
      </div>
    
      <div class="kpi" data-kpi="capitalRecovery">
        <h3>Capital Recovered</h3>
        <p>${(kpis.capitalRecoveryPct * 100).toFixed(2)}%</p>
      </div>

    
      <div class="kpi" data-kpi="spread">
        <h3>ROI Spread</h3>
        <p id="roiSpread"></p>
      </div>
    `;


      // -------------------------------
      // KPI4 â€” ROI Spread value (SAFE)
      // -------------------------------
      const roiValues = currentLoans.map(l => {
      const e = getCurrentOwnedRoiEntry(l);
      return e?.roi ?? 0;
    });
    ;
      
      const minROI = Math.min(...roiValues);
      const maxROI = Math.max(...roiValues);
      const roiSpread = maxROI - minROI;
      
      document.getElementById("roiSpread").textContent =
        (roiSpread * 100).toFixed(2) + "%";
      
      
    /* -------------------------
       Render loan tiles + mini charts
       ------------------------- */
    const grid = document.getElementById('loanGrid');
    const tooltip = document.getElementById('tooltip');

    currentLoans
      .slice()
      .sort((a, b) => new Date(a.purchaseDate) - new Date(b.purchaseDate))
      .forEach((loan, idx) => {

      const currentRoiEntry = getCurrentOwnedRoiEntry(loan);
      const tile = document.createElement('div'); tile.className='tile'; tile.setAttribute('tabindex','0');
        tile.dataset.loanName = (loan.name || "").toLowerCase();
        tile.dataset.school = (loan.school || "").toLowerCase();
        tile.dataset.rate = loan.nominalRate;
        tile.dataset.purchaseDate = new Date(loan.purchaseDate).getTime();
        tile.dataset.startDate = new Date(loan.loanStartDate).getTime();
        tile.dataset.amount = Number(loan.purchasePrice || 0);


const badges = getLoanEventBadges(loan);

const badgeHtml = badges.length
  ? `
    <div class="loan-badges">
      ${badges.map(b =>
        `<span class="loan-badge ${b.type}">${b.label}</span>`
      ).join("")}
    </div>`
  : "";

        
      tile.innerHTML = `
        <div class="tile-left">

        <!-- Line 1: Loan Name -->
        <div class="loan-name" style="font-weight:700; font-size:14px;">
        ${loan.name || loan.loanName || ("Loan " + loan.id)}
       </div>

    ${badgeHtml}

        <!-- Line 2: School -->
        <div class="loan-name" style="font-weight:700; font-size:14px; margin-top:2px;">
        ${loan.school || "No school listed"}
       </div>

        <!-- Line 3: Rate Â· Term Â· Matures -->
        <div class="loan-sub" style="margin-top:6px;">
        Rate: ${(loan.nominalRate * 100).toFixed(2)}% &nbsp;Â·&nbsp;
        Term: ${loan.termYears} yrs &nbsp;Â·&nbsp;
        Matures: ${
          (() => {
            const m = getLoanMaturityFromAmort(loan);
            return m ? formatMonthYear(m) : "â€”";
          })()
        }

        </div>

        <!-- Line 4: Loan ID -->
        <div class="loan-sub" style="margin-top:4px;">
         Loan ${loan.id}
      </div>

    </div>

    <div class="chart-wrap">
      <div class="mini-label">
      ROI ${(currentRoiEntry.roi * 100).toFixed(2)}%
    </div>
    <svg class="sparkline" viewBox="0 0 170 48" preserveAspectRatio="none" data-idx="${idx}" aria-hidden="true"></svg>
  </div>
`;

// After tile.innerHTML is set, attach tooltips to badges
const badgeElements = tile.querySelectorAll('.loan-badge');
badgeElements.forEach((badgeEl, index) => {
  const badgeData = badges[index]; // Matches order from getLoanEventBadges
  if (!badgeData) return;

  const type = badgeData.type;
  const eventsOfType = loan.events.filter(e => e.type === type);

  let tooltipText = '';

  if (type === 'prepayment') {
    tooltipText = eventsOfType.map(e => {
      const date = new Date(e.date);
      return `Prepayment\nDate: ${date.toLocaleDateString()}\nAmount: $${Number(e.amount || 0).toLocaleString()}`;
    }).join('\n\n');
  } else if (type === 'deferral') {
    tooltipText = eventsOfType.map(e => {
      const start = new Date(e.startDate);
      const end = new Date(start);
      end.setMonth(end.getMonth() + Number(e.months || 0));
      return `Deferral\nStart: ${start.toLocaleDateString(undefined, {month: 'short', year: 'numeric'})}\nDuration: ${e.months} months\nEnd: ${end.toLocaleDateString(undefined, {month: 'short', year: 'numeric'})}`;
    }).join('\n\n');
  } else if (type === 'default') {
    const e = eventsOfType[0]; // Assume one default
    if (!e) return;

    const defDate = new Date(e.date);
    const recovered = Number(e.recoveryAmount || 0);

    // Find the default row in amort schedule (matches month/year)
    const defYear = defDate.getFullYear();
    const defMonth = defDate.getMonth();
    const defaultRow = loan.amort.schedule.find(r =>
      r.loanDate.getFullYear() === defYear && r.loanDate.getMonth() === defMonth
    );

    let remaining = 0;
    if (defaultRow) {
      const balanceAtDefault = defaultRow.balance + recovered; // Reconstruct balance before recovery
      remaining = balanceAtDefault - recovered; // Remaining (loss) after recovery
    }

    tooltipText = `Default\nDate: ${defDate.toLocaleDateString(undefined, {month: 'short', year: 'numeric'})}\nRecovered: $${recovered.toLocaleString()}\nRemaining: $${remaining.toLocaleString()}`;
  }

  if (tooltipText) {
    createBadgeTooltip(badgeEl, tooltipText);
  }
});
        
      tile.addEventListener('click', e=>{ e.stopPropagation(); openDrawerForLoan(loan); });
      tile.addEventListener('keydown', e=>{ if(e.key==='Enter'||e.key===' '){ e.preventDefault(); openDrawerForLoan(loan); } });
      grid.appendChild(tile);

      // render mini chart: cumulative ROI points
      const svg = tile.querySelector('svg.sparkline');
      const w=170,h=48,pad=6;
      const pts = loan.roiSeries.map(s => ({
  y: s.roi,
  date: s.date
}));


      const ys = pts.map(p=>p.y); const minY=Math.min(...ys); const maxY=Math.max(...ys); const rangeY=Math.max(1e-6,maxY-minY);
      const stepX=(w-pad*2)/Math.max(1,pts.length-1);
      let d=''; pts.forEach((p,i)=>{ const x=pad + i*stepX; const y = pad + (h - pad*2) - ((p.y - minY)/rangeY)*(h - pad*2); d += (i===0?('M '+x+' '+y):(' L '+x+' '+y)); });
      svg.innerHTML = `<path d="${d}" fill="none" stroke="#0ea5e9" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"></path><g class="mini-hover"></g>`;
      // vertical line at "today" based on ownershipDate in roiSeries
      const today = new Date();
      // find index of last roiSeries entry whose ownershipDate <= today
      let todayIdxFull = -1;
      loan.roiSeries.forEach((entry, i) => {
  if (entry.date && entry.date <= today) {
    todayIdxFull = i;
  }
});

      if (todayIdxFull === -1) todayIdxFull = 0;

      // map into the pts array used for the mini chart (pts may be a slice of roiSeries)
      const maxIdxInPts = pts.length - 1;
      const todayIdx = Math.max(0, Math.min(maxIdxInPts, todayIdxFull));
      const dashX = pad + todayIdx * stepX;

      const line = document.createElementNS('http://www.w3.org/2000/svg','line');
      line.setAttribute('x1', dashX);
      line.setAttribute('x2', dashX);
      line.setAttribute('y1', 2);
      line.setAttribute('y2', h - 2);
      line.setAttribute('stroke', '#111827');
      line.setAttribute('stroke-dasharray', '3 3');
      line.setAttribute('stroke-opacity', '0.6');
      svg.appendChild(line);
      svg.addEventListener('mousemove', ev=>{ const rect=svg.getBoundingClientRect(); const relX=ev.clientX-rect.left; const step = (w-pad*2)/Math.max(1,pts.length-1); let idxNearest=Math.round((relX-pad)/step); idxNearest=Math.max(0,Math.min(pts.length-1,idxNearest)); const p = loan.roiSeries[idxNearest]; tooltip.style.left=ev.clientX+'px'; tooltip.style.top=(ev.clientY-10)+'px'; tooltip.style.display='block'; tooltip.innerHTML =
  'Date: ' + formatDate(p.date) +
  ' â€¢ ROI ' + (p.roi * 100).toFixed(2) + '%';
 const hoverG = svg.querySelector('g.mini-hover'); hoverG.innerHTML=''; const cx = pad + idxNearest*step; const cy = pad + (h - pad*2) - ((p.roi - minY)/rangeY)*(h - pad*2); const c=document.createElementNS('http://www.w3.org/2000/svg','circle'); c.setAttribute('cx',cx); c.setAttribute('cy',cy); c.setAttribute('r',3.6); c.setAttribute('fill','#0ea5e9'); c.setAttribute('stroke','var(--card)'); c.setAttribute('stroke-width','1'); hoverG.appendChild(c); });
      svg.addEventListener('mouseleave', ()=>{ tooltip.style.display='none'; const hoverG = svg.querySelector('g.mini-hover'); if(hoverG) hoverG.innerHTML=''; });
    });

    // -------------------------
    // Populate filter dropdowns
    // -------------------------
    const nameSelect = document.getElementById("filterName");
    const schoolSelect = document.getElementById("filterSchool");
    
    const uniqueNames = [...new Set(currentLoans.map(l => l.name).filter(Boolean))];
    const uniqueSchools = [...new Set(currentLoans.map(l => l.school).filter(Boolean))];

    
    uniqueNames.forEach(n => {
      const opt = document.createElement("option");
      opt.value = n.toLowerCase();
      opt.textContent = n;
      nameSelect.appendChild(opt);
    });
    
    uniqueSchools.forEach(s => {
      const opt = document.createElement("option");
      opt.value = s.toLowerCase();
      opt.textContent = s;
      schoolSelect.appendChild(opt);
    });

      function applyLoanFilters() {
  const nameVal = document.getElementById("filterName").value;
  const schoolVal = document.getElementById("filterSchool").value;
  const rateVal = document.getElementById("filterRate").value;

  document.querySelectorAll("#loanGrid .tile").forEach(tile => {
    let show = true;

    if (nameVal && !tile.dataset.loanName.includes(nameVal)) {
      show = false;
    }

    if (schoolVal && !tile.dataset.school.includes(schoolVal)) {
      show = false;
    }

    if (rateVal) {
      const rate = Number(tile.dataset.rate) * 100;
      if (
        (rateVal === "low" && rate >= 5) ||
        (rateVal === "mid" && (rate < 5 || rate > 8)) ||
        (rateVal === "high" && rate <= 8)
      ) {
        show = false;
      }
    }

    tile.style.display = show ? "" : "none";
  });
    applyLoanSort();
}

function applyLoanSort() {
  const grid = document.getElementById("loanGrid");
  const mode = sortLoans.value;
  const tiles = Array.from(grid.children)
    .filter(t => t.style.display !== "none");
  const get = (el, k) => Number(el.dataset[k] || 0);
  tiles.sort((a, b) => {
    switch (mode) {
      case "purchase_asc": return get(a,"purchaseDate") - get(b,"purchaseDate");
      case "purchase_desc": return get(b,"purchaseDate") - get(a,"purchaseDate");
      case "start_asc": return get(a,"startDate") - get(b,"startDate");
      case "start_desc": return get(b,"startDate") - get(a,"startDate");
      case "amount_asc": return get(a,"amount") - get(b,"amount");
      case "amount_desc": return get(b,"amount") - get(a,"amount");
      case "rate_asc": return get(a,"rate") - get(b,"rate");
      case "rate_desc": return get(b,"rate") - get(a,"rate");
      default: return 0;
    }
  });

  tiles.forEach(t => grid.appendChild(t));
}

    document.getElementById("filterName").addEventListener("change", applyLoanFilters);
    document.getElementById("filterSchool").addEventListener("change", applyLoanFilters);
    document.getElementById("filterRate").addEventListener("change", applyLoanFilters);
    document.getElementById("sortLoans").addEventListener("change", applyLoanSort);
    document.getElementById("resetFilters").addEventListener("click", () => {
      document.getElementById("filterName").value = "";
      document.getElementById("filterSchool").value = "";
      document.getElementById("filterRate").value = "";
      applyLoanFilters();
    });
    
    /* -------------------------
   Compact tile toggle (persisted)
   ------------------------- */
    const compactToggle = document.getElementById("toggleCompact");
    const loanGrid = document.getElementById("loanGrid");
    
    // Restore saved preference
    const savedCompact = localStorage.getItem("loanGridCompact");
    if (savedCompact !== null) {
      compactToggle.checked = savedCompact === "true";
    }
    
    // Apply initial state
    loanGrid.classList.toggle("compact", compactToggle.checked);
    
    // Persist on change
    compactToggle.addEventListener("change", () => {
      loanGrid.classList.toggle("compact", compactToggle.checked);
      localStorage.setItem("loanGridCompact", compactToggle.checked);
    });

      
    /* -------------------------
       Drawer helpers & openers
       ------------------------- */
    const drawer = document.getElementById('drawer');
    const drawerTitle = document.getElementById('drawerTitle');
    const drawerSub = document.getElementById('drawerSub');
    const drawerPrimaryTitle = document.getElementById('drawerPrimaryTitle');
    const drawerPrimary = document.getElementById('drawerPrimary');
    const drawerSecondaryTitle = document.getElementById('drawerSecondaryTitle');
    const drawerSecondary = document.getElementById('drawerSecondary');
    const drawerChartArea = document.getElementById('drawerChartArea');
    const drawerLegend = document.getElementById('drawerLegend');
    const drawerExtra = document.getElementById('drawerExtra');
    const drawerAmortContainer = document.getElementById('drawerAmortContainer');

    document.getElementById('closeBtn').addEventListener('click', closeDrawer);
    document.addEventListener('keydown', (e)=>{ if(e.key==='Escape') closeDrawer(); });

    function closeDrawer(){ drawer.classList.remove('open'); drawer.setAttribute('aria-hidden','true'); tooltip.style.display='none'; currentLoan=null; currentMode=null; }

    let currentLoan=null, currentMode=null;

    
function populateROILoanTable(){
  const tbody = document.querySelector("#roiLoansTable tbody");
  if(!tbody) return;

  tbody.innerHTML = loansWithAmort.map(l => {
    const roiEntry = getCurrentOwnedRoiEntry(l);

    let matStr = '';
    try {
      const pd = new Date(l.purchaseDate);
      const months = Math.round((l.termYears + l.graceYears) * 12);
      pd.setMonth(pd.getMonth() + months);
      matStr = pd.toISOString().slice(0,10);
    } catch(e) {
      matStr = '';
    }

    const roiPct = (roiEntry.roi || 0) * 100;
    const id = l.id ?? l.loanId;
    const color = window.KPI_COLOR_MAP?.[id] || '#64748b';

    // âœ… ADD data-loan-id HERE
    return `<tr data-loan-id="${id}">
      <td style="text-align:left;">
        <span style="
          display:inline-block;
          width:10px;
          height:10px;
          background:${color};
          border-radius:2px;
          margin-right:8px;
          vertical-align:middle;
        "></span>
        <strong>${l.name}</strong>
        <div style="font-size:12px;color:var(--muted)">${l.school || ""}</div>
      </td>
      <td style="text-align:left;">${l.purchaseDate}</td>
      <td style="text-align:left;">${matStr}</td>
      <td style="text-align:right;color:${color};font-weight:700">
        ${roiPct.toFixed(2)}%
      </td>
    </tr>`;
  }).join('');
    
      const chartSvg = drawerChartArea.querySelector("svg");
      if (!chartSvg) return;
    
      const table = document.getElementById("roiLoansTable");
      if (!table) return;
    
      const loanPaths = Array.from(
        chartSvg.querySelectorAll('path[data-type="loan"]')
      );

      table.querySelectorAll("tbody tr").forEach(row => {
        const rowLoanId = row.dataset.loanId;
        if (!rowLoanId) return;
    
    row.addEventListener("mouseenter", () => {
      loanPaths.forEach(p => {
        const isTarget = p.dataset.loanId === rowLoanId;
    
        p.setAttribute("stroke-opacity", isTarget ? "1" : "0.15");
        p.setAttribute("stroke-width", "1.2"); // KEEP ALL LINES SAME WIDTH
      });
    });
    
    row.addEventListener("mouseleave", () => {
      loanPaths.forEach(p => {
        p.setAttribute("stroke-opacity", "0.9");
        p.setAttribute("stroke-width", "1.2");
      });
    });
   });
 }

function populateProjectedROILoanTable(){
  const tbody = document.querySelector("#roiProjectedLoansTable tbody");
  if(!tbody) return;

  tbody.innerHTML = loansWithAmort.map(l => {
    const roiEntry = getLastOwnedRoiEntry(l);

    let matStr = '';
    try {
      const pd = new Date(l.purchaseDate);
      const months = Math.round((l.termYears + l.graceYears) * 12);
      pd.setMonth(pd.getMonth() + months);
      matStr = pd.toISOString().slice(0,10);
    } catch(e) {
      matStr = '';
    }

    const roiPct = (roiEntry.roi || 0) * 100;
    const id = l.id ?? l.loanId;
    const color = window.KPI_COLOR_MAP?.[id] || '#64748b';

    return `<tr data-loan-id="${id}">
      <td style="text-align:left;">
        <span style="
          display:inline-block;
          width:10px;
          height:10px;
          background:${color};
          border-radius:2px;
          margin-right:8px;
          vertical-align:middle;
        "></span>
        <strong>${l.name}</strong>
        <div style="font-size:12px;color:var(--muted)">${l.school || ""}</div>
      </td>
      <td style="text-align:left;">${l.purchaseDate}</td>
      <td style="text-align:left;">${matStr}</td>
      <td style="text-align:right;color:${color};font-weight:700">
        ${roiPct.toFixed(2)}%
      </td>
    </tr>`;
  }).join('');

  // ---------- hover logic ----------
  // Ensure we bind to the MOST RECENT chart SVG
  const svgs = drawerChartArea.querySelectorAll("svg");
  if (!svgs.length) return;
  const chartSvg = svgs[svgs.length - 1];


  const table = document.getElementById("roiProjectedLoansTable");
  if (!table) return;

  const loanPaths = Array.from(
    chartSvg.querySelectorAll('path[data-type="loan"]')
  );
  const weightedPath = chartSvg.querySelector('path[data-type="weighted"]');

  table.querySelectorAll("tbody tr").forEach(row => {
    const rowLoanId = row.dataset.loanId;
    if (!rowLoanId) return;

    row.addEventListener("mouseenter", () => {
      loanPaths.forEach(p => {
        if (p.dataset.loanId === rowLoanId) {
          p.setAttribute("stroke-opacity", "1");
          p.setAttribute("stroke-width", "3");
        } else {
          p.setAttribute("stroke-opacity", "0.15");
          p.setAttribute("stroke-width", "1");
        }
      });

      // weighted projected line stays neutral
      if (weightedPath) {
        weightedPath.setAttribute("stroke-opacity", "1");
      }
    });

    row.addEventListener("mouseleave", () => {
      loanPaths.forEach(p => {
        p.setAttribute("stroke-opacity", "0.9");
        p.setAttribute("stroke-width", "1.2");
      });

      if (weightedPath) {
        weightedPath.setAttribute("stroke-opacity", "1");
      }
    });
  });
}

function getEventRowClass(loan, row) {
  if (!Array.isArray(loan.events) || !row.displayDate) return "";

  const rowMonth =
    row.displayDate.getFullYear() + "-" + row.displayDate.getMonth();

  for (const e of loan.events) {
    if (!e.date) continue;
    const d = new Date(e.date);
    const eventMonth = d.getFullYear() + "-" + d.getMonth();

    if (eventMonth === rowMonth) {
      if (e.type === "default") return "event-default";
      if (row.isOwned && row.isDeferral) {
  return 'event-deferral';
}
      if (e.type === "prepayment") return "event-prepayment";
    }
  }
  return "";
}

      
function openDrawerForLoan(loan){
  currentMode = 'loan';
  currentLoan = loan;
  drawerAmortContainer.style.display = '';
  drawer.classList.add('loan-mode');
  // --- loan drawer heading (match earnings structure) ---
  drawerTitle.textContent = loan.name || ("Loan " + loan.id);
  drawerSub.innerHTML = `
    ${loan.school || "No school"}<br>
    Purchased ${loan.purchaseDate}
    â€¢ Orig Loan Amt $${Number(
      loan.originalLoanAmount ||
      loan.origLoanAmount ||
      loan.loanAmount ||
      0
    ).toLocaleString()}
    â€¢ Loan Purchase Price $${Number(loan.purchasePrice || 0).toLocaleString()}
  `;
  drawerPrimaryTitle.textContent = 'Orig Loan Amount';
  drawerPrimary.textContent = '$' + loan.purchasePrice.toLocaleString();
  drawerSecondaryTitle.textContent = 'Nominal Rate';
  drawerSecondary.textContent = (loan.nominalRate * 100).toFixed(2) + '%';
  drawerExtra.innerHTML = '';
  drawerLegend.style.display = 'none';
  drawerLegend.innerHTML = '';
  // --------------------------------------------------
  // ROI LINE CHART (use canonical date)
  // --------------------------------------------------
  const series = loan.roiSeries.map(s => ({
    x: formatMonthYear(s.date), // âœ… displayDate-derived
    y: s.roi,
    date: s.date
  }));
  createLineChart(drawerChartArea, series, {
    color: '#0ea5e9',
    loanStartDate: loan.loanStartDate,
    tickEvery: 12,
    labelFn: (pt) =>
      `Date: ${formatDate(pt.date)} â€¢ ROI ${(pt.y * 100).toFixed(2)}%`
  });
  // --------------------------------------------------
  // ROI-BY-MONTH TABLE (use displayDate)
  // --------------------------------------------------
drawerAmortContainer.innerHTML = `
  <h3 style="margin-top:8px">ROI by Month</h3>
  <div class="amort-wrap">
    <table>
      <thead>
        <tr>
          <th>Month</th>
          <th style="text-align:right">Balance</th>
          <th style="text-align:right">Loan Value</th>
          <th style="text-align:right">ROI</th>
        </tr>
      </thead>
      <tbody id="roiBody"></tbody>
    </table>
  </div>
`;
  const roiBody = document.getElementById('roiBody');
  roiBody.innerHTML = '';
loan.roiSeries.forEach(s => {
  const cs =
    loan.cumSchedule.find(r => r.ownershipMonthIndex === s.month) || {};
  console.log(
  "[ROI TABLE ROW]",
  formatMonthYear(cs.displayDate),
  "isDeferred =", cs.isDeferred,
  "remaining =", cs.deferralRemaining
);
  const tr = document.createElement('tr');

  // Shade deferral months
  if (cs.isDeferred) {
    tr.style.background = 'rgba(234,179,8,0.08)';
  }

  const rowClass = getEventRowClass(loan, cs);
  if (rowClass) tr.classList.add(rowClass);
  const monthLabel =
    cs.displayDate instanceof Date
      ? formatMonthYear(cs.displayDate)
      : '';
  tr.innerHTML = `
    <td style="text-align:left">${monthLabel}</td>
    <td style="text-align:right">$${formatCurrency(cs.balance)}</td>
    <td style="text-align:right">$${formatCurrency(s.loanValue)}</td>
    <td style="text-align:right">${((s.roi || 0) * 100).toFixed(2)}%</td>
  `;
  roiBody.appendChild(tr);
});
  drawer.classList.add('open');
  drawer.setAttribute('aria-hidden', 'false');
  drawer.scrollTop = 0;
}


    /* ============================================
   HISTORICAL ROI TIMELINE ENGINE
   Builds a unified date-based ROI timeline
   For all loans, from earliest purchase â†’ today
   ============================================ */

function buildHistoricalRoiTimeline(loans) {
  const today = new Date();

  // ---- 1. Determine global timeline ----
  const earliestPurchase = loans.reduce((earliest, l) => {
    const d = new Date(l.purchaseDate);
    return d < earliest ? d : earliest;
  }, new Date(loans[0].purchaseDate));

  // Build monthly date list from earliest â†’ today
  const dates = [];
  const cursor = new Date(earliestPurchase);
  while (cursor <= today) {
    dates.push(new Date(cursor));
    cursor.setMonth(cursor.getMonth() + 1);
  }

  // ---- 2. Align each loan ROI onto the global date timeline ----
  const perLoanSeries = loans.map((loan, idx) => {
    const purchase = new Date(loan.purchaseDate);
    const id = loan.id ?? loan.loanId;
    const color = window.KPI_COLOR_MAP?.[id] || '#64748b';


    // Map ownershipDate -> ROI for quick lookup
    const roiMap = {};
    loan.cumSchedule.forEach(row => {
    if (!row.isOwned) return;

    const realized = (row.cumPrincipal + row.cumInterest) - row.cumFees;
    const unrealized = row.balance * 0.95;
    const loanValue = realized + unrealized;

    const roi = (loanValue - loan.purchasePrice) / loan.purchasePrice;

    const key = row.loanDate.toISOString().slice(0, 7);
    roiMap[key] = roi;
});


   // Build calendar-aligned ROI (null before purchase)
    // Initialize to the ROI of the first owned month to avoid a spike
    const roiKeys = Object.keys(roiMap).sort();
    let lastKnownROI = roiKeys.length ? roiMap[roiKeys[0]] : 0;
    
    const data = dates.map(date => {
      if (date < purchase) {
      return { date, y: null };
      }

    const key = date.toISOString().slice(0, 7);

    if (key in roiMap) {
    lastKnownROI = roiMap[key];
    }

    // forward-fill ROI after purchase
    return { date, y: lastKnownROI };
    });

    const displayName = loan.name || loan.loanName || `Loan ${id}`;
    
    return {
      id,
      name: displayName,
      color,
      data
    };
  });

  // ---- 3. Build weighted ROI series ----
  const totalInvested = loans.reduce((s, l) => s + l.purchasePrice, 0);

  const weightedSeries = dates.map((date, i) => {
    let weightedSum = 0;

    loans.forEach((loan, idx) => {
      const roi = perLoanSeries[idx].data[i].y;
      if (roi != null) {
        weightedSum += roi * loan.purchasePrice;
      }
    });

    const weightedRoi = weightedSum / totalInvested;

    return { date, y: weightedRoi };
  });

  return {
    dates,
    perLoanSeries,
    weightedSeries,
    earliestDate: earliestPurchase
  };
}

/* ==========================================================
   DATE-ALIGNED CHART ENGINE HELPERS
   ========================================================== */

// Convert YYYY-MM-DD to Date objects
function toDate(d) {
  return (d instanceof Date) ? d : new Date(d);
}

// Difference in months between two dates
function monthDiff(a, b) {
  a = toDate(a);
  b = toDate(b);
  return (b.getFullYear() - a.getFullYear()) * 12 + (b.getMonth() - a.getMonth());
}

// Format ticks (Jan 2024)
function formatMonthYear(d) {
  return d.toLocaleString("en-US", { month: "short", year: "numeric" });
}

// Simple catmull-rom smoothing
function smoothPath(points) {
  if (points.length < 3) {
    return `M${points.map(p => `${p.x},${p.y}`).join(" L")}`;
  }
  let d = `M${points[0].x},${points[0].y}`;
  for (let i = 1; i < points.length - 2; i++) {
    const xc = (points[i].x + points[i + 1].x) / 2;
    const yc = (points[i].y + points[i + 1].y) / 2;
    d += ` Q ${points[i].x},${points[i].y} ${xc},${yc}`;
  }
  const n = points.length;
  d += ` T ${points[n - 1].x},${points[n - 1].y}`;
  return d;
}


      
    /* -------------------------
       KPI drawer renderers
       ------------------------- */
      
/* ============================================================
   TPV Drawer â€” Weighted ROI To Date
   Using the same stable timeline engine as Projected ROI
   ============================================================ */
function renderTPVDrawer() {
  currentMode = 'kpi';
  currentLoan = null;

  drawer.classList.remove('loan-mode');


  // Reset drawer
  drawerAmortContainer.style.display = 'none';
  drawerLegend.style.display = 'none';
  drawerChartArea.innerHTML = '';
  drawerExtra.innerHTML = '';

  drawerTitle.textContent = "Weighted ROI to Date";
  drawerSub.textContent = "Current Portfolio Snapshot";

  // ===============================
  // 1. Compute weighted ROI to date
  // ===============================
  const totalInv = loansWithAmort.reduce((s,l)=> s + l.purchasePrice, 0);

  let weightedROI = 0;
  loansWithAmort.forEach(l => {
    const last = getCurrentOwnedRoiEntry(l); // TODAY'S ROI ENTRY
    weightedROI += l.purchasePrice * (last.roi || 0);
  });
  weightedROI = weightedROI / Math.max(1, totalInv);

  drawerPrimaryTitle.textContent = "Weighted ROI to Date";
  drawerPrimary.textContent = (weightedROI * 100).toFixed(2) + "%";

  // ===============================
  // 2. Compute portfolio value today
  // ===============================
  let portfolioValue = 0;
  loansWithAmort.forEach(l => {
    const last = getCurrentOwnedRoiEntry(l);
    portfolioValue += last.loanValue || 0;
  });

  drawerSecondaryTitle.textContent = "Portfolio Value";
  drawerSecondary.textContent = "$" + portfolioValue.toLocaleString();

  // ===============================
  // 3. Build TIMELINE using the
  //    existing stable Projected ROI engine
  //    BUT using today's ROI values
  // ===============================
  const timeline = buildHistoricalRoiTimeline(loansWithAmort);

  // ===============================
  // 4. Render multi-series chart
  // ===============================
 const globalDates = buildGlobalDatesFromLoans(currentLoans);
  
  createMultiSeriesChart(
    drawerChartArea,
    timeline.perLoanSeries,
    timeline.weightedSeries,
    {
      weightedColor: "#000",
      weightedWidth: 2.6,
      dates: timeline.dates,
      tickSpacingX: 3   // label every other month
    }
  );


  // ===============================
  // 5. ROI-to-Date Table
  // ===============================
  drawerExtra.innerHTML = `
    <div style="margin-top:12px">
      <h3 style="margin:0 0 8px 0">ROI to Date â€” All Loans</h3>
      <div style="
        max-height:300px;
        overflow:auto;
        border:1px solid var(--border);
        border-radius:8px;
        padding:6px;
        background:var(--card);
      ">
        <table id="roiLoansTable" class="roi-table" style="width:100%;font-size:13px;">
          <thead>
            <tr>
              <th style="text-align:left;">Loan</th>
              <th style="text-align:left;">Purchase Date</th>
              <th style="text-align:left;">Maturity Date</th>
              <th style="text-align:right;">ROI to Date</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>
    </div>
  `;

  populateROILoanTable();  // already implemented

  // ===============================
  // 6. Open drawer
  // ===============================
  drawer.classList.add('open');
  drawer.setAttribute('aria-hidden','false');
  drawer.scrollTop = 0;
}

      /* ============================================================
   PROJECTED ROI TIMELINE ENGINE
   Extends to each loan's maturity (NOT to today's date)
   ============================================================ */
function buildProjectedRoiTimeline(loans) {
  // ---- 1. Determine global start (earliest purchase) ----
  const earliestPurchase = loans.reduce((earliest, l) => {
    const d = new Date(l.purchaseDate);
    return d < earliest ? d : earliest;
  }, new Date(loans[0].purchaseDate));

  // ---- 2. Determine global end (latest maturity date) ----
  const latestMaturity = loans.reduce((latest, l) => {
    const mat = new Date(l.purchaseDate);
    mat.setMonth(mat.getMonth() + Math.round((l.termYears + l.graceYears) * 12));
    return mat > latest ? mat : latest;
  }, new Date(earliestPurchase));

  // ---- 3. Build monthly date list earliest â†’ latest maturity ----
  const dates = [];
  const cursor = new Date(earliestPurchase);
  while (cursor <= latestMaturity) {
    dates.push(new Date(cursor));
    cursor.setMonth(cursor.getMonth() + 1);
  }

  // ---- 4. Align per-loan ROI series ----
  const perLoanSeries = loans.map((loan, idx) => {
    const purchase = new Date(loan.purchaseDate);
const roiMap = {};

loan.cumSchedule.forEach(row => {
  if (!row.isOwned) return;

  const realized = (row.cumPrincipal + row.cumInterest) - row.cumFees;
  const unrealized = row.balance * 0.95;
  const loanValue = realized + unrealized;

  const roi = (loanValue - loan.purchasePrice) / loan.purchasePrice;

  const key = row.loanDate.toISOString().slice(0, 7);
  roiMap[key] = roi;
});



    // Determine the very first ROI value for this loan
const roiKeys = Object.keys(roiMap).sort();
const firstRoiValue = roiKeys.length ? roiMap[roiKeys[0]] : 0;

let lastKnownROI = firstRoiValue;   // <-- FIX: start correctly

const data = dates.map(date => {
  if (date < purchase) return { date, y: null };

  const key = date.toISOString().slice(0,7);
  if (roiMap[key] != null) {
    lastKnownROI = roiMap[key];
  }

  return { date, y: lastKnownROI };
});


    const loanId = loan.id ?? loan.loanId ?? idx;

    return {
      id: loanId,
      name: loan.name || `Loan ${loanId}`,
      color: window.KPI_COLOR_MAP?.[loanId] || loanColors[idx % loanColors.length],
      data
    };

  });

  // ---- 5. Weighted ROI series ----
  const totalInvested = loans.reduce((s,l)=> s + l.purchasePrice, 0);

  const weightedSeries = dates.map((date, i) => {
    let weightedSum = 0;
    loans.forEach((loan, idx) => {
      const roi = perLoanSeries[idx].data[i].y;
      if (roi != null) {
        weightedSum += roi * loan.purchasePrice;
      }
    });
    return { date, y: weightedSum / totalInvested };
  });

  return {
    dates,
    perLoanSeries,
    weightedSeries
  };
}


    function renderRatesDrawer(){
  currentMode = 'kpi';
currentLoan = null;

    drawer.classList.remove('loan-mode');

drawerAmortContainer.style.display = 'none';
drawerLegend.style.display = 'none';
drawerChartArea.innerHTML = '';
drawerExtra.innerHTML = '';

drawerTitle.textContent = "Projected Weighted ROI";
drawerSub.textContent = "Projection to Maturity";

// ===============================
// 1. Compute projected weighted ROI
// ===============================
const totalInv = loansWithAmort.reduce((s,l)=> s + l.purchasePrice, 0);

let projWeightedROI = 0;
loansWithAmort.forEach(l => {
  const last = getLastOwnedRoiEntry(l);
  projWeightedROI += l.purchasePrice * (last.roi || 0);
});
projWeightedROI = projWeightedROI / Math.max(1, totalInv);

drawerPrimaryTitle.textContent = "Projected Weighted ROI";
drawerPrimary.textContent = (projWeightedROI * 100).toFixed(2) + "%";

// ===============================
// 2. Compute projected portfolio value
// ===============================
let projPortfolioValue = 0;
loansWithAmort.forEach(l => {
  const last = getLastOwnedRoiEntry(l);
  projPortfolioValue += last.loanValue || 0;
});

drawerSecondaryTitle.textContent = "Projected Portfolio Value";
drawerSecondary.textContent = "$" + projPortfolioValue.toLocaleString();

// ===============================
// 3. Build timeline (calendar aligned)
// ===============================
const timeline = buildProjectedRoiTimeline(loansWithAmort);
      
// ===============================
// 4. Render multi-series chart WITH hover
// ===============================
      
      createMultiSeriesChart(
  drawerChartArea,
  timeline.perLoanSeries,
  timeline.weightedSeries,
  {
    weightedColor: "#000",
    weightedWidth: 2.6,
    dates: timeline.dates
  }
);

// ===============================
// 5. Table of projected ROI for each loan
// ===============================
drawerExtra.innerHTML = `
  <div style="margin-top:12px">
    <h3 style="margin:0 0 8px 0">Projected ROI at Maturity â€” All Loans</h3>
    <div style="
      max-height:300px;
      overflow:auto;
      border:1px solid var(--border);
      border-radius:8px;
      padding:6px;
      background:var(--card);
    ">
      <table id="roiProjectedLoansTable" class="roi-table" style="width:100%;font-size:13px;">
        <thead>
          <tr>
            <th style="text-align:left;">Loan</th>
            <th style="text-align:left;">Purchase Date</th>
            <th style="text-align:left;">Maturity Date</th>
            <th style="text-align:right;">Projected ROI</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>
  </div>
`;

populateProjectedROILoanTable();


drawer.classList.add('open');
drawer.setAttribute('aria-hidden','false');
drawer.scrollTop = 0;

}

// ============================================================
// KPI4 â€” ROI SPREAD DRAWER
// ============================================================
function renderROISpreadDrawer() {
  currentMode = 'kpi';
  currentLoan = null;
  drawer.classList.remove('loan-mode');

  drawerAmortContainer.style.display = 'none';
  drawerLegend.style.display = 'none';
  drawerChartArea.innerHTML = '';
  drawerExtra.innerHTML = '';

  drawerTitle.textContent = "ROI Spread";
  drawerSub.textContent = "Best vs Worst Performing Loans";

  // -------------------------------
  // Compute spread stats
  // -------------------------------
  const rows = loansWithAmort.map(l => {
    const e = getCurrentOwnedRoiEntry(l);
    return {
      id: l.id,
      name: l.name,
      school: l.school,
      roi: e?.roi ?? 0,
      color: window.KPI_COLOR_MAP?.[l.id] || '#64748b'
    };
  });

  rows.sort((a, b) => b.roi - a.roi);

  const best = rows[0];
  const worst = rows[rows.length - 1];
  const spread = best.roi - worst.roi;

  drawerPrimaryTitle.textContent = "ROI Spread";
  drawerPrimary.textContent = (spread * 100).toFixed(2) + "%";

  drawerSecondaryTitle.textContent = "Loans";
  drawerSecondary.textContent = rows.length;

  // -------------------------------
  // Chart for Spread Drawer (multi-series)
  // -------------------------------
 const timeline = buildHistoricalRoiTimeline(loansWithAmort);

const globalDates = buildGlobalDatesFromLoans(currentLoans);
  
createMultiSeriesChart(
  drawerChartArea,
  timeline.perLoanSeries,
  null, // â›” NO weighted line
  {
    dates: timeline.dates,
    tickSpacingX: 3,     // SAME as Weighted ROI to Date
    hideWeighted: true
  }
);


  // -------------------------------
  // Table
  // -------------------------------
drawerExtra.innerHTML = `
  <div style="margin-top:12px">
    <h3 style="margin:0 0 8px 0">ROI by Loan</h3>
    <div style="
      max-height:320px;
      overflow:auto;
      border:1px solid var(--border);
      border-radius:8px;
      padding:6px;
      background:var(--card);
    ">
      <table id="roiLoansTable" class="roi-table" style="width:100%;font-size:13px;">
        <thead>
          <tr>
            <th style="text-align:left">Loan</th>
            <th style="text-align:left">Purchase Date</th>
            <th style="text-align:left">Maturity Date</th>
            <th style="text-align:right">ROI to Date</th>
            <th style="text-align:right">Î” vs Best</th>
          </tr>
        </thead>
        <tbody>
          ${rows.map(r => {
            const loan = loansWithAmort.find(l => l.id === r.id);
            if (!loan) return '';

            let maturity = '';
            try {
              const d = new Date(loan.purchaseDate);
              const months = Math.round((loan.termYears + loan.graceYears) * 12);
              d.setMonth(d.getMonth() + months);
              maturity = d.toISOString().slice(0,10);
            } catch {}

            return `
              <tr data-loan-id="${r.id}">
                <td style="text-align:left;">
                  <span style="
                    display:inline-block;
                    width:10px;
                    height:10px;
                    background:${r.color};
                    border-radius:2px;
                    margin-right:8px;
                    vertical-align:middle;
                  "></span>
                  <strong>${r.name}</strong>
                  <div style="font-size:12px;color:var(--muted)">
                    ${r.school || ""}
                  </div>
                </td>
                <td style="text-align:left;">
                  ${loan.purchaseDate || ""}
                </td>
                <td style="text-align:left;">
                  ${maturity}
                </td>
                <td style="text-align:right;color:${r.color};font-weight:700">
                  ${(r.roi * 100).toFixed(2)}%
                </td>
                <td style="text-align:right;color:var(--muted)">
                  ${((r.roi - best.roi) * 100).toFixed(2)}%
                </td>
              </tr>
            `;
          }).join('')}
        </tbody>
      </table>
    </div>
  </div>
`;

  // -----------------------------------------
  // ROI Spread table row â†’ chart hover binding
  // -----------------------------------------
  const chartSvg = drawerChartArea.querySelector("svg");
  if (chartSvg) {
    const loanPaths = Array.from(
      chartSvg.querySelectorAll('path[data-type="loan"]')
    );
  
    const table = document.getElementById("roiLoansTable");
    if (table) {
      table.querySelectorAll("tbody tr").forEach(row => {
        const rowLoanId = row.dataset.loanId;
        if (!rowLoanId) return;
  
        row.addEventListener("mouseenter", () => {
          loanPaths.forEach(p => {
            const isTarget = p.dataset.loanId === rowLoanId;
            p.setAttribute("stroke-opacity", isTarget ? "1" : "0.15");
            p.setAttribute("stroke-width", isTarget ? "2.6" : "1.2");
          });
        });
  
        row.addEventListener("mouseleave", () => {
          loanPaths.forEach(p => {
            p.setAttribute("stroke-opacity", "0.9");
            p.setAttribute("stroke-width", "1.2");
          });
        });
      });
    }
  }


  drawer.classList.add('open');
  drawer.setAttribute('aria-hidden','false');
  drawer.scrollTop = 0;

}

function renderCapitalRecoveryDrawer() {
  currentMode = 'kpi';
  currentLoan = null;

  // -----------------------------
  // Open + reset drawer
  // -----------------------------
  drawer.classList.add('open');
  drawer.setAttribute('aria-hidden', 'false');
  drawer.classList.remove('loan-mode');

  drawerAmortContainer.style.display = 'none';
  drawerLegend.style.display = 'none';
  drawerChartArea.innerHTML = '';
  drawerExtra.innerHTML = '';

  drawerTitle.textContent = "Capital Recovery Over Time";
  drawerSub.textContent =
    "Cumulative principal returned as a percentage of purchase price (through today).";

  const TODAY = new Date();
  TODAY.setHours(23, 59, 59, 999);

  // --------------------------------------------------
  // Build per-loan recovery series (MONTHLY, TO TODAY)
  // --------------------------------------------------
  const loanSeriesList = [];
  const monthMap = new Map(); // key = YYYY-MM â†’ Date(1st)

  function monthKey(d) {
    return `${d.getFullYear()}-${d.getMonth()}`;
  }

  function monthStart(d) {
    return new Date(d.getFullYear(), d.getMonth(), 1);
  }

  currentLoans.forEach(l => {
    if (!l.amort || !l.amort.schedule) return;

    let cumPrincipal = 0;
    const monthly = new Map();

    l.amort.schedule
      .filter(r => r.isOwned && r.loanDate && r.loanDate <= TODAY)
      .forEach(r => {
        const m = monthStart(r.loanDate);
        const k = monthKey(m);

        cumPrincipal += r.principalPaid || 0;

        const pct =
          l.purchasePrice > 0 ? cumPrincipal / l.purchasePrice : 0;

        monthly.set(k, { date: m, y: pct });
        monthMap.set(k, m);
      });

    loanSeriesList.push({
      id: l.id,
      name: l.name,
      color: window.KPI_COLOR_MAP?.[l.id] || '#64748b',
      data: Array.from(monthly.values())
    });
  });

  // --------------------------------------------------
  // Unified MONTHLY date axis (clean)
  // --------------------------------------------------
  const globalDates = Array.from(monthMap.values()).sort(
    (a, b) => a - b
  );

  // --------------------------------------------------
  // Portfolio cumulative line (MONTHLY)
  // --------------------------------------------------
  const totalInvested = currentLoans.reduce(
    (s, l) => s + (l.purchasePrice || 0),
    0
  );

  let cumPortfolioRecovered = 0;

  const portfolioSeries = globalDates.map(d => {
    let monthRecovered = 0;

    currentLoans.forEach(l => {
      l.amort?.schedule
        ?.filter(
          r =>
            r.isOwned &&
            r.loanDate &&
            r.loanDate <= TODAY &&
            r.loanDate.getFullYear() === d.getFullYear() &&
            r.loanDate.getMonth() === d.getMonth()
        )
        .forEach(r => {
          monthRecovered += r.principalPaid || 0;
        });
    });

    cumPortfolioRecovered += monthRecovered;

    return {
      date: d,
      y: totalInvested > 0 ? cumPortfolioRecovered / totalInvested : 0
    };
  });

  // --------------------------------------------------
  // Dynamic x-axis spacing (â‰ˆ 6â€“8 labels max)
  // --------------------------------------------------
  const tickSpacingX = Math.max(
    1,
    Math.round(globalDates.length / 7)
  );

  // --------------------------------------------------
  // Render chart (CLEAN X-AXIS)
  // --------------------------------------------------
  
  createMultiSeriesChart(
    document.getElementById('drawerChartArea'),
    loanSeriesList,
    portfolioSeries,
    {
      dates: globalDates,
      weightedColor: '#111827',
      weightedWidth: 3,
      tickSpacingX
    }
  );

  // --------------------------------------------------
  // Metrics
  // --------------------------------------------------
  drawerPrimaryTitle.textContent = "Capital Recovered";
  drawerPrimary.textContent =
    "$" + (kpis.capitalRecoveredAmount || 0).toLocaleString();

  drawerSecondaryTitle.textContent = "% Recovered";
  drawerSecondary.textContent =
    ((kpis.capitalRecoveryPct || 0) * 100).toFixed(2) + "%";

  // --------------------------------------------------
  // Table (unchanged)
  // --------------------------------------------------
  let html = `
    <div class="amort-wrap">
      <table class="kpi-table" id="capitalRecoveryTable">
        <thead>
          <tr>
            <th>Loan</th>
            <th>Cap Recovered</th>
            <th>% Recovered</th>
            <th>Remaining</th>
          </tr>
        </thead>
        <tbody>
  `;

  currentLoans.forEach(l => {
    if (!l.amort || !l.amort.schedule) return;

    const recovered = l.amort.schedule
      .filter(r => r.isOwned && r.loanDate && r.loanDate <= TODAY)
      .reduce((s, r) => s + (r.principalPaid || 0), 0);

    const pct = l.purchasePrice > 0 ? recovered / l.purchasePrice : 0;
    const remaining =
      Math.max(0, (l.balanceAtPurchase || 0) - recovered);

    const color = window.KPI_COLOR_MAP?.[l.id] || '#64748b';

    html += `
      <tr data-loan-id="${l.id}">
        <td>
          <div style="display:flex;gap:8px;align-items:center">
            <span style="width:10px;height:10px;border-radius:2px;background:${color}"></span>
            <div>
              <div style="font-weight:500">${l.name}</div>
              <div style="font-size:11px;color:#64748b">${l.school || ''}</div>
            </div>
          </div>
        </td>
        <td style="color:${color};font-weight:600">$${recovered.toLocaleString()}</td>
        <td>${(pct * 100).toFixed(2)}%</td>
        <td>$${remaining.toLocaleString()}</td>
      </tr>
    `;
  });

  html += `
        </tbody>
      </table>
    </div>
  `;

  drawerExtra.innerHTML = html;

  const chartSvg = drawerChartArea.querySelector("svg");
if (chartSvg) {
  const loanPaths = Array.from(
    chartSvg.querySelectorAll('path[data-type="loan"]')
  );

  const table = document.getElementById("capitalRecoveryTable");
  if (table) {
    table.querySelectorAll("tbody tr").forEach(row => {
      const rowLoanId = row.dataset.loanId;
      if (!rowLoanId) return;

      row.addEventListener("mouseenter", () => {
        loanPaths.forEach(p => {
          const isTarget = p.dataset.loanId === rowLoanId;
          p.setAttribute("stroke-opacity", isTarget ? "1" : "0.15");
          p.setAttribute("stroke-width", isTarget ? "2.6" : "1.2");
        });
      });

      row.addEventListener("mouseleave", () => {
        loanPaths.forEach(p => {
          p.setAttribute("stroke-opacity", "0.9");
          p.setAttribute("stroke-width", "1.2");
        });
      });
    });
  }
}
}

// ----------------------------------
// Embed auto-open handling (KPI2)
// ----------------------------------
const urlParams = new URLSearchParams(window.location.search);
const EMBED_MODE = urlParams.get("embed") === "true";
const OPEN_TARGET = urlParams.get("open");

requestAnimationFrame(() => {
  if (OPEN_TARGET === "kpi2" || OPEN_TARGET === "projectedROI") {
    if (typeof renderRatesDrawer === "function") {
      renderRatesDrawer();
    }
  }
});


// ----------------------------------
// Embed click-through to full ROI
// ----------------------------------
if (EMBED_MODE) {
  document.addEventListener(
    "click",
    (e) => {
      // Allow normal interaction
      if (e.target.closest("button, select, a, input, textarea")) return;

      const user = PAGE_USER || "jeff";
      window.top.location.href =
        `/loan-dashboard/roi/index.html?user=${user}&open=kpi2`;
    },
    { passive: true }
  );
}



      
    /* -------------------------
       KPI wiring & interactions
       ------------------------- */
    document.querySelectorAll('.kpi').forEach(k=>{ k.addEventListener('click', ev=>{ ev.stopPropagation(); const key=k.getAttribute('data-kpi'); if(key==='spread') renderROISpreadDrawer(); if(key==='tpv') renderTPVDrawer(); if(key==='rates') renderRatesDrawer(); if(key==='capitalRecovery') renderCapitalRecoveryDrawer(); }); });

    /* -------------------------
       CSV / clipboard / download / print
       ------------------------- */
    function copyPortfolioCSV(){ let rows=[['Loan','Purchase Date','Amount','Rate']]; loansWithAmort.forEach(l=>rows.push([formatLoanLabel(l),l.purchaseDate,l.purchasePrice,(l.nominalRate*100).toFixed(2)+'%'])); const csv=rows.map(r=>r.join(',')).join('\n'); navigator.clipboard.writeText(csv); alert('CSV copied to clipboard'); }
    function amortToCSV(loan){ const rows=[['Month','Payment','Principal','Interest','Balance']]; loan.amort.schedule.forEach(r=>rows.push([r.monthIndex,r.payment.toFixed(2),r.principalPaid.toFixed(2),r.interest.toFixed(2),r.balance.toFixed(2)])); return rows.map(r=>r.join(',')).join('\n'); }
    document.getElementById('copyCsvBtn')?.addEventListener('click', async ()=>{ if(currentMode!=='loan' || !currentLoan) return alert('Open an individual loan drawer to copy CSV'); const csv=amortToCSV(currentLoan); try{ await navigator.clipboard.writeText(csv); alert('CSV copied to clipboard'); }catch(e){ alert('Copy failed â€” browser denied clipboard access'); } });
    document.getElementById('downloadCsvBtn')?.addEventListener('click', ()=>{ if(currentMode==='loan' && currentLoan){ const csv=amortToCSV(currentLoan); const blob=new Blob([csv],{type:'text/csv;charset=utf-8;'}); const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download='loan-'+currentLoan.id+'-amort.csv'; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url); } else alert('Download CSV is supported for individual loan drawers only.'); });
    document.getElementById('printBtn')?.addEventListener('click', ()=>window.print());

    /* -------------------------
       Close drawer on outside click; hide tooltip on scroll
       ------------------------- */
    document.addEventListener('click', function(e){ if(!drawer.classList.contains('open')) return; const clickedInside=drawer.contains(e.target); const clickedTile=!!e.target.closest('.tile'); if(!clickedInside && !clickedTile) closeDrawer(); });
    document.querySelector('.grid').addEventListener('scroll', ()=>{ tooltip.style.display='none'; });

    /* -------------------------
       End
       ------------------------- */

// ======================================================
// EMBED MODE â€” OVERRIDE KPI2 DRAWER BUTTON BEHAVIOR
// ======================================================
const _embedParams = new URLSearchParams(window.location.search);
const _IS_EMBED = _embedParams.get("embed") === "true";

if (_IS_EMBED) {
  const user = PAGE_USER || "jeff";
  const targetUrl =
    `/loan-dashboard/roi/index.html?user=${user}&open=kpi2`;

  function redirectToFullROI(e) {
    e.preventDefault();
    e.stopImmediatePropagation();
    window.top.location.href = targetUrl;
  }

  // --- CLOSE (âœ•) ---
  const closeBtn = document.getElementById("closeBtn");
  if (closeBtn) {
    closeBtn.addEventListener("click", redirectToFullROI, true);
  }

  // --- DOWNLOAD CSV ---
  const downloadBtn = document.getElementById("downloadCsvBtn");
  if (downloadBtn) {
    downloadBtn.addEventListener("click", redirectToFullROI, true);
  }

  // --- PRINT ---
  const printBtn = document.getElementById("printBtn");
  if (printBtn) {
    printBtn.addEventListener("click", redirectToFullROI, true);
  }

  // --- COPY CSV ---
  const copyBtn = document.getElementById("copyCsvBtn");
  if (copyBtn) {
    copyBtn.addEventListener("click", redirectToFullROI, true);
  }
}


    } // END initROI()

    document.addEventListener("DOMContentLoaded", async () => {
      await loadLoans();
      document.getElementById("currentDate").textContent = formatDate(new Date());
      initROI();
    });


    
    // theme toggle
window.addEventListener("DOMContentLoaded", () => {
  const toggle = document.getElementById("themeToggle");
  if (!toggle) return;

  const applyTheme = (theme) => {
    document.documentElement.setAttribute("data-theme", theme);
    document.body.classList.toggle("dark", theme === "dark");
    localStorage.setItem("theme", theme);
    toggle.textContent = theme === "dark" ? "â˜€ï¸" : "ðŸŒ™";
    toggle.setAttribute("aria-label", theme === "dark" ? "Switch to light mode" : "Switch to dark mode");
    toggle.setAttribute("title", theme === "dark" ? "Switch to light mode" : "Switch to dark mode");
  };

  const saved = localStorage.getItem("theme");
  const prefersDark = window.matchMedia("(prefers-color-scheme: dark)").matches;
  applyTheme(saved || (prefersDark ? "dark" : "light"));

  toggle.addEventListener("click", () => {
    const nextTheme = document.documentElement.getAttribute("data-theme") === "dark" ? "light" : "dark";
    applyTheme(nextTheme);
  });
});

</script>
</body>
</html>

<script>

const isEmbed = new URLSearchParams(window.location.search).get('embed') === 'true';

</script>

