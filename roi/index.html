<!doctype html>
<html lang="en" data-theme="light">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Loan Portfolio â€” ROI</title>

  <!-- ====================================
       Styles (organized, with dark mode)
       ==================================== -->
  <style>
 
:root {
  --bg:#f8fafc;
  --surface:#f1f5f9;
  --card:#ffffff;
  --border:#e2e8f0;
  --text:#0f172a;
  --muted:#64748b;

  --brand:#0ea5e9;
  --accent:#7c3aed;

  --shadow:0 12px 30px rgba(15,23,42,0.06);

  --page-gradient: linear-gradient(180deg, var(--surface), var(--bg));

  --chart-bg:linear-gradient(180deg,#ffffff,#fcfeff);
  --grad-top:#f1f5f9;
  --grad-bottom:#ffffff;

  --tooltip-bg:#0f172a;
  --tooltip-text:#f8fafc;

  --table-header:var(--surface);
  --table-border:rgba(148,163,184,0.35);
}

html {
  color-scheme: light;
}
    
html[data-theme="light"] {
  --bg:#f8fafc;
  --surface:#f1f5f9;
  --card:#ffffff;
  --border:#e2e8f0;
  --text:#0f172a;
  --muted:#64748b;

  --brand:#0ea5e9;
  --accent:#7c3aed;

  --shadow:0 12px 30px rgba(15,23,42,0.06);

  --chart-bg:linear-gradient(180deg,#ffffff,#fcfeff);

  --tooltip-bg:#0f172a;
  --tooltip-text:#f8fafc;

  --table-header:var(--surface);
  --table-border:rgba(148,163,184,0.35);
}

html[data-theme="dark"] {
   color-scheme: dark; 
  --bg:#0f172a;
  --surface:#1e293b;
  --card:#1e293b;
  --border:#334155;
  --text:#f1f5f9;
  --muted:#94a3b8;

  --brand:#38bdf8;
  --accent:#c4b5fd;

  --grad-top:#1e293b;
  --grad-bottom:#0f172a;

  --shadow:rgba(0,0,0,0.45);

  --chart-bg:linear-gradient(180deg,#1e293b,#0f172a);

  --tooltip-bg:#0f172a;
  --tooltip-text:#f1f5f9;

  --table-header:#1e293b;
  --table-border:#334155;
}

    /* Smooth theme transitions (copied from amortization page) */
    html, body,
    .app,
    header,
    .kpi, .tile,
    .drawer, .drawer-head, .drawer-body, .drawer-footer,
    .info-card, .drawer-chart,
    table, thead th, td,
    .tooltip,
    .theme-icon,
    svg text {
      transition:
    background-color .25s ease,
    color .25s ease,
    border-color .25s ease,
    box-shadow .25s ease,
    fill .25s ease;
    }

html,body{
  height:100%;
  margin:0;
  font-family:Inter, system-ui, -apple-system, "Segoe UI", Roboto, Arial;
  color:var(--text);
  -webkit-font-smoothing: antialiased;
}

/* Force layout to match Amort: body does NOT scroll */
html, body {
  height: 100%;
  overflow: hidden;
}

/* Make .app the ONLY scroll container (same as Amort) */
.app {
  height: 100%;
  overflow-y: auto;
  overflow-x: hidden;
  background: var(--surface);   /* <-- ADD THIS */
}
#app,
.app {
  background: var(--surface);
}


    
body{
  background: linear-gradient(180deg, var(--grad-top) 0%, var(--grad-bottom) 100%);
  background-color: var(--bg);
  transition: background-color .25s ease, color .25s ease;
}

/* Dark mode gradient (match Amort exactly) */
html[data-theme="dark"] body {
  background: linear-gradient(180deg,#0b1224 0%, #0f172a 100%);
}

    .app{
      max-width:1200px;
      margin:20px auto 0 auto;
      padding:16px 16px 0 16px;
    }

    /* Match amort layout */
    body > .app {
       background: transparent;
      padding-top: 16px;
      margin-top: 0;
    }


    header {
      display:flex;
      flex-direction:column;
      gap:8px;
      margin-bottom:8px;   /* match amort */
      padding:0;           /* remove invisible offset */
    }

    .header-top{display:flex;align-items:center;justify-content:space-between}
    .header-controls {
      display:flex;
      gap:10px;
      align-items:center;
    }

    h1{ font-size:20px; margin:0 }
    p.lead{ margin:0; color:var(--muted); font-size:13px }
    .current-date{ font-size:13px; color:var(--muted); margin-top:4px }

    /* =========================
       Buttons (unified with Amort Page)
       ========================= */
    .actions { display:flex; gap:8px; align-items:center }
    .btn{ padding:8px 12px; border-radius:8px; border:1px solid var(--border); background:transparent; cursor:pointer; font-weight:600; color:var(--text); transition:background .2s ease, color .2s ease, border-color .2s ease }
    .btn.primary{ background:linear-gradient(90deg,var(--brand),var(--accent)); color:white; border:none; box-shadow: var(--shadow) }
    .btn.secondary{ background:var(--surface); color:var(--text); }
    .close-btn{ background:var(--surface); border:1px solid var(--border); padding:8px; border-radius:8px; cursor:pointer; }
    .btn:hover, .close-btn:hover{ border-color:rgba(15,23,42,0.14); }

    /* =========================
       KPI row + tiles (unified hover)
       ========================= */
     .kpis {
      display:grid;
      grid-template-columns:repeat(4,1fr);
      gap:12px;
      margin:14px 0 18px;
    }

  .kpi{
    background:var(--card);
    padding:12px;
    border-radius:10px;
    box-shadow:var(--shadow);
    border:1px solid var(--border);
    cursor:pointer;
    transition: transform .18s, box-shadow .18s,
              background-color .25s ease, color .25s ease,
              border-color .25s ease;
    }
  .kpi:hover {
    transform: translateY(-2px);
    box-shadow: 0 6px 16px rgba(0,0,0,0.15);
    }


  .kpi h3 { margin:0; font-size:12px; color:var(--muted); }
  .kpi p  { margin:8px 0 0; font-size:18px; font-weight:700; }


    .grid{ display:grid; grid-template-columns:repeat(2,1fr); gap:12px; height:calc(100vh - 320px); overflow: auto; padding-right:6px }
  
    @media(max-width:900px){ .grid{ grid-template-columns:1fr; height:auto } .kpis{ grid-template-columns:repeat(2,1fr) } }

    .tile{ display:flex; align-items:center; justify-content:space-between; padding:10px 12px; border-radius:12px; background:var(--card); min-height:110px; cursor:pointer; overflow:hidden; transition: transform .18s ease, box-shadow .18s ease; border:1px solid var(--border) }
    .tile-left{ flex:1; padding-right:10px }
    .loan-name{ font-weight:700; font-size:14px }
    .loan-sub{ font-size:12px; color:var(--muted); margin-top:6px }
    .loan-meta{ display:flex; gap:8px; font-size:12px; color:var(--muted); margin-top:8px }

    .chart-wrap{ width:170px; flex-shrink:0; display:flex; flex-direction:column; align-items:flex-end }
    .mini-label{ font-size:12px; color:var(--muted); margin-bottom:6px }
    svg.sparkline{ width:170px; height:48px; display:block }

    /* =========================
       Drawer (with opening animation)
       ========================= */
    .drawer{
      position:fixed; right:0; top:0; height:100vh; max-width:1000px; width:760px; background:var(--card);
      box-shadow:-28px 0 80px rgba(2,6,23,0.14); transform:translateX(110%); transition: transform .32s cubic-bezier(.2,.9,.3,1), opacity .24s ease;
      z-index:120; opacity:0; display:flex; flex-direction:column; overflow:hidden;
      padding:0; border-left:1px solid var(--border);
    }
    .drawer.open{ transform:translateX(0); opacity:1; animation: drawerIn .28s cubic-bezier(.2,.9,.3,1); }
    @keyframes drawerIn { from { transform: translateX(30%); opacity:0 } to { transform: translateX(0); opacity:1 } }

    .drawer-head{ display:flex; align-items:start; justify-content:space-between; gap:8px; padding:20px; flex-shrink:0; border-bottom:1px solid var(--border); background:var(--surface); }
    .drawer-body{ flex:1 1 auto; overflow-y:auto; overflow-x:hidden; padding:0 20px 20px; }
    .drawer-footer{ padding:12px 20px 20px; flex-shrink:0; padding-left: 20px; border-top:1px solid var(--border); background:var(--surface); }
    .drawer-footer .actions{ justify-content:flex-start; }
    .drawer, #drawerBody, .drawer-body { overflow-x: hidden; }
    .drawer-chart { width:100%; height:260px; background: var(--chart-bg); border-radius:8px; border:1px solid var(--border); margin-bottom:8px; padding:0; position:relative; display:block }

    }

    /* Drawer info row */
    .drawer-info-row { display:flex; gap:12px; margin-bottom:8px; align-items:center }
    .info-card{ flex:1; background:var(--bg); padding:12px; border-radius:8px; display:flex; flex-direction:column; justify-content:center; min-height:56px; border:1px solid var(--border) }
    .info-card.small{ width:160px; align-items:flex-end }
    .muted-small{ font-size:12px; color:var(--muted); margin-bottom:6px }
    .main-val{ font-weight:800; font-size:18px }

    .amort-wrap{ border:1px solid var(--border); border-radius:8px; padding:8px; max-height:40vh; overflow:auto; background:var(--card) }
    table{ width:100%; border-collapse:collapse; font-size:13px; background:var(--card); }
    thead th{ position:sticky; top:0; background:var(--table-header); padding:8px; text-align:left; color:var(--muted); font-weight:700; border-bottom:1px solid var(--table-border) }
    td{ padding:8px; border-bottom:1px dashed var(--table-border); text-align:right }
    td:first-child, th:first-child{ text-align:left }

  .tooltip{
    position:fixed;
    pointer-events:none;
    background:var(--tooltip-bg);
    color:var(--tooltip-text);
    padding:6px 8px;
    border-radius:6px;
    font-size:12px;
    transform:translate(-50%,-120%);
    box-shadow:0 6px 18px rgba(2,6,23,0.2);
    display:none;
    z-index:9999;
    line-height:1.12;
    border:1px solid rgba(148,163,184,0.3);
    transition:background-color .25s ease, color .25s ease,
             border-color .25s ease, box-shadow .25s ease;
    }

    .small{ font-size:12px; color:var(--muted) }

    /* tiny responsive tweaks */
    @media(max-width:760px){
      .drawer{ width:100%; min-width:0; }
      .kpis{ grid-template-columns:repeat(2,1fr) }
    }

    /* Theme toggle icon */
  .theme-icon {
    width:38px;
    height:38px;
    display:flex;
    align-items:center;
    justify-content:center;
    border-radius:12px;
    border:1px solid var(--border);
    background:var(--surface);
    color:var(--text);
    cursor:pointer;
    font-size:16px;
    transition:background .2s ease, color .2s ease, 
             border-color .2s ease, transform .15s ease;
    box-shadow:0 8px 18px rgba(15,23,42,0.06);
    }
  .theme-icon:hover{
    transform:translateY(-1px);
    border-color:rgba(15,23,42,0.14);
    }


  </style>
</head>
<body>
  <div class="app" role="main">

      <!-- Header here -->
  <header>
    <div class="header-top">
      <div>
        <h1>Loan Portfolio â€” ROI</h1>
        <p class="lead">Unified design, dark mode, animations, KPI drawers with primary/secondary cards.</p>
      </div>
  
      <div class="header-controls">
        <div style="font-size:13px;color:var(--muted)">
          User: <strong style="color:var(--brand)">Jeff Customer</strong>
        </div>
        <button id="themeToggle" class="theme-icon" title="Toggle dark mode">ðŸŒ™</button>
      </div>
    </div>

    <div class="current-date" id="currentDateLabel">
      Current Date: <span id="currentDate"></span>
    </div>
  </header>



    <!-- KPI Row -->
    <section class="kpis" id="kpis"></section>

    <!-- Loan grid -->
    <section class="grid" id="loanGrid" aria-live="polite"></section>
  </div>

  <!-- Drawer -->
  <aside id="drawer" class="drawer" aria-hidden="true">
    <div class="drawer-head">
      <div>
        <h2 id="drawerTitle">Drawer</h2>
        <div class="muted" id="drawerSub">details</div>
      </div>
      <div style="display:flex;gap:8px;align-items:center">
        <button class="btn" id="downloadCsvBtn">Download CSV</button>
        <button class="close-btn" id="closeBtn" aria-label="Close drawer">âœ•</button>
      </div>
    </div>

    <div class="drawer-body" id="drawerBody">
      <div class="drawer-info-row">
        <div class="info-card" id="drawerPrimaryCard">
          <div class="muted-small" id="drawerPrimaryTitle">Primary</div>
          <div id="drawerPrimary" class="main-val"></div>
        </div>
        <div class="info-card small" id="drawerSecondaryCard">
          <div class="muted-small" id="drawerSecondaryTitle">Secondary</div>
          <div id="drawerSecondary" class="main-val small"></div>
        </div>
      </div>

      <div class="drawer-chart" id="drawerChartArea"></div>
      <div class="legend" id="drawerLegend" style="display:none"></div>
      <div id="drawerExtra">
<table id="roiLoansTable" class="roi-table"><thead><tr><th>Loan</th><th>ROI to Date</th></tr></thead><tbody></tbody></table>
</div>

      <div style="margin-top:12px" id="drawerAmortContainer"></div>
    </div>

    <div class="drawer-footer">
      <div class="actions">
        <button class="btn" id="printBtn">Print</button>
        <button class="btn primary" id="copyCsvBtn">Copy CSV</button>
      </div>
    </div>
  </aside>

  <div id="tooltip" class="tooltip" role="status" aria-live="polite"></div>

  <!-- ====================================
       Script (organized with sections)
       ==================================== -->
  <script type="module">
    import { buildAmortSchedule } from "../js/loanEngine.js";
    
    function addMonths(date, months) {
      const d = new Date(date);
      d.setMonth(d.getMonth() + months);
      return d;
    }

    function formatDate(date) {
      return date.toLocaleDateString("en-US", {
        year: "numeric",
        month: "short",
        day: "numeric"
      });
    }

    function formatMonthYear(date) {
      return date.toLocaleDateString("en-US", {
        year: "numeric",
        month: "short"
      });
    }

    function monthDiff(d1, d2) {
      return (d2.getFullYear() - d1.getFullYear()) * 12 +
             (d2.getMonth() - d1.getMonth());
    }

    /* -------------------------
       Settings & data
       ------------------------- */
    // Dynamic loans loaded from backend
    let loans = [];

    async function loadLoans() {
      const res = await fetch("https://loan-dashboard-api.jeff-263.workers.dev/loans");
      const data = await res.json();
      loans = (data.loans || []).map(l => ({
        ...l,
        id: l.loanId,
        name: l.loanName ?? `Loan ${l.loanId}`,
        school: l.school ?? "",
        loanStartDate: l.loanStartDate || "",
        termYears: Number(l.termYears ?? 0),
        graceYears: Number(l.graceYears ?? 0),
        purchasePrice: Number(l.purchasePrice ?? 0),
        nominalRate: Number(l.nominalRate ?? 0),
        upfrontFee: Number(l.upfrontFee ?? 150),
        monthlyFeeStart: Number(l.monthlyFeeStart ?? 9),
      }));
    }

    /* -------------------------
       Amortization logic
       ------------------------- */
    function calcAmort(principal, annualRate, termYears, graceYears){
      const monthlyRate = annualRate/12;
      const totalMonths = Math.round(termYears*12);
      const graceMonths = Math.round(graceYears*12);
      const repayMonths = Math.max(1, totalMonths - graceMonths);
      let balance = principal; const schedule=[];
      for(let m=1;m<=graceMonths;m++){ const interest = +(balance*monthlyRate).toFixed(2); balance = +(balance + interest).toFixed(2); schedule.push({ monthIndex:m, payment:0, principalPaid:0, interest, balance }); }
      const payment = monthlyRate===0 ? +(balance/repayMonths).toFixed(2) : +((balance*monthlyRate)/(1-Math.pow(1+monthlyRate,-repayMonths))).toFixed(2);
      for(let m=1;m<=repayMonths;m++){ const interest = +(balance*monthlyRate).toFixed(2); const principalPaid = +Math.min(balance, +(payment - interest).toFixed(2)); balance = +(Math.max(0, balance - principalPaid).toFixed(2)); schedule.push({ monthIndex: graceMonths + m, payment:+payment.toFixed(2), principalPaid, interest, balance }); }
      return { payment, schedule };
    }

    async function initROI() {
      const TODAY = new Date();
      const formatLoanLabel = (loan) => `Loan ${loan.id} â€” ${loan.name} (${loan.school})`;
      const formattedLoans = loans.map(l => ({
        ...l,
        purchasePrice: Number(l.principal ?? l.purchasePrice ?? 0),
        nominalRate: Number(l.rate ?? l.nominalRate ?? 0)
      }));

      const loansWithAmort = formattedLoans.map(l => {
        // compute amortization schedule for this loan
    // -------------------------------------
    // USE REAL AMORT ENGINE FROM loanEngine.js
    // -------------------------------------
      const amortSchedule = buildAmortSchedule(l);

      // Attach ownership flags
      const purchase = new Date(l.purchaseDate);
      const scheduleWithOwnership = amortSchedule.map(r => ({
        ...r,
        isOwned: r.loanDate >= purchase,
        ownershipMonthIndex: r.loanDate >= purchase
          ? monthDiff(purchase, r.loanDate) + 1
        : 0,
      ownershipDate: r.loanDate >= purchase ? r.loanDate : null
    }));

    // Build cumulative values only for owned rows
      let cumP = 0, cumI = 0, cumFees = 0;
      const cumSchedule = scheduleWithOwnership.map(r => {
        if (r.isOwned) {
        cumP += r.principalPaid;
        cumI += r.interest;
        const feeThisMonth = Number(r.feeThisMonth ?? 0);
        cumFees += feeThisMonth;
      }
      return {
        ...r,
      cumPrincipal: +cumP.toFixed(2),
      cumInterest: +cumI.toFixed(2),
      cumFees: +cumFees.toFixed(2)
    };
    });

    // Compute proper ROI timeline using correct amort + fees
    const purchasePrice = Number(l.purchasePrice ?? 0);
    const roiSeries = cumSchedule
      .filter(r => r.isOwned)
      .map(r => {
      const realized = (r.cumPrincipal + r.cumInterest) - r.cumFees;
      const unrealized = r.balance * 0.95;
      const loanValue = realized + unrealized;
      const roi = (loanValue - purchasePrice) / purchasePrice;
      return {
      month: r.ownershipMonthIndex,
      ownershipDate: r.loanDate,
      roi,
      loanValue,
      cumFees: r.cumFees,
      realized,
      remainingBalance: r.balance,
      unrealized
    };
  });

    // Return updated loan object
    return {
      ...l,
      amort: { schedule: amortSchedule },
      scheduleWithOwnership,
      cumSchedule,
      balanceAtPurchase: amortSchedule.find(r => r.loanDate >= purchase)?.balance ?? 0,
      roiSeries,
      miniPts: roiSeries.slice(0, 24).map(r => ({ y: r.roi, ownershipDate: r.ownershipDate }))
    };


        const miniPts = roiSeries.slice(0, Math.min(24, roiSeries.length)).map(s=>({ y:s.roi, ownershipDate: s.ownershipDate }));

        // return updated loan object
        return {
          ...l,
          amort: amortData,
          amortSchedule: schedule,
          monthsSinceStart,
          scheduleWithOwnership,
          cumSchedule,
          balanceAtPurchase,
          roiSeries,
          miniPts
        };
      });

    /* -------------------------
       KPI computations
       ------------------------- */
    function getCurrentOwnedRoiEntry(loan){
      const today = new Date();
      const ownedEntries = loan.roiSeries.filter(r => r.ownershipDate && r.ownershipDate <= today);
      if (!ownedEntries.length) return { roi: 0, loanValue: loan.purchasePrice };
      return ownedEntries[ownedEntries.length - 1];
    }

    function getLastOwnedRoiEntry(loan){
      if (!loan.roiSeries || !loan.roiSeries.length) return { roi: 0, loanValue: loan.purchasePrice };
      return loan.roiSeries[loan.roiSeries.length - 1];
    }

    function computeKPIs(list){
      const total = list.reduce((s,l)=>s + l.purchasePrice,0);
      const weightedROI = list.reduce((s,l)=>{
        const entry = getCurrentOwnedRoiEntry(l);
        return s + l.purchasePrice * (entry.roi || 0);
      }, 0) / Math.max(1, total);
      const projectedWeightedROI = list.reduce((s,l)=> s + l.purchasePrice * ( (l.roiSeries[l.roiSeries.length-1] || {}).roi || 0 ), 0) / Math.max(1, total);
      const avgRate = list.reduce((s,l)=> s + l.nominalRate * l.purchasePrice, 0) / Math.max(1, total);
      return { total, weightedROI, projectedWeightedROI, avgRate };
    }
    const kpis = computeKPIs(loansWithAmort);

    /* -------------------------
       Small chart utilities (line & bar with hover)
       ------------------------- */
    function createLineChart(containerEl, series, opts = {}) {
      containerEl.innerHTML = '';
      const svgNS = "http://www.w3.org/2000/svg";
      const rect = containerEl.getBoundingClientRect();
      const w = Math.max(360, rect.width || 600);
      const h = opts.h || 260;
      const pad = opts.pad || 28;
      const svg = document.createElementNS(svgNS, "svg");
      svg.setAttribute("viewBox", `0 0 ${w} ${h}`);
      svg.setAttribute("width", "100%");
      svg.setAttribute("height", "100%");
      svg.style.display = "block";

      const data = series.length ? series.slice() : [{ x: 0, y: 0 }];
      const ys = data.map(d => d.y);
      const minY = Math.min(...ys);
      const maxY = Math.max(...ys);
      const rangeY = Math.max(1e-6, maxY - minY);
      const stepX = (w - pad * 2) / Math.max(1, data.length - 1);
      const xForMonth = month => pad + (Math.min(Math.max(month, 1), data.length) - 1) * stepX;
      function toXY(d, i) {
        const x = pad + i * stepX;
        const y = pad + (h - pad * 2) - ((d.y - minY) / rangeY) * (h - pad * 2);
        return [x, y];
      }

      for (let gy = 0; gy < 5; gy++) {
        const y = pad + gy * ((h - pad * 2) / 4);
        const line = document.createElementNS(svgNS, 'line');
        line.setAttribute('x1', pad);
        line.setAttribute('x2', w - pad);
        line.setAttribute('y1', y);
        line.setAttribute('y2', y);
        line.setAttribute('stroke', '#eef2f7');
        svg.appendChild(line);
      }

      let path = '';
      data.forEach((p, i) => {
        const xy = toXY(p, i);
        path += (i === 0 ? ('M ' + xy[0] + ' ' + xy[1]) : (' L ' + xy[0] + ' ' + xy[1]));
      });
      const el = document.createElementNS(svgNS, 'path');
      el.setAttribute('d', path);
      el.setAttribute('fill', 'none');
      el.setAttribute('stroke', opts.color || '#0ea5e9');
      el.setAttribute('stroke-width', '2');
      svg.appendChild(el);

      // Static vertical line at "today" based on ownershipDate
      const today = new Date();
      let todayIdx = -1;
      data.forEach((d, i) => {
        if (d.ownershipDate && d.ownershipDate <= today) {
          todayIdx = i;
        }
      });
      if (todayIdx === -1) todayIdx = 0;
      const todayX = pad + todayIdx * stepX;
      const todayLine = document.createElementNS(svgNS, "line");
      todayLine.setAttribute("x1", todayX);
      todayLine.setAttribute("x2", todayX);
      todayLine.setAttribute("y1", pad);
      todayLine.setAttribute("y2", h - pad);
      todayLine.setAttribute("stroke", "#111827");
      todayLine.setAttribute("stroke-dasharray", "3 3");
      todayLine.setAttribute("stroke-opacity", "0.6");
      svg.appendChild(todayLine);

      const vLine = document.createElementNS(svgNS, 'line');
      vLine.setAttribute('stroke', '#111827');
      vLine.setAttribute('stroke-dasharray', '3 4');
      vLine.setAttribute('stroke-opacity', '0.6');
      svg.appendChild(vLine);
      const hoverG = document.createElementNS(svgNS, 'g');
      hoverG.setAttribute('class', 'hover');
      svg.appendChild(hoverG);
      svg.addEventListener('mousemove', function (ev) {
        const rect = svg.getBoundingClientRect();
        const svgX = ev.clientX - rect.left;
        let idx = Math.round((svgX - pad) / stepX);
        idx = Math.max(0, Math.min(data.length - 1, idx));
        const point = data[idx];
        const [cx, cy] = toXY(point, idx);
        vLine.setAttribute('x1', cx);
        vLine.setAttribute('x2', cx);
        vLine.setAttribute('y1', pad);
        vLine.setAttribute('y2', h - pad);
        hoverG.innerHTML = '';
        const c = document.createElementNS(svgNS, 'circle');
        c.setAttribute('cx', cx);
        c.setAttribute('cy', cy);
        c.setAttribute('r', 4);
        c.setAttribute('fill', opts.color || '#0ea5e9');
        c.setAttribute('stroke', 'var(--card)');
        c.setAttribute('stroke-width', '1');
        hoverG.appendChild(c);
        tooltip.style.display = 'block';
        tooltip.style.left = (rect.left + cx) + 'px';
        tooltip.style.top = (rect.top + cy - 28) + 'px';
        tooltip.innerHTML = (opts.labelFn ? opts.labelFn(point, idx) : (point.ownershipDate ? `Date: ${formatDate(point.ownershipDate)} â€¢ ${(point.y * 100).toFixed(2)}%` : (`M${point.x} â€¢ ${(point.y * 100).toFixed(2)}%`)));
      });
      svg.addEventListener('mouseleave', function () { hoverG.innerHTML = ''; tooltip.style.display = 'none'; });
      containerEl.appendChild(svg); return svg;
    }
    function smoothPathFromPoints(points) {
      if (points.length < 3) {
      return points.map((p,i) => 
        (i===0 ? `M ${p[0]} ${p[1]}` : `L ${p[0]} ${p[1]}`)
        ).join(' ');
    }

    let d = `M ${points[0][0]} ${points[0][1]}`;
    for (let i = 1; i < points.length - 1; i++) {
      const p0 = points[i - 1];
     const p1 = points[i];
      const p2 = points[i + 1];

      const c1x = (p0[0] + p1[0]) / 2;
      const c1y = (p0[1] + p1[1]) / 2;
      const c2x = (p1[0] + p2[0]) / 2;
      const c2y = (p1[1] + p2[1]) / 2;

      d += ` C ${c1x} ${c1y}, ${c2x} ${c2y}, ${p2[0]} ${p2[1]}`;
    }
    return d;
  }

   // --- Multi-series chart (loan lines + weighted line) ---
/* ============================================================
   Multi-Series ROI Chart (Aligned by Purchase Date, Smoothed)
   ============================================================ */

function createMultiSeriesChart(containerEl, loanSeriesList, weightedSeries, opts = {}) {
  containerEl.innerHTML = "";
  const svgNS = "http://www.w3.org/2000/svg";

  const rect = containerEl.getBoundingClientRect();
  const w = Math.max(360, rect.width || 700);
  const h = opts.h || 260;
  const pad = opts.pad || 28;

  const svg = document.createElementNS(svgNS, "svg");
  svg.setAttribute("viewBox", `0 0 ${w} ${h}`);
  svg.setAttribute("width", "100%");
  svg.setAttribute("height", "100%");
  svg.style.display = "block";

  // -------------------------
  // Build a unified date axis
  // -------------------------
  const globalDates = opts.dates || [];
  const count = globalDates.length;

  if (!count) {
    containerEl.appendChild(svg);
    return;
  }

  // x scale based on real dates
  const ms0 = globalDates[0].getTime();
  const ms1 = globalDates[count - 1].getTime();
  const msRange = ms1 - ms0 || 1;

  const dateToX = (d) => {
    const t = d.getTime();
    const ratio = (t - ms0) / msRange;
    return pad + ratio * (w - pad * 2);
  };

  // Determine Y range
  let ys = [];
  weightedSeries.forEach((p) => ys.push(p.y));
  loanSeriesList.forEach((ls) => ls.data.forEach((p) => ys.push(p.y)));

  const minY = Math.min(...ys);
  const maxY = Math.max(...ys);
  const rangeY = maxY - minY || 1;

  const yScale = (yVal) => {
    const pct = (yVal - minY) / rangeY;
    return pad + (h - pad * 2) - pct * (h - pad * 2);
  };

  // -----------------------------------
  // Draw grid + Y-axis percentage labels
  // -----------------------------------
  const steps = 4; // 5 lines / labels
  for (let gy = 0; gy <= steps; gy++) {
    const ratio = gy / steps;
    const y = pad + ratio * (h - pad * 2);

    // grid line
    const line = document.createElementNS(svgNS, "line");
    line.setAttribute("x1", pad);
    line.setAttribute("x2", w - pad);
    line.setAttribute("y1", y);
    line.setAttribute("y2", y);
    line.setAttribute("stroke", "var(--border)");
    line.setAttribute("stroke-opacity", "0.16");
    svg.appendChild(line);

    // label value: top = maxY, bottom = minY
    const value = maxY - ratio * rangeY;
    const label = document.createElementNS(svgNS, "text");
    label.setAttribute("x", pad - 0);
    label.setAttribute("y", y);
    label.setAttribute("text-anchor", "end");
    label.setAttribute("dominant-baseline", "middle");
    label.setAttribute("font-size", "10");
    label.setAttribute("fill", "var(--muted)");
    label.style.pointerEvents = "none";
    label.textContent = (value * 1000).toFixed(1) + "%";
    svg.appendChild(label);
  }


  
  // -----------------------------------
  // Smoothing path helper
  // -----------------------------------
  function smoothPathFromPointsCubic(points) {
    if (points.length < 2) return "";

    let d = `M ${points[0][0]} ${points[0][1]}`;
    for (let i = 1; i < points.length; i++) {
      const p0 = points[i - 1];
      const p1 = points[i];
      const cx = (p0[0] + p1[0]) / 2;
      const cy = (p0[1] + p1[1]) / 2;
      d += ` Q ${p0[0]} ${p0[1]}, ${cx} ${cy}`;
    }
    d += ` T ${points[points.length - 1][0]} ${points[points.length - 1][1]}`;
    return d;
  }

  // -----------------------------------
  // Draw loan lines
  // -----------------------------------
  loanSeriesList.forEach((ls) => {
    const pts = ls.data
      .filter((pt) => pt.y != null)
      .map((pt) => [dateToX(pt.date), yScale(pt.y)]);

    if (!pts.length) return;

    const path = document.createElementNS(svgNS, "path");
    path.setAttribute("d", smoothPathFromPointsCubic(pts));
    path.setAttribute("fill", "none");
    path.setAttribute("stroke", ls.color || "#888");
    path.setAttribute("stroke-width", "1.2");
    path.setAttribute("stroke-opacity", "0.9");
    svg.appendChild(path);
  });

  // -----------------------------------
  // Weighted line (black)
  // -----------------------------------
  if (weightedSeries.length) {
    const pts = weightedSeries.map((pt) => [
      dateToX(pt.date),
      yScale(pt.y),
    ]);

    const path = document.createElementNS(svgNS, "path");
    path.setAttribute("d", smoothPathFromPointsCubic(pts));
    path.setAttribute("fill", "none");
    path.setAttribute("stroke", opts.weightedColor || "#000");
    path.setAttribute("stroke-width", opts.weightedWidth || "2.6");
    svg.appendChild(path);
  }

  // -----------------------------------
  // X-axis
  // -----------------------------------
  const axisGroup = document.createElementNS(svgNS, "g");
  const tickSpacing = 12;

  globalDates.forEach((dateObj, idx) => {
    if (idx % tickSpacing !== 0) return;
    const x = dateToX(dateObj);

    const lbl = document.createElementNS(svgNS, "text");
    lbl.setAttribute("x", x);
    lbl.setAttribute("y", h - 4);
    lbl.setAttribute("text-anchor", "middle");
    lbl.setAttribute("font-size", "10");
    lbl.setAttribute("fill", "var(--muted)");
    lbl.textContent = formatMonthYear(dateObj);
    axisGroup.appendChild(lbl);
  });

  svg.appendChild(axisGroup);

  // =======================================================
  // >>> INSERTED HOVER SYSTEM (Weighted ROI hover only) <<<
  // =======================================================

  const hoverLine = document.createElementNS(svgNS, 'line');
  hoverLine.setAttribute('stroke', '#111827');
  hoverLine.setAttribute('stroke-dasharray', '3 3');
  hoverLine.setAttribute('stroke-opacity', '0.6');
  hoverLine.style.display = 'none';
  svg.appendChild(hoverLine);

  const hoverCircle = document.createElementNS(svgNS, 'circle');
  hoverCircle.setAttribute('r', 4);
  hoverCircle.setAttribute('fill', '#000');
  hoverCircle.setAttribute('stroke', 'var(--card)');
  hoverCircle.setAttribute('stroke-width', '1');
  hoverCircle.style.display = 'none';
  svg.appendChild(hoverCircle);

  svg.addEventListener('mousemove', (ev) => {
    const rectSvg = svg.getBoundingClientRect();
    const mouseX = ev.clientX - rectSvg.left;

    let bestIdx = 0;
    let bestDist = Infinity;

    globalDates.forEach((d, i) => {
      const x = dateToX(d);
      const dist = Math.abs(mouseX - x);
      if (dist < bestDist) {
        bestDist = dist;
        bestIdx = i;
      }
    });

    const date = globalDates[bestIdx];
    const wPt = weightedSeries[bestIdx];
    const cx = dateToX(date);
    const cy = yScale(wPt.y);

    hoverLine.style.display = 'block';
    hoverLine.setAttribute('x1', cx);
    hoverLine.setAttribute('x2', cx);
    hoverLine.setAttribute('y1', pad);
    hoverLine.setAttribute('y2', h - pad);

    hoverCircle.style.display = 'block';
    hoverCircle.setAttribute('cx', cx);
    hoverCircle.setAttribute('cy', cy);

    tooltip.style.display = 'block';
    tooltip.style.left = (rectSvg.left + cx) + 'px';
    tooltip.style.top = (rectSvg.top + cy - 30) + 'px';
    tooltip.innerHTML =
      `${formatDate(date)}<br>` +
      `Weighted ROI: ${(wPt.y * 100).toFixed(2)}%`;
  });

  svg.addEventListener('mouseleave', () => {
    hoverLine.style.display = 'none';
    hoverCircle.style.display = 'none';
    tooltip.style.display = 'none';
  });

  // END HOVER INSERT
  // =======================================================

  containerEl.appendChild(svg);
}
   


function createBarChart(containerEl, keys, values, opts = {}) {
  containerEl.innerHTML = '';

  const svgNS = "http://www.w3.org/2000/svg";
  const rect = containerEl.getBoundingClientRect();
  const w = Math.max(360, rect.width || 600);
  const h = opts.h || 260;

  const padL = opts.padL || 55;
  const padR = opts.padR || 20;
  const padT = opts.padT || 25;
  const padB = opts.padB || 55;

  const svg = document.createElementNS(svgNS, "svg");
  svg.setAttribute("viewBox", `0 0 ${w} ${h}`);
  svg.setAttribute("width", "100%");
  svg.setAttribute("height", "100%");
  svg.style.display = "block";

  const maxValue = Math.max(...values, 1);
  const barW = (w - padL - padR) / Math.max(1, keys.length);

  const yIsCount = !!opts.yIsCount;
  const colors = opts.colors || null;

  // --- GRID LINES + Y LABELS ---
  for (let i = 0; i <= 5; i++) {
    const y = padT + (h - padT - padB) * (i / 5);

    const line = document.createElementNS(svgNS, "line");
    line.setAttribute("x1", padL);
    line.setAttribute("x2", w - padR);
    line.setAttribute("y1", y);
    line.setAttribute("y2", y);
    line.setAttribute("stroke", "var(--border)");
    line.setAttribute("stroke-opacity", "0.35");
    svg.appendChild(line);

    const value = maxValue * (1 - i / 5);
    const lbl = document.createElementNS(svgNS, "text");
    lbl.textContent = yIsCount ? String(Math.round(value)) : ("$" + Math.round(value).toLocaleString());
    lbl.setAttribute("x", padL - 10);
    lbl.setAttribute("y", y + 4);
    lbl.setAttribute("font-size", "11");
    lbl.setAttribute("fill", "var(--text)");
    lbl.setAttribute("text-anchor", "end");
    svg.appendChild(lbl);
  }

  // --- HOVER GROUP (created now, appended later so it stays on TOP) ---
  const hoverG = document.createElementNS(svgNS, "g");
  hoverG.setAttribute("class", "hover");

  // --- DRAW BARS ---
  keys.forEach((k, i) => {
    const amount = values[i];

    const x = padL + i * barW;
    const barH = (amount / maxValue) * (h - padT - padB);
    const y = h - padB - barH;

    const bar = document.createElementNS(svgNS, "rect");
    bar.setAttribute("x", x + 6);
    bar.setAttribute("y", y);
    bar.setAttribute("width", barW - 12);
    bar.setAttribute("height", barH);
    bar.setAttribute("rx", 4);
    const fillColor = colors ? colors[i % colors.length] : (opts.color || "#0ea5e9");
    bar.setAttribute("fill", fillColor);
    bar.setAttribute("data-idx", i);
    bar.classList.add(opts.barClass || "bar");
    bar.style.cursor = "pointer";

    // --- UNIFIED HOVER TOOLTIP ---
    bar.addEventListener("mousemove", (ev) => {
      const rectSvg = svg.getBoundingClientRect();
      const cx = ev.clientX - rectSvg.left;
      const cy = ev.clientY - rectSvg.top;

      hoverG.innerHTML = "";

      // black floating tooltip box above bar
      const tipBg = document.createElementNS(svgNS, "rect");
      tipBg.setAttribute("x", cx - 45);
      tipBg.setAttribute("y", cy - 38);
      tipBg.setAttribute("width", 90);
      tipBg.setAttribute("height", 26);
      tipBg.setAttribute("rx", 6);
      tipBg.setAttribute("fill", "black");
      tipBg.setAttribute("opacity", "0.85");

      const tipTxt = document.createElementNS(svgNS, "text");
      tipTxt.textContent = yIsCount ? (amount + " loans") : ("$" + amount.toLocaleString());
      tipTxt.setAttribute("x", cx);
      tipTxt.setAttribute("y", cy - 21);
      tipTxt.setAttribute("font-size", "12");
      tipTxt.setAttribute("font-weight", "600");
      tipTxt.setAttribute("fill", "white");
      tipTxt.setAttribute("text-anchor", "middle");

      hoverG.appendChild(tipBg);
      hoverG.appendChild(tipTxt);
    });

    bar.addEventListener("mouseleave", () => {
      hoverG.innerHTML = "";
    });

    svg.appendChild(bar);

    // X axis labels
    const lbl = document.createElementNS(svgNS, "text");
    lbl.textContent = k;
    lbl.setAttribute("x", x + barW / 2);
    lbl.setAttribute("y", h - padB + 22);
    lbl.setAttribute("font-size", "11");
    lbl.setAttribute("fill", "var(--text)");
    lbl.setAttribute("text-anchor", "middle");
    svg.appendChild(lbl);
  });

  // --- ADD HOVER GROUP LAST (IMPORTANT: fixes tooltip behind bars) ---
  svg.appendChild(hoverG);

  containerEl.appendChild(svg);
  return svg;
}

function createHistogram(containerEl, values, bins=6, opts={}) {
      containerEl.innerHTML=''; const minV=Math.min(...values); const maxV=Math.max(...values); const range=Math.max(1e-6,maxV-minV); const binSize=range/bins; const counts=new Array(bins).fill(0); values.forEach(v=>{ let idx=Math.floor((v-minV)/binSize); if(idx===bins) idx=bins-1; counts[idx]++; }); const labels=counts.map((_,i)=>{ const a=minV+i*binSize; const b=a+binSize; return `${(a*100).toFixed(1)}â€“${(b*100).toFixed(1)}%`; }); return createBarChart(containerEl, labels, counts, opts); }

    /* -------------------------
       UI: Render KPI tiles
       ------------------------- */
    const kpisEl = document.getElementById('kpis');
    kpisEl.innerHTML = `
      <div class="kpi" data-kpi="tpv"><h3>Weighted ROI to Date</h3><p id="wroi">${(kpis.weightedROI*100).toFixed(2)}%</p></div>
      <div class="kpi" data-kpi="rates"><h3>Projected Weighted ROI</h3><p id="wproj">${(kpis.projectedWeightedROI*100).toFixed(2)}%</p></div>
      <div class="kpi" data-kpi="avgRate"><h3>Avg Rate</h3><p>${(kpis.avgRate*100).toFixed(2)}%</p></div>
      <div class="kpi" data-kpi="distribution"><h3>Total Loans</h3><p>${loansWithAmort.length}</p></div>
    `;

    /* -------------------------
       Render loan tiles + mini charts
       ------------------------- */
    const grid = document.getElementById('loanGrid');
    const tooltip = document.getElementById('tooltip');

    loansWithAmort.forEach((loan, idx) => {
      const currentRoiEntry = getCurrentOwnedRoiEntry(loan);
      const tile = document.createElement('div'); tile.className='tile'; tile.setAttribute('tabindex','0');
      tile.innerHTML = `
        <div class="tile-left">

        <!-- Line 1: Loan Name -->
        <div class="loan-name" style="font-weight:700; font-size:14px;">
        ${loan.name || loan.loanName || ("Loan " + loan.id)}
       </div>

        <!-- Line 2: School -->
        <div class="loan-name" style="font-weight:700; font-size:14px; margin-top:2px;">
        ${loan.school || "No school listed"}
       </div>

        <!-- Line 3: Rate Â· Term Â· Matures -->
        <div class="loan-sub" style="margin-top:6px;">
        Rate: ${(loan.nominalRate * 100).toFixed(2)}% &nbsp;Â·&nbsp;
        Term: ${loan.termYears} yrs &nbsp;Â·&nbsp;
        Matures: ${formatMonthYear(
        addMonths(new Date(loan.loanStartDate), loan.termYears * 12)
        )}
        </div>

        <!-- Line 4: Loan ID -->
        <div class="loan-sub" style="margin-top:4px;">
         Loan ${loan.id}
      </div>

    </div>

    <div class="chart-wrap">
      <div class="mini-label">
      ROI ${(currentRoiEntry.roi * 100).toFixed(2)}%
    </div>
    <svg class="sparkline" viewBox="0 0 170 48" preserveAspectRatio="none" data-idx="${idx}" aria-hidden="true"></svg>
  </div>
`;

      tile.addEventListener('click', e=>{ e.stopPropagation(); openDrawerForLoan(loan); });
      tile.addEventListener('keydown', e=>{ if(e.key==='Enter'||e.key===' '){ e.preventDefault(); openDrawerForLoan(loan); } });
      grid.appendChild(tile);

      // render mini chart: cumulative ROI points
      const svg = tile.querySelector('svg.sparkline');
      const w=170,h=48,pad=6;
      const pts = loan.miniPts && loan.miniPts.length ? loan.miniPts : loan.roiSeries.map(s=>({ y: s.roi, ownershipDate: s.ownershipDate }));
      const ys = pts.map(p=>p.y); const minY=Math.min(...ys); const maxY=Math.max(...ys); const rangeY=Math.max(1e-6,maxY-minY);
      const stepX=(w-pad*2)/Math.max(1,pts.length-1);
      let d=''; pts.forEach((p,i)=>{ const x=pad + i*stepX; const y = pad + (h - pad*2) - ((p.y - minY)/rangeY)*(h - pad*2); d += (i===0?('M '+x+' '+y):(' L '+x+' '+y)); });
      svg.innerHTML = `<path d="${d}" fill="none" stroke="#0ea5e9" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"></path><g class="mini-hover"></g>`;
      // vertical line at "today" based on ownershipDate in roiSeries
      const today = new Date();
      // find index of last roiSeries entry whose ownershipDate <= today
      let todayIdxFull = -1;
      loan.roiSeries.forEach((entry, i) => {
        if (entry.ownershipDate && entry.ownershipDate <= today) {
          todayIdxFull = i;
        }
      });
      if (todayIdxFull === -1) todayIdxFull = 0;

      // map into the pts array used for the mini chart (pts may be a slice of roiSeries)
      const maxIdxInPts = pts.length - 1;
      const todayIdx = Math.max(0, Math.min(maxIdxInPts, todayIdxFull));
      const dashX = pad + todayIdx * stepX;

      const line = document.createElementNS('http://www.w3.org/2000/svg','line');
      line.setAttribute('x1', dashX);
      line.setAttribute('x2', dashX);
      line.setAttribute('y1', 2);
      line.setAttribute('y2', h - 2);
      line.setAttribute('stroke', '#111827');
      line.setAttribute('stroke-dasharray', '3 3');
      line.setAttribute('stroke-opacity', '0.6');
      svg.appendChild(line);
      svg.addEventListener('mousemove', ev=>{ const rect=svg.getBoundingClientRect(); const relX=ev.clientX-rect.left; const step = (w-pad*2)/Math.max(1,pts.length-1); let idxNearest=Math.round((relX-pad)/step); idxNearest=Math.max(0,Math.min(pts.length-1,idxNearest)); const p = loan.roiSeries[idxNearest]; tooltip.style.left=ev.clientX+'px'; tooltip.style.top=(ev.clientY-10)+'px'; tooltip.style.display='block'; tooltip.innerHTML = 'Date: '+formatDate(p.ownershipDate)+' â€¢ ROI '+(p.roi*100).toFixed(2)+'%'; const hoverG = svg.querySelector('g.mini-hover'); hoverG.innerHTML=''; const cx = pad + idxNearest*step; const cy = pad + (h - pad*2) - ((p.roi - minY)/rangeY)*(h - pad*2); const c=document.createElementNS('http://www.w3.org/2000/svg','circle'); c.setAttribute('cx',cx); c.setAttribute('cy',cy); c.setAttribute('r',3.6); c.setAttribute('fill','#0ea5e9'); c.setAttribute('stroke','var(--card)'); c.setAttribute('stroke-width','1'); hoverG.appendChild(c); });
      svg.addEventListener('mouseleave', ()=>{ tooltip.style.display='none'; const hoverG = svg.querySelector('g.mini-hover'); if(hoverG) hoverG.innerHTML=''; });
    });

    /* -------------------------
       Drawer helpers & openers
       ------------------------- */
    const drawer = document.getElementById('drawer');
    const drawerTitle = document.getElementById('drawerTitle');
    const drawerSub = document.getElementById('drawerSub');
    const drawerPrimaryTitle = document.getElementById('drawerPrimaryTitle');
    const drawerPrimary = document.getElementById('drawerPrimary');
    const drawerSecondaryTitle = document.getElementById('drawerSecondaryTitle');
    const drawerSecondary = document.getElementById('drawerSecondary');
    const drawerChartArea = document.getElementById('drawerChartArea');
    const drawerLegend = document.getElementById('drawerLegend');
    const drawerExtra = document.getElementById('drawerExtra');
    const drawerAmortContainer = document.getElementById('drawerAmortContainer');

    document.getElementById('closeBtn').addEventListener('click', closeDrawer);
    document.addEventListener('keydown', (e)=>{ if(e.key==='Escape') closeDrawer(); });

    function closeDrawer(){ drawer.classList.remove('open'); drawer.setAttribute('aria-hidden','true'); tooltip.style.display='none'; currentLoan=null; currentMode=null; }

    let currentLoan=null, currentMode=null;

    
function populateROILoanTable(){
  const tbody = document.querySelector("#roiLoansTable tbody");
  if(!tbody) return;
  const palette = ['#e11d48','#f97316','#f59e0b','#eab308','#84cc16','#10b981','#06b6d4','#3b82f6','#6366f1','#8b5cf6'];
  tbody.innerHTML = loansWithAmort.map(l => {
    const roiEntry = getCurrentOwnedRoiEntry(l);
    let matStr = '';
    try {
      const pd = new Date(l.purchaseDate);
      const months = Math.round((l.termYears + l.graceYears) * 12);
      pd.setMonth(pd.getMonth() + months);
      matStr = pd.toISOString().slice(0,10);
    } catch(e) {
      matStr = '';
    }
    const roiPct = (roiEntry.roi || 0) * 100;
    const color = palette[(l.id-1) % palette.length];
    return `<tr>
      <td style="text-align:left;"><span style="display:inline-block;width:10px;height:10px;background:${color};border-radius:2px;margin-right:8px;vertical-align:middle;"></span>${formatLoanLabel(l)}</td>
      <td style="text-align:left;">${l.purchaseDate}</td>
      <td style="text-align:left;">${matStr}</td>
      <td style="text-align:right;color:${color};font-weight:700">${roiPct.toFixed(2)}%</td>
    </tr>`;
  }).join('');
}


function openDrawerForLoan(loan){
      currentMode='loan'; currentLoan=loan;
      drawerTitle.textContent =
        `Loan ${loan.id} â€” ${loan.name} (${loan.school || "No school"})`;
      drawerSub.textContent = 'Purchased: ' + loan.purchaseDate + ' â€¢ Balance at Purchase: $' + loan.balanceAtPurchase.toLocaleString();
      drawerPrimaryTitle.textContent = 'Purchase Price'; drawerPrimary.textContent = '$' + loan.purchasePrice.toLocaleString();
      drawerSecondaryTitle.textContent = 'Nominal Rate'; drawerSecondary.textContent = (loan.nominalRate*100).toFixed(2)+'%';
      drawerExtra.innerHTML=''; drawerLegend.style.display='flex'; drawerLegend.innerHTML = '<div class=\"item\"><span class=\"sw\" style=\"background:#0f172a\"></span>Balance</div><div class=\"item\"><span class=\"sw\" style=\"background:#0ea5e9\"></span>ROI</div>';

      const series = loan.roiSeries.map(s=>({x: formatMonthYear(s.ownershipDate), y:s.roi, ownershipDate: s.ownershipDate}));
      createLineChart(drawerChartArea, series, { color:'#0ea5e9', loanStartDate: loan.loanStartDate, labelFn:(pt)=>`Date: ${formatDate(pt.ownershipDate)} â€¢ ROI ${(pt.y*100).toFixed(2)}%` });

      // ROI-by-month table (replaces amort table)
      drawerAmortContainer.innerHTML = '<h3 style="margin-top:8px">ROI by Month</h3><div class="amort-wrap"><table><thead><tr><th>Month</th><th style="text-align:right">Balance</th><th style="text-align:right">Cum Interest</th><th style="text-align:right">Cum Payments</th><th style="text-align:right">Cum Fees</th><th style="text-align:right">Loan Value</th><th style="text-align:right">ROI</th></tr></thead><tbody id="roiBody"></tbody></table></div>';
      const roiBody = document.getElementById('roiBody');
      roiBody.innerHTML = '';
      // build rows using cumSchedule and roiSeries, accounting for amortization fees
      loan.roiSeries.forEach(s => {
        const month = s.month;
        const cs = loan.cumSchedule.find(r => r.ownershipMonthIndex === month) || {};
        const balance = (cs.balance !== undefined) ? cs.balance : '';
        const cumInterest = (cs.cumInterest !== undefined) ? cs.cumInterest : '';
        const cumPayments = (cs.cumTotal !== undefined) ? cs.cumTotal : '';
        const cumFees = s.cumFees ?? 0;
        const loanValueAdj = s.loanValue ?? 0;
        const roiAdj = s.roi || 0;
        const tr = document.createElement('tr');
        const loanDate = cs.loanDate ? formatDate(cs.loanDate) : '';
        tr.innerHTML = `<td style="text-align:left">${loanDate}</td><td style="text-align:right">$${Number(balance).toFixed(2)}</td><td style="text-align:right">$${Number(cumInterest).toFixed(2)}</td><td style="text-align:right">$${Number(cumPayments).toFixed(2)}</td><td style="text-align:right">$${Number(cumFees).toFixed(2)}</td><td style="text-align:right">$${Number(loanValueAdj).toFixed(2)}</td><td style="text-align:right">${(roiAdj*100).toFixed(2)}%</td>`;
        roiBody.appendChild(tr);
      });

      drawer.classList.add('open'); drawer.setAttribute('aria-hidden','false'); drawer.scrollTop=0;
    }

    /* ============================================
   HISTORICAL ROI TIMELINE ENGINE
   Builds a unified date-based ROI timeline
   For all loans, from earliest purchase â†’ today
   ============================================ */

function buildHistoricalRoiTimeline(loans) {
  const today = new Date();

  // ---- 1. Determine global timeline ----
  const earliestPurchase = loans.reduce((earliest, l) => {
    const d = new Date(l.purchaseDate);
    return d < earliest ? d : earliest;
  }, new Date(loans[0].purchaseDate));

  // Build monthly date list from earliest â†’ today
  const dates = [];
  const cursor = new Date(earliestPurchase);
  while (cursor <= today) {
    dates.push(new Date(cursor));
    cursor.setMonth(cursor.getMonth() + 1);
  }

  // ---- 2. Align each loan ROI onto the global date timeline ----
  const perLoanSeries = loans.map((loan, idx) => {
    const purchase = new Date(loan.purchaseDate);
    const color = loanColors[idx % loanColors.length];

    // Map ownershipDate -> ROI for quick lookup
    const roiMap = {};
    loan.roiSeries.forEach(entry => {
      if (entry.ownershipDate) {
        roiMap[new Date(entry.ownershipDate).toISOString().slice(0,7)] = entry.roi;
      }
    });

    // Build calendar-aligned ROI (null before purchase)
    let lastKnownROI = 0;

    const data = dates.map(date => {
      if (date < purchase) {
      return { date, y: null };
      }

    const key = date.toISOString().slice(0, 7);

    if (key in roiMap) {
    lastKnownROI = roiMap[key];
    }

    // forward-fill ROI after purchase
    return { date, y: lastKnownROI };
    });


    return {
      name: `Loan ${loan.id}`,
      color,
      data
    };
  });

  // ---- 3. Build weighted ROI series ----
  const totalInvested = loans.reduce((s, l) => s + l.purchasePrice, 0);

  const weightedSeries = dates.map((date, i) => {
    let weightedSum = 0;

    loans.forEach((loan, idx) => {
      const roi = perLoanSeries[idx].data[i].y;
      if (roi != null) {
        weightedSum += roi * loan.purchasePrice;
      }
    });

    const weightedRoi = weightedSum / totalInvested;

    return { date, y: weightedRoi };
  });

  return {
    dates,
    perLoanSeries,
    weightedSeries,
    earliestDate: earliestPurchase
  };
}

/* ==========================================================
   DATE-ALIGNED CHART ENGINE HELPERS
   ========================================================== */

// Convert YYYY-MM-DD to Date objects
function toDate(d) {
  return (d instanceof Date) ? d : new Date(d);
}

// Difference in months between two dates
function monthDiff(a, b) {
  a = toDate(a);
  b = toDate(b);
  return (b.getFullYear() - a.getFullYear()) * 12 + (b.getMonth() - a.getMonth());
}

// Format ticks (Jan 2024)
function formatMonthYear(d) {
  return d.toLocaleString("en-US", { month: "short", year: "numeric" });
}

// Simple catmull-rom smoothing
function smoothPath(points) {
  if (points.length < 3) {
    return `M${points.map(p => `${p.x},${p.y}`).join(" L")}`;
  }
  let d = `M${points[0].x},${points[0].y}`;
  for (let i = 1; i < points.length - 2; i++) {
    const xc = (points[i].x + points[i + 1].x) / 2;
    const yc = (points[i].y + points[i + 1].y) / 2;
    d += ` Q ${points[i].x},${points[i].y} ${xc},${yc}`;
  }
  const n = points.length;
  d += ` T ${points[n - 1].x},${points[n - 1].y}`;
  return d;
}


      
    /* -------------------------
       KPI drawer renderers
       ------------------------- */
    function getMonthlyTotals(list){ const totals={}; list.forEach(l=>{ const d=new Date(l.purchaseDate); const key=`${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}`; totals[key]=(totals[key]||0)+l.purchasePrice; }); return totals; }

/* ================================
   TPV Drawer â€” Weighted ROI To Date
   ================================ */
function renderTPVDrawer() {
  if (!loansWithAmort || !loansWithAmort.length) return;

  currentMode = 'kpi';
  currentLoan = null;

  drawerAmortContainer.innerHTML = '';
  drawerLegend.style.display = 'none';
  drawerChartArea.innerHTML = '';
  
  // --- Drawer Titles ---
  drawerTitle.textContent = "Portfolio â€” Weighted ROI (To Date)";
  drawerSub.textContent = "Snapshot";

  // --- Compute weighted ROI to date ---
  const totalInvested = loansWithAmort.reduce((s,l)=> s + l.purchasePrice, 0);

  let weightedROI = 0;
  loansWithAmort.forEach(l => {
    const last = getCurrentOwnedRoiEntry(l);
    weightedROI += l.purchasePrice * (last.roi || 0);
  });
  weightedROI = weightedROI / Math.max(1, totalInvested);

  drawerPrimaryTitle.textContent = "Weighted ROI to Date";
  drawerPrimary.textContent = (weightedROI * 100).toFixed(2) + "%";

  // Portfolio value today (mark-to-market sum)
  let portfolioValue = 0;
  loansWithAmort.forEach(l => {
    const last = getCurrentOwnedRoiEntry(l);
    portfolioValue += last.loanValue || 0;
  });

  drawerSecondaryTitle.textContent = "Portfolio Value";
  drawerSecondary.textContent = "$" + portfolioValue.toLocaleString();

const timeline = buildHistoricalRoiTimeline(loansWithAmort);

createMultiSeriesChart(
  drawerChartArea,
  timeline.perLoanSeries,
  timeline.weightedSeries,
  {
    weightedColor: "#000",
    weightedWidth: 2.6,
    dates: timeline.dates
  }
);



   // --- Build ROI table (reuse existing helper) ---
  drawerExtra.innerHTML = `
    <div style="margin-top:12px">
      <h3 style="margin:0 0 8px 0">ROI to Date â€” All Loans</h3>
      <div style="
        max-height:300px;
        overflow:auto;
        border:1px solid var(--border);
        border-radius:8px;
        padding:6px;
        background:var(--card);
      ">
        <table id="roiLoansTable" class="roi-table" style="width:100%;font-size:13px;">
          <thead>
            <tr>
              <th style="text-align:left;">Loan</th>
              <th style="text-align:left;">Purchase Date</th>
              <th style="text-align:left;">Maturity Date</th>
              <th style="text-align:right;">ROI to Date</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>
    </div>
  `;

  // fill rows using the helper you already defined
  populateROILoanTable();

  // open drawer (inline, since there is no openDrawer() helper)
  drawer.classList.add('open');
  drawer.setAttribute('aria-hidden', 'false');
  drawer.scrollTop = 0;
}
      
    function renderDistributionDrawer() {
  currentMode = 'kpi';
  currentLoan = null;

  drawerAmortContainer.innerHTML = '';
  drawerLegend.style.display = 'none';
  drawerChartArea.innerHTML = '';
  drawerExtra.innerHTML = '';

  drawerTitle.textContent = 'Total Loans';
  drawerSub.textContent = 'Loan Purchase Amounts Per Month';

  // same monthly totals as before
  const totalsObj = getMonthlyTotals(loansWithAmort);  // { '2024-01': 18500, ... }
  const keys = Object.keys(totalsObj).sort();          // chronological
  const values = keys.map(k => totalsObj[k]);
  const totalInv = values.reduce((a, b) => a + b, 0);

  drawerPrimaryTitle.textContent = 'Total Invested';
  drawerPrimary.textContent = '$' + totalInv.toLocaleString();

  drawerSecondaryTitle.textContent = 'Current Portfolio Value';
  const portfolioValue = loansWithAmort.reduce((sum, l) => {
    const row = getCurrentOwnedRoiEntry(l);
    return sum + (row.loanValue || l.purchasePrice);
  }, 0);
  drawerSecondary.textContent = '$' + portfolioValue.toLocaleString();

  if (!keys.length) {
    drawer.classList.add('open');
    drawer.setAttribute('aria-hidden', 'false');
    return;
  }

  // -------------------------------
  // STACKED BAR CHART (monthly)
  // -------------------------------
  const svgNS = 'http://www.w3.org/2000/svg';
  const rect = drawerChartArea.getBoundingClientRect();
  const w = Math.max(360, rect.width || 700);
  const h = 260;

  const padL = 55, padR = 20, padT = 25, padB = 55;
  const chartH = h - padT - padB;

  const svg = document.createElementNS(svgNS, 'svg');
  svg.setAttribute('viewBox', `0 0 ${w} ${h}`);
  svg.setAttribute('width', '100%');
  svg.setAttribute('height', '100%');
  svg.style.display = 'block';
  drawerChartArea.appendChild(svg);

  // same palette as the other KPI drawers
  const palette = [
    '#e11d48','#f97316','#f59e0b','#eab308','#84cc16',
    '#10b981','#06b6d4','#3b82f6','#6366f1','#8b5cf6'
  ];

  // loans per month key (YYYY-MM)
  const monthLoans = keys.map(key => {
    return loansWithAmort.filter(l => {
      if (!l.purchaseDate) return false;
      const d = new Date(l.purchaseDate);
      if (Number.isNaN(d.getTime())) return false;
      const mKey = `${d.getFullYear()}-${String(d.getMonth() + 1).padStart(2, '0')}`;
      return mKey === key;
    });
  });

  const maxValue = Math.max(...values, 1);
  const barW = (w - padL - padR) / keys.length;

  // grid + Y labels ($)
  for (let i = 0; i <= 5; i++) {
    const y = padT + chartH * (i / 5);

    const line = document.createElementNS(svgNS, 'line');
    line.setAttribute('x1', padL);
    line.setAttribute('x2', w - padR);
    line.setAttribute('y1', y);
    line.setAttribute('y2', y);
    line.setAttribute('stroke', 'var(--border)');
    line.setAttribute('stroke-opacity', '0.35');
    svg.appendChild(line);

    const value = maxValue * (1 - i / 5);
    const lbl = document.createElementNS(svgNS, 'text');
    lbl.textContent = '$' + Math.round(value).toLocaleString();
    lbl.setAttribute('x', padL - 10);
    lbl.setAttribute('y', y + 4);
    lbl.setAttribute('font-size', '11');
    lbl.setAttribute('fill', 'var(--text)');
    lbl.setAttribute('text-anchor', 'end');
    svg.appendChild(lbl);
  }

  const tooltipEl = document.getElementById('tooltip');

  keys.forEach((key, i) => {
    const totalForMonth = totalsObj[key];
    const loansInMonth = monthLoans[i].slice().sort((a, b) => a.id - b.id);
    const x = padL + i * barW;

    let currentY = h - padB;

    // stack each loan's amount in this month
  loansInMonth.forEach((loan, loanIdx) => {
    const segH = (loan.purchasePrice / maxValue) * chartH;
    currentY -= segH;

    const palette = ['#e11d48','#f97316','#f59e0b','#eab308','#84cc16',
             '#10b981','#06b6d4','#3b82f6','#6366f1','#8b5cf6'];

    const color = palette[loanIdx % palette.length];


      const seg = document.createElementNS(svgNS, 'rect');
      seg.setAttribute('x', x + 6);
      seg.setAttribute('y', currentY);
      seg.setAttribute('width', barW - 12);
      seg.setAttribute('height', segH - 1);
      seg.setAttribute('rx', 3);
      seg.setAttribute('fill', color);
      seg.style.cursor = 'pointer';

      seg.addEventListener('mousemove', ev => {
        if (!tooltipEl) return;
        const count = loansInMonth.length;
        const countText = count === 1 ? '1 loan' : `${count} loans`;
        tooltipEl.style.display = 'block';
        tooltipEl.style.left = ev.clientX + 'px';
        tooltipEl.style.top = (ev.clientY - 28) + 'px';
        tooltipEl.innerHTML =
          `${key} â€¢ ${countText}<br>` +
          `${formatLoanLabel(loan)} â€¢ $${loan.purchasePrice.toLocaleString()}`;
      });

      seg.addEventListener('mouseleave', () => {
        if (tooltipEl) tooltipEl.style.display = 'none';
      });

      svg.appendChild(seg);
    });

    // X-axis label: month key
    const lbl = document.createElementNS(svgNS, 'text');
    lbl.textContent = key;
    lbl.setAttribute('x', x + barW / 2);
    lbl.setAttribute('y', h - padB + 20);
    lbl.setAttribute('font-size', '11');
    lbl.setAttribute('fill', 'var(--text)');
    lbl.setAttribute('text-anchor', 'middle');
    svg.appendChild(lbl);
  });

  // -------------------------------
  // Color-coded loans table
  // -------------------------------
  drawerExtra.innerHTML = `
    <h3 style="margin-top:12px;margin-bottom:8px">Loans</h3>
    <div style="
      border:1px solid rgba(15,23,42,0.06);
      border-radius:8px;
      max-height:260px;
      overflow:auto;
      background:var(--card);
      padding:6px;
    ">
      <table style="width:100%;font-size:13px">
        <thead>
          <tr>
            <th style="text-align:left">Loan</th>
            <th style="text-align:left">Purchase</th>
            <th style="text-align:right">Amount</th>
            <th style="text-align:right">Rate</th>
          </tr>
        </thead>
        <tbody id="totalLoansTableBody"></tbody>
      </table>
    </div>
  `;

  const tbody = document.getElementById('totalLoansTableBody');
  tbody.innerHTML = '';

  loansWithAmort.forEach(l => {
    const color = palette[(l.id - 1) % palette.length];
    const row = `
      <tr>
        <td style="text-align:left;">
          <span style="
            display:inline-block;
            width:10px;
            height:10px;
            border-radius:2px;
            background:${color};
            margin-right:8px;
            vertical-align:middle;
          "></span>
          ${formatLoanLabel(l)}
        </td>
        <td style="text-align:left;">${l.purchaseDate}</td>
        <td style="text-align:right;">$${l.purchasePrice.toLocaleString()}</td>
        <td style="text-align:right;color:${color};font-weight:600;">
          ${(l.nominalRate * 100).toFixed(2)}%
        </td>
      </tr>`;
    tbody.insertAdjacentHTML('beforeend', row);
  });

  drawer.classList.add('open');
  drawer.setAttribute('aria-hidden', 'false');
}

      /* ============================================================
   PROJECTED ROI TIMELINE ENGINE
   Extends to each loan's maturity (NOT to today's date)
   ============================================================ */
function buildProjectedRoiTimeline(loans) {
  // ---- 1. Determine global start (earliest purchase) ----
  const earliestPurchase = loans.reduce((earliest, l) => {
    const d = new Date(l.purchaseDate);
    return d < earliest ? d : earliest;
  }, new Date(loans[0].purchaseDate));

  // ---- 2. Determine global end (latest maturity date) ----
  const latestMaturity = loans.reduce((latest, l) => {
    const mat = new Date(l.purchaseDate);
    mat.setMonth(mat.getMonth() + Math.round((l.termYears + l.graceYears) * 12));
    return mat > latest ? mat : latest;
  }, new Date(earliestPurchase));

  // ---- 3. Build monthly date list earliest â†’ latest maturity ----
  const dates = [];
  const cursor = new Date(earliestPurchase);
  while (cursor <= latestMaturity) {
    dates.push(new Date(cursor));
    cursor.setMonth(cursor.getMonth() + 1);
  }

  // ---- 4. Align per-loan ROI series ----
  const perLoanSeries = loans.map((loan, idx) => {
    const purchase = new Date(loan.purchaseDate);
    const roiMap = {};

    loan.roiSeries.forEach(entry => {
      if (entry.ownershipDate) {
        roiMap[new Date(entry.ownershipDate).toISOString().slice(0,7)] = entry.roi;
      }
    });

    let lastKnownROI = 0;

    const data = dates.map(date => {
      if (date < purchase) return { date, y: null };

      const key = date.toISOString().slice(0,7);
      if (roiMap[key] != null) lastKnownROI = roiMap[key];

      return { date, y: lastKnownROI };
    });

    return {
      name: `Loan ${loan.id}`,
      color: loanColors[idx % loanColors.length],
      data
    };
  });

  // ---- 5. Weighted ROI series ----
  const totalInvested = loans.reduce((s,l)=> s + l.purchasePrice, 0);

  const weightedSeries = dates.map((date, i) => {
    let weightedSum = 0;
    loans.forEach((loan, idx) => {
      const roi = perLoanSeries[idx].data[i].y;
      if (roi != null) {
        weightedSum += roi * loan.purchasePrice;
      }
    });
    return { date, y: weightedSum / totalInvested };
  });

  return {
    dates,
    perLoanSeries,
    weightedSeries
  };
}


    function renderRatesDrawer(){
  currentMode = 'kpi';
currentLoan = null;

drawerAmortContainer.innerHTML = '';
drawerLegend.style.display = 'none';
drawerChartArea.innerHTML = '';
drawerExtra.innerHTML = '';

drawerTitle.textContent = "Projected Weighted ROI";
drawerSub.textContent = "Projection to Maturity";

// ===============================
// 1. Compute projected weighted ROI
// ===============================
const totalInv = loansWithAmort.reduce((s,l)=> s + l.purchasePrice, 0);

let projWeightedROI = 0;
loansWithAmort.forEach(l => {
  const last = getLastOwnedRoiEntry(l);
  projWeightedROI += l.purchasePrice * (last.roi || 0);
});
projWeightedROI = projWeightedROI / Math.max(1, totalInv);

drawerPrimaryTitle.textContent = "Projected Weighted ROI";
drawerPrimary.textContent = (projWeightedROI * 100).toFixed(2) + "%";

// ===============================
// 2. Compute projected portfolio value
// ===============================
let projPortfolioValue = 0;
loansWithAmort.forEach(l => {
  const last = getLastOwnedRoiEntry(l);
  projPortfolioValue += last.loanValue || 0;
});

drawerSecondaryTitle.textContent = "Projected Portfolio Value";
drawerSecondary.textContent = "$" + projPortfolioValue.toLocaleString();

// ===============================
// 3. Build timeline (calendar aligned)
// ===============================
const timeline = buildProjectedRoiTimeline(loansWithAmort);
      
// ===============================
// 4. Render multi-series chart WITH hover
// ===============================
createMultiSeriesChart(
  drawerChartArea,
  timeline.perLoanSeries,
  timeline.weightedSeries,
  {
    weightedColor: "#000",
    weightedWidth: 2.6,
    dates: timeline.dates
  }
);

// ===============================
// 5. Table of projected ROI for each loan
// ===============================
drawerExtra.innerHTML = `
  <div style="margin-top:12px">
    <h3 style="margin:0 0 8px 0">Projected ROI at Maturity â€” All Loans</h3>
    <div style="
      max-height:300px;
      overflow:auto;
      border:1px solid var(--border);
      border-radius:8px;
      padding:6px;
      background:var(--card);
    ">
      <table id="roiLoansTable" class="roi-table" style="width:100%;font-size:13px;">
        <thead>
          <tr>
            <th style="text-align:left;">Loan</th>
            <th style="text-align:left;">Purchase Date</th>
            <th style="text-align:left;">Maturity Date</th>
            <th style="text-align:right;">Projected ROI</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>
  </div>
`;

populateROILoanTable();

drawer.classList.add('open');
drawer.setAttribute('aria-hidden','false');
drawer.scrollTop = 0;

}


function renderAvgRateDrawer() {
  currentMode = 'kpi';
  currentLoan = null;

  drawerTitle.textContent = 'Average Interest Rate';
  drawerSub.textContent = 'Distribution of loan nominal rates';

  drawerLegend.style.display = 'none';
  drawerAmortContainer.innerHTML = '';
  drawerExtra.innerHTML = '';
  drawerChartArea.innerHTML = '';

  if (!loansWithAmort.length) return;

  // -------------------------------
  // Build rate buckets automatically
  // -------------------------------
  const rates = loansWithAmort.map(l => l.nominalRate);
  const minR = Math.min(...rates);
  const maxR = Math.max(...rates);

  const bucketSize = 0.01; // 1% wide
  const start = Math.floor(minR * 100) / 100;
  const end = Math.ceil(maxR * 100) / 100;

  const buckets = [];
  for (let r = start; r < end; r += bucketSize) {
    const low = r;
    const high = r + bucketSize;
    const label = `${(low * 100).toFixed(1)}â€“${(high * 100).toFixed(1)}%`;

    buckets.push({ label, low, high });
  }

  const labels = buckets.map(b => b.label);

  // -------------------------------
  // Primary / Secondary KPI numbers
  // -------------------------------
  drawerPrimaryTitle.textContent = 'Average Rate';
  drawerPrimary.textContent = (kpis.avgRate * 100).toFixed(2) + '%';

  drawerSecondaryTitle.textContent = 'Loan Count';
  drawerSecondary.textContent = loansWithAmort.length;

  // -------------------------------
  // STACKED COLOR BARCHART
  // -------------------------------
  const svgNS = 'http://www.w3.org/2000/svg';
  const rect = drawerChartArea.getBoundingClientRect();
  const w = Math.max(360, rect.width || 700);
  const h = 260;

  const padL = 55, padR = 20, padT = 25, padB = 55;

  const svg = document.createElementNS(svgNS, 'svg');
  svg.setAttribute('viewBox', `0 0 ${w} ${h}`);
  svg.setAttribute('width', '100%');
  svg.setAttribute('height', '100%');
  svg.style.display = 'block';
  drawerChartArea.appendChild(svg);

  // same palette as other KPI drawers
  const palette = [
    '#e11d48','#f97316','#f59e0b','#eab308','#84cc16',
    '#10b981','#06b6d4','#3b82f6','#6366f1','#8b5cf6'
  ];

  // map each bucket to its loans
  const bucketLoans = buckets.map(
    b => loansWithAmort.filter(
      l => l.nominalRate >= b.low && l.nominalRate < b.high
    )
  );

  const maxStack = Math.max(...bucketLoans.map(list => list.length), 1);

  // grid + y labels
  for (let i = 0; i <= 5; i++) {
    const y = padT + (h - padT - padB) * (i / 5);

    const line = document.createElementNS(svgNS, 'line');
    line.setAttribute('x1', padL);
    line.setAttribute('x2', w - padR);
    line.setAttribute('y1', y);
    line.setAttribute('y2', y);
    line.setAttribute('stroke', 'var(--border)');
    line.setAttribute('stroke-opacity', '0.35');
    svg.appendChild(line);

    const value = maxStack * (1 - i / 5);
    const lbl = document.createElementNS(svgNS, 'text');
    lbl.textContent = String(Math.round(value));
    lbl.setAttribute('x', padL - 10);
    lbl.setAttribute('y', y + 4);
    lbl.setAttribute('font-size', '11');
    lbl.setAttribute('fill', 'var(--text)');
    lbl.setAttribute('text-anchor', 'end');
    svg.appendChild(lbl);
  }

  const barW = (w - padL - padR) / labels.length;
  const tooltipEl = document.getElementById('tooltip');

  bucketLoans.forEach((loanList, iBucket) => {
    const x = padL + iBucket * barW;
    const stackHeight = (loanList.length / maxStack) * (h - padT - padB);
    let currentY = h - padB;

    // consistent ordering
    loanList.sort((a, b) => a.id - b.id);

    const bucketCount = loanList.length;

    loanList.forEach((loan) => {
      const segH = (1 / maxStack) * (h - padT - padB);
      currentY -= segH;

      const color = palette[(loan.id - 1) % palette.length];

      const seg = document.createElementNS(svgNS, 'rect');
      seg.setAttribute('x', x + 6);
      seg.setAttribute('y', currentY);
      seg.setAttribute('width', barW - 12);
      seg.setAttribute('height', segH - 1);
      seg.setAttribute('rx', 3);
      seg.setAttribute('fill', color);
      seg.style.cursor = 'pointer';

      // HTML tooltip ABOVE everything
      seg.addEventListener('mousemove', (ev) => {
        if (!tooltipEl) return;
        const countText = bucketCount === 1 ? '1 loan' : `${bucketCount} loans`;
        const schoolName = loan.school || loan.name;
        tooltipEl.style.display = 'block';
        tooltipEl.style.left = ev.clientX + 'px';
        tooltipEl.style.top = (ev.clientY - 28) + 'px';
        tooltipEl.innerHTML =
          `${countText}: ${schoolName}<br>` +
          `Rate: ${(loan.nominalRate * 100).toFixed(2)}%`;
      });

      seg.addEventListener('mouseleave', () => {
        if (tooltipEl) tooltipEl.style.display = 'none';
      });

      svg.appendChild(seg);
    });

    // X-axis label
    const lbl = document.createElementNS(svgNS, 'text');
    lbl.textContent = labels[iBucket];
    lbl.setAttribute('x', x + barW / 2);
    lbl.setAttribute('y', h - padB + 20);
    lbl.setAttribute('font-size', '11');
    lbl.setAttribute('fill', 'var(--text)');
    lbl.setAttribute('text-anchor', 'middle');
    svg.appendChild(lbl);
  });

  // -------------------------------
  // Loan table (color-coded)
  // -------------------------------
  drawerExtra.innerHTML = `
    <div style="margin-top:12px">
      <h3 style="margin:0 0 8px 0">Loan Rates</h3>
      <div style="
        max-height:300px;
        overflow:auto;
        border:1px solid var(--border);
        border-radius:8px;
        padding:6px;
        background:var(--card);
      ">
        <table style="width:100%;font-size:13px;">
          <thead>
            <tr>
              <th style="text-align:left;">Loan</th>
              <th style="text-align:left;">Purchase Date</th>
              <th style="text-align:right;">Rate</th>
              <th style="text-align:right;">Amount</th>
            </tr>
          </thead>
          <tbody id="avgRateTableBody"></tbody>
        </table>
      </div>
    </div>
  `;

  const tbody = document.getElementById('avgRateTableBody');
  tbody.innerHTML = '';

  loansWithAmort.forEach(l => {
    const color = palette[(l.id - 1) % palette.length];
    const row = `
      <tr>
        <td style="text-align:left;">
          <span style="
            display:inline-block;
            width:10px;
            height:10px;
            border-radius:2px;
            background:${color};
            margin-right:8px;
            vertical-align:middle;
          "></span>
          ${formatLoanLabel(l)}
        </td>
        <td style="text-align:left;">${l.purchaseDate}</td>
        <td style="text-align:right;color:${color};font-weight:600;">
          ${(l.nominalRate * 100).toFixed(2)}%
        </td>
        <td style="text-align:right;">$${l.purchasePrice.toLocaleString()}</td>
      </tr>`;
    tbody.insertAdjacentHTML('beforeend', row);
  });

  drawer.classList.add('open');
  drawer.setAttribute('aria-hidden', 'false');
}

    /* -------------------------
       KPI wiring & interactions
       ------------------------- */
    document.querySelectorAll('.kpi').forEach(k=>{ k.addEventListener('click', ev=>{ ev.stopPropagation(); const key=k.getAttribute('data-kpi'); if(key==='distribution') renderDistributionDrawer(); if(key==='tpv') renderTPVDrawer(); if(key==='rates') renderRatesDrawer(); if(key==='avgRate') renderAvgRateDrawer(); }); });

    /* -------------------------
       CSV / clipboard / download / print
       ------------------------- */
    function copyPortfolioCSV(){ let rows=[['Loan','Purchase Date','Amount','Rate']]; loansWithAmort.forEach(l=>rows.push([formatLoanLabel(l),l.purchaseDate,l.purchasePrice,(l.nominalRate*100).toFixed(2)+'%'])); const csv=rows.map(r=>r.join(',')).join('\n'); navigator.clipboard.writeText(csv); alert('CSV copied to clipboard'); }
    function amortToCSV(loan){ const rows=[['Month','Payment','Principal','Interest','Balance']]; loan.amort.schedule.forEach(r=>rows.push([r.monthIndex,r.payment.toFixed(2),r.principalPaid.toFixed(2),r.interest.toFixed(2),r.balance.toFixed(2)])); return rows.map(r=>r.join(',')).join('\n'); }
    document.getElementById('copyCsvBtn')?.addEventListener('click', async ()=>{ if(currentMode!=='loan' || !currentLoan) return alert('Open an individual loan drawer to copy CSV'); const csv=amortToCSV(currentLoan); try{ await navigator.clipboard.writeText(csv); alert('CSV copied to clipboard'); }catch(e){ alert('Copy failed â€” browser denied clipboard access'); } });
    document.getElementById('downloadCsvBtn')?.addEventListener('click', ()=>{ if(currentMode==='loan' && currentLoan){ const csv=amortToCSV(currentLoan); const blob=new Blob([csv],{type:'text/csv;charset=utf-8;'}); const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download='loan-'+currentLoan.id+'-amort.csv'; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url); } else alert('Download CSV is supported for individual loan drawers only.'); });
    document.getElementById('printBtn')?.addEventListener('click', ()=>window.print());

    /* -------------------------
       Close drawer on outside click; hide tooltip on scroll
       ------------------------- */
    document.addEventListener('click', function(e){ if(!drawer.classList.contains('open')) return; const clickedInside=drawer.contains(e.target); const clickedTile=!!e.target.closest('.tile'); if(!clickedInside && !clickedTile) closeDrawer(); });
    document.querySelector('.grid').addEventListener('scroll', ()=>{ tooltip.style.display='none'; });

    /* -------------------------
       End
       ------------------------- */



    } // END initROI()

    document.addEventListener("DOMContentLoaded", async () => {
      await loadLoans();
      document.getElementById("currentDate").textContent = formatDate(new Date());
      initROI();
    });

    // theme toggle
window.addEventListener("DOMContentLoaded", () => {
  const toggle = document.getElementById("themeToggle");
  if (!toggle) return;

  const applyTheme = (theme) => {
    document.documentElement.setAttribute("data-theme", theme);
    document.body.classList.toggle("dark", theme === "dark");
    localStorage.setItem("theme", theme);
    toggle.textContent = theme === "dark" ? "â˜€ï¸" : "ðŸŒ™";
    toggle.setAttribute("aria-label", theme === "dark" ? "Switch to light mode" : "Switch to dark mode");
    toggle.setAttribute("title", theme === "dark" ? "Switch to light mode" : "Switch to dark mode");
  };

  const saved = localStorage.getItem("theme");
  const prefersDark = window.matchMedia("(prefers-color-scheme: dark)").matches;
  applyTheme(saved || (prefersDark ? "dark" : "light"));

  toggle.addEventListener("click", () => {
    const nextTheme = document.documentElement.getAttribute("data-theme") === "dark" ? "light" : "dark";
    applyTheme(nextTheme);
  });
});

</script>
</body>
</html>

<!-- Added customTooltip function -->
<script>

const loanColors = [
  "#ef4444", "#f97316", "#eab308", "#22c55e", "#06b6d4",
  "#3b82f6", "#6366f1", "#a855f7", "#ec4899", "#14b8a6"
];
  
function customTooltip(context) {
    let tooltipEl = document.getElementById('chartjs-tooltip');
    if (!tooltipEl) {
        tooltipEl = document.createElement('div');
        tooltipEl.id = 'chartjs-tooltip';
        tooltipEl.style.position = 'absolute';
        tooltipEl.style.background = 'rgba(0,0,0,0.85)';
        tooltipEl.style.color = 'var(--card)';
        tooltipEl.style.padding = '8px 12px';
        tooltipEl.style.borderRadius = '6px';
        tooltipEl.style.pointerEvents = 'none';
        tooltipEl.style.transition = '0.1s ease';
        tooltipEl.style.zIndex = '9999';
        document.body.appendChild(tooltipEl);
    }
    const tooltip = context.tooltip;
    if (tooltip.opacity === 0) {
        tooltipEl.style.opacity = 0;
        return;
    }
    tooltipEl.style.opacity = 1;
    tooltipEl.innerHTML = `<div style="font-weight:600;font-size:13px;">${tooltip.dataPoints[0].formattedValue}</div>`;
    const { offsetLeft, offsetTop } = context.chart.canvas;
    tooltipEl.style.left = offsetLeft + tooltip.caretX + 15 + 'px';
    tooltipEl.style.top = offsetTop + tooltip.caretY + 'px';
}
</script>
