<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Loan Portfolio â€” Amortization</title>

  <style>
    :root {
     --bg:#f0f4f8;
     --surface:#f1f5f9;
     --card:#ffffff;
     --text:#0f172a;
     --muted:#64748b;
     --border:#e2e8f0;
     --shadow:rgba(0,0,0,0.08);
     --brand:#0ea5e9;
     --brand-strong:#0284c7;
     --accent1:#7c3aed;
     --accent2:#0ea5e9;
     --accent3:#14b8a6;
     --accent4:#f97316;
     --accent5:#ef4444;
    --stat-bg:#f8fafc;
    --stat-border:#e2e8f0;
    --grad-top:var(--surface);
    --grad-bottom:var(--card);
    --font-smooth:antialiased;
    --tile-bg:var(--card);
    --tile-hover-bg:#f8fafc;
    --drawer-bg:var(--card);
    --drawer-shadow:rgba(0,0,0,0.10);
    --tooltip-bg:#0f172a;     /* solid black tooltip */
    --tooltip-text:#f8fafc;   /* white text */
  }

    html { color-scheme:light; }

      html[data-theme="dark"] {
      color-scheme: dark;

      --bg:#0f172a;
      --surface:#1e293b;
      --card:#1e293b;
      --text:#f1f5f9;
      --muted:#94a3b8;
      --border:#334155;
      --shadow:rgba(0,0,0,0.45);

      --stat-bg:#1e293b;
      --stat-border:#334155;

      --grad-top:#1e293b;
      --grad-bottom:#0f172a;

      --tile-bg:#1e293b;
      --tile-hover-bg:#243447;

      --drawer-bg:#1e293b;
      --drawer-shadow:rgba(0,0,0,0.55);

      --table-header:#1e293b;
      --table-stripe:rgba(255,255,255,0.02);

      --tooltip-bg:#0f172a;
      --tooltip-text:#f8fafc;
    }


    html,body{
      height:100%;
      margin:0;
      font-family:Inter, system-ui, -apple-system, "Segoe UI", Roboto, Arial;
      color:var(--text);
      -webkit-font-smoothing:antialiased;
    }

    body {
      background: linear-gradient(180deg, var(--grad-top) 0%, var(--grad-bottom) 100%);
      background-color: var(--bg);
      -webkit-font-smoothing: var(--font-smooth);
      transition: background-color .25s ease, color .25s ease;
    }

    
    html[data-theme="dark"] body { background:linear-gradient(180deg,#0b1224 0%, #0f172a 100%); }

    .app{
      max-width:1200px;
      margin:20px auto 0 auto;   /* remove extra bottom margin */
      padding:16px 16px 0 16px;  /* remove extra bottom padding */
      transition:color .25s ease;
    }

     body > .app {
      background: transparent;
      padding-top: 16px;  /* match earnings exactly */
      margin-top: 0;
    }

    header{
      display:flex;
      flex-direction:column;
      gap:8px;
      margin-bottom:8px;   /* match earnings */
      padding:0;            /* remove invisible offset */
      transition:color .25s ease;
    }

    .header-top{
      display:flex;
      align-items:center;
      justify-content:space-between;
    }

    .header-controls{display:flex;gap:10px;align-items:center}

    h1{ font-size:20px; margin:0; }
    p.lead{ margin:0; color:var(--muted); font-size:13px; }
    .current-date{ font-size:13px; color:var(--muted); margin-top:4px; }

    /* KPI row */
    .kpis{
      display:grid;
      grid-template-columns:repeat(4,1fr);
      gap:12px;
      margin:14px 0 18px;
    }
    .kpi{
      background:var(--card);
      padding:12px;
      border-radius:10px;
      box-shadow:var(--shadow);
      border:1px solid var(--border);
      cursor:pointer;
      transition: transform .18s, box-shadow .18s, background-color .25s ease, color .25s ease, border-color .25s ease;
    }
    .kpi:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 16px rgba(0,0,0,0.15);
    }

    .kpi h3{ margin:0; font-size:12px; color:var(--muted) }
    .kpi p{ margin:8px 0 0; font-size:18px; font-weight:700 }

    /* Grid of tiles */
    .grid{
      display:grid;
      grid-template-columns:repeat(2,1fr);
      gap:12px;
      height:calc(100vh - 320px);
      overflow:auto;
      padding-right:6px;
    }
    @media(max-width:900px){
      .grid{ grid-template-columns:1fr; height:auto }
      .kpis{ grid-template-columns:repeat(2,1fr) }
    }

    .tile{
      display:flex;
      align-items:center;
      justify-content:space-between;
      padding:10px 12px;
      border-radius:12px;
      background:var(--card);
      min-height:110px;
      cursor:pointer;
      overflow:hidden;
      border:1px solid var(--border);
      transition: transform .18s ease, box-shadow .18s ease, background-color .25s ease, color .25s ease, border-color .25s ease;
    }
    .tile:hover{ transform:translateY(-6px); box-shadow:var(--shadow) }

    .tile-left{ flex:1; padding-right:10px }
    .loan-name{ font-weight:700; font-size:14px }
    .loan-sub{ font-size:12px; color:var(--muted); margin-top:6px }
    .loan-meta{ display:flex; gap:8px; font-size:12px; color:var(--muted); margin-top:8px }

    .chart-wrap{ width:170px; flex-shrink:0; display:flex; flex-direction:column; align-items:flex-end }
    .mini-label{ font-size:12px; color:var(--muted); margin-bottom:6px }
    svg.sparkline{ width:170px; height:48px; display:block }

    /* Drawer */
    .drawer{
      position:fixed;
      right:0;
      top:0;
      height:100vh;
      width:560px;
      background:var(--card);
      box-shadow:-28px 0 80px rgba(2,6,23,0.14);
      transform:translateX(110%);
      transition:transform .28s cubic-bezier(.2,.9,.3,1), background-color .25s ease, color .25s ease, border-color .25s ease, box-shadow .25s ease;
      z-index:90;
      overflow:hidden;
      padding:0;
      border-left:1px solid var(--border);
      display:flex;
      flex-direction:column;
    }
    .drawer.open{ transform:translateX(0) }

    .drawer-header{ padding:20px; flex-shrink:0; }
    .drawer-head{ display:flex; align-items:start; justify-content:space-between; gap:8px }
    .close-btn{
      background:#f1f5f9;
      border:none;
      padding:8px;
      border-radius:8px;
      cursor:pointer;
      transition:background-color .25s ease, color .25s ease;
    }
    .drawer h2{ margin:0 0 6px; font-size:20px }
    .muted{ color:var(--muted); font-size:13px; margin-bottom:10px }

    .drawer-body,
    #drawerBody{ flex:1 1 auto; overflow-y:auto; overflow-x:hidden; padding:0 20px 20px; }

    .drawer,
    .drawer-body,
    #drawerBody{ overflow-x:hidden; }

    .drawer-footer{ flex-shrink:0; padding:20px; }
    .drawer-footer .actions{ justify-content:flex-start; }

    .drawer-chart{
      height:220px;
      background:var(--chart-bg);
      border-radius:8px;
      border:1px solid rgba(15,23,42,0.03);
      display:flex;
      align-items:center;
      justify-content:center;
      margin-bottom:8px;
      position:relative;
      padding:8px;
      box-shadow:0 6px 18px rgba(15,23,42,0.06);
      transition:background-color .25s ease, color .25s ease, border-color .25s ease, box-shadow .25s ease;
    }

    /* KPI2 table â€” color rows by loan color */
    .kpi2-table tbody tr[data-loan-id] {
    color: var(--loan-color);
    }

.kpi2-table tbody tr[data-loan-id] td {
  color: inherit;
}


    
    .legend { display:flex; gap:10px; font-size:12px; align-items:center; margin-top:6px; }
    .legend .item { display:flex; gap:6px; align-items:center; }
    .legend .sw { width:12px; height:8px; border-radius:2px; display:inline-block; }

    .amort-wrap{
      border:1px solid var(--border);
      border-radius:8px;
      padding:8px;
      max-height:40vh;
      overflow:auto;
      background:var(--card);
      transition:background-color .25s ease, color .25s ease, border-color .25s ease, box-shadow .25s ease;
    }

    table{ width:100%; border-collapse:collapse; font-size:13px; transition:color .25s ease; }
    thead th{
      position:sticky; top:0; background:var(--card);
      padding:8px; text-align:left; color:var(--muted); font-weight:700; border-bottom:1px solid var(--border);
      transition:background-color .25s ease, color .25s ease, border-color .25s ease;
    }
    td{ padding:8px; border-bottom:1px dashed rgba(15,23,42,0.04); text-align:right; transition:color .25s ease, border-color .25s ease; }
    td:first-child, th:first-child{ text-align:left }

    .actions{ display:flex; gap:8px; margin-top:12px }
    .btn{ padding:8px 10px; border-radius:8px; border:1px solid rgba(15,23,42,0.06); background:transparent; cursor:pointer; font-weight:600; transition:background-color .25s ease, color .25s ease, border-color .25s ease; }
    .btn.primary{ background:linear-gradient(90deg,var(--brand),var(--accent2)); color:white; border:none; box-shadow:var(--shadow); }

    .tooltip{
      position:fixed;
      pointer-events:none;
      background:var(--tooltip-bg);
      color:var(--tooltip-text);
      padding:6px 8px;
      border-radius:6px;
      font-size:12px;
      transform:translate(-50%,-120%);
      box-shadow:0 6px 18px rgba(2,6,23,0.2);
      display:none;
      z-index:9999;
      line-height:1.12;
      border:1px solid rgba(148,163,184,0.3);
      transition:background-color .25s ease, color .25s ease, border-color .25s ease, box-shadow .25s ease;
    }

    .small { font-size:12px; color:var(--muted) }

    @media(max-width:760px){ .drawer{ width:100%; min-width:0; } }

    /* Theme toggle */
    .theme-icon{
    background:var(--card);
    border:1px solid var(--border);
    font-size:18px;
    cursor:pointer;
    transition:background-color .25s ease, color .25s ease, border-color .25s ease, box-shadow .25s ease, transform .2s ease;
    width:38px;
    height:38px;
    border-radius:10px;
    display:inline-flex;
    align-items:center;
    justify-content:center;
    box-shadow:var(--shadow);
    }
    .theme-icon:hover{
    opacity:0.95;
    transform:translateY(-1px);
    }

    /* Dark mode overrides */
html[data-theme="dark"] .tile,
html[data-theme="dark"] .kpi,
html[data-theme="dark"] .amort-wrap {
  background:var(--card);
  border-color:var(--border);
  box-shadow:0 10px 30px rgba(0,0,0,0.35);
}

html[data-theme="dark"] .drawer {
  background:var(--drawer-bg);
  border-left:1px solid var(--border);
  box-shadow:-28px 0 80px var(--drawer-shadow);
}

html[data-theme="dark"] thead th {
  background:var(--surface);
  border-bottom:1px solid var(--border);
  color:var(--text);
}

html[data-theme="dark"] td {
  border-bottom:1px dashed rgba(148,163,184,0.24);
}

html[data-theme="dark"] .tooltip {
  background:var(--tooltip-bg);
  color:var(--tooltip-text);
  border-color:rgba(148,163,184,0.35);
  box-shadow:0 12px 30px rgba(0,0,0,0.45);
}

html[data-theme="dark"] .close-btn {
  background:#0f172a;
  color:var(--text);
}

    svg text{ fill:var(--text); transition:fill .25s ease; }
  </style>
</head>

<body>
  <div class="app" role="main">
    <header>
      <div class="header-top">
        <div>
          <h1>Loan Portfolio - Amortization Schedules</h1>
          <p class="lead">Click on the loan below to see & export the amortization schedule.</p>
        </div>
        <div class="header-controls">
          <div style="font-size:13px;color:var(--muted)">Name: <strong style="color:var(--brand)">Jeff Customer</strong></div>
          <button id="themeToggle" class="theme-icon" title="Toggle dark mode">ðŸŒ™</button>
        </div>
      </div>

      <div class="current-date" id="currentDateLabel">Current Date: </div>
    </header>

    <section class="kpis" id="kpis"></section>

    <section class="grid" id="loanGrid" aria-live="polite"></section>
  </div>

  <!-- Right drawer -->
  <aside id="drawer" class="drawer" aria-hidden="true">
    <div class="drawer-header">
      <div class="drawer-head">
        <div>
          <h2 id="drawerTitle">Drawer</h2>
          <div class="muted" id="drawerSub">details</div>
        </div>

        <div style="display:flex;gap:8px;align-items:center">
          <button class="btn" id="downloadCsvBtn">Download CSV</button>
          <button class="close-btn" id="closeBtn" aria-label="Close drawer">âœ•</button>
        </div>
      </div>
    </div>

    <div id="drawerBody" class="drawer-body">
      <div class="drawer-chart" id="drawerChartArea"></div>
      <div class="legend" id="drawerLegend" style="display:none"></div>

      <div style="display:flex;gap:10px;margin-bottom:8px">
        <div style="flex:1;background:var(--surface);padding:10px;border-radius:8px;border:1px solid var(--border)">
          <div style="font-size:12px;color:var(--muted)" id="drawerPrimaryTitle">Purchase Price</div>
          <div id="drawerPrimary" style="font-weight:800;font-size:18px"></div>
        </div>
        <div style="width:120px;background:var(--surface);padding:10px;border-radius:8px;border:1px solid var(--border)">
          <div style="font-size:12px;color:var(--muted)" id="drawerSecondaryTitle">Rate</div>
          <div id="drawerSecondary" style="font-weight:800;font-size:16px"></div>
        </div>
      </div>

      <div id="drawerExtra"></div>

      <div id="drawerAmortContainer">
        <h3 style="margin-top:8px">Amortization</h3>
        <div class="amort-wrap" id="amortWrap">
          <table>
            <thead>
              <tr>
                <th>Date</th><th>Payment</th><th>Principal</th><th>Interest</th><th>Balance</th>
              </tr>
            </thead>
            <tbody id="amortBody"></tbody>
          </table>
        </div>
      </div>
    </div>

    <div class="drawer-footer">
      <div class="actions">
        <button class="btn" id="printBtn">Print</button>
        <button class="btn primary" id="copyCsvBtn">Copy CSV</button>
      </div>
    </div>
  </aside>

  <div id="tooltip" class="tooltip" role="status" aria-live="polite"></div>

  <script type="module">
    import { loadLoans, attachSchedules } from "../js/loanEngine.js";

    let tpvSeriesData = [];   // <-- GLOBAL so all drawers can use it
    
    let USE_DYNAMIC_DATA = true;   // stays false until Step 7
    let allLoans = [];              // unified variable replacing allLoans
    let cachedKPIs = null;
    let apiLoans = [];   // <-- REQUIRED so init() can assign to it

   
    /* ============================
       Loan data (dates spread across ~6 months)
       ============================ */
    const loans = [
      { id:1, purchaseDate:'2025-01-15', purchasePrice:10000, termYears:10, graceYears:4.5, nominalRate:0.08 },
      { id:2, purchaseDate:'2025-02-01', purchasePrice:7500, termYears:8, graceYears:2, nominalRate:0.075 },
      { id:3, purchaseDate:'2025-02-20', purchasePrice:12000, termYears:12, graceYears:3, nominalRate:0.0825 },
      { id:4, purchaseDate:'2025-03-10', purchasePrice:6000, termYears:9, graceYears:1.5, nominalRate:0.095 },
      { id:5, purchaseDate:'2025-03-30', purchasePrice:5000, termYears:10, graceYears:1, nominalRate:0.09 },
      { id:6, purchaseDate:'2025-04-15', purchasePrice:7500, termYears:5, graceYears:0, nominalRate:0.073 },
      { id:7, purchaseDate:'2025-04-30', purchasePrice:10000, termYears:8, graceYears:0, nominalRate:0.09 },
      { id:8, purchaseDate:'2025-05-20', purchasePrice:5000, termYears:9, graceYears:0.5, nominalRate:0.11 },
      { id:9, purchaseDate:'2025-06-10', purchasePrice:10000, termYears:7, graceYears:0.25, nominalRate:0.10 },
      { id:10,purchaseDate:'2025-06-30', purchasePrice:8000, termYears:3, graceYears:0, nominalRate:0.06 }
    ];

    /* ============================
       Amortization (grace interest capitalized)
       ============================ */
    function calcAmort(principal, annualRate, termYears, graceYears) {
      const monthlyRate = annualRate / 12;
      const totalMonths = Math.round(termYears * 12);
      const graceMonths = Math.round(graceYears * 12);
      const repayMonths = Math.max(1, totalMonths - graceMonths);

      let balance = principal;
      const schedule = [];

      // Grace months â€” interest accrues and capitalizes (payment = 0)
      for (let m = 1; m <= graceMonths; m++) {
        const interest = +(balance * monthlyRate).toFixed(2);
        balance = +(balance + interest).toFixed(2); // capitalize
        schedule.push({ monthIndex: m, payment: 0, principalPaid: 0, interest, balance });
      }

      // Payment computed on capitalized balance after grace
      const payment = monthlyRate === 0
        ? +(balance / repayMonths).toFixed(2)
        : +((balance * monthlyRate) / (1 - Math.pow(1 + monthlyRate, -repayMonths))).toFixed(2);

      // Repayment months
      for (let m = 1; m <= repayMonths; m++) {
        const interest = +(balance * monthlyRate).toFixed(2);
        const principalPaid = +Math.min(balance, +(payment - interest).toFixed(2));
        balance = +(Math.max(0, balance - principalPaid).toFixed(2));
        schedule.push({ monthIndex: graceMonths + m, payment: +payment.toFixed(2), principalPaid, interest, balance });
      }

      return { payment, schedule };
    }

    /* ============================
       Build loans with amort + cumulative metrics + mini points
       ============================ */
function buildStaticLoans() {
  return loans.map(l => {
    const amort = calcAmort(l.purchasePrice, l.nominalRate, l.termYears, l.graceYears);

    let cumP = 0, cumI = 0, cumTotal = 0;

    const cumSchedule = amort.schedule.map(r => {
      cumP = +(cumP + r.principalPaid).toFixed(2);
      cumI = +(cumI + r.interest).toFixed(2);
      cumTotal = +(cumTotal + r.payment).toFixed(2);

      return {
        ...r,
        cumPrincipal: cumP,
        cumInterest: cumI,
        cumTotal,
        loanDate: new Date(),
        ownershipDate: new Date()
      };
    });

    const miniPts = cumSchedule
      .slice(0, Math.min(24, cumSchedule.length))
      .map(s => ({
        x: s.monthIndex,
        y: s.balance
      }));

    return {
      ...l,
      loanName: "Loan " + l.loanId,
      loanStartDate: l.purchaseDate,
      amort,
      cumSchedule,
      miniPts
    };
  });
}

async function init() {
if (USE_DYNAMIC_DATA) {
  let apiLoaded = await loadLoans();  // { loans, sha }
  apiLoans = apiLoaded.map(l => ({
  ...l,
id: String(l.loanId ?? l.id),      // fallback to numeric id if loanId missing
loanId: String(l.loanId ?? l.id),  // ensures no undefined

  loanName: l.loanName || ""
}));


apiLoans = attachSchedules(apiLoans);


  allLoans = apiLoans.map(l => {
    // ADD cumulative values directly into amort.schedule
    let cumP = 0, cumI = 0, cumT = 0;

    const schedule = l.amort.schedule.map(r => {
      cumP += r.principalPaid;
      cumI += r.interest;
      cumT += r.payment;

      return {
        ...r,
        cumPrincipal: +(cumP.toFixed(2)),
        cumInterest: +(cumI.toFixed(2)),
        cumTotal: +(cumT.toFixed(2))
      };
    });

    // build mini sparkline points
    const miniPts = schedule
      .slice(0, Math.min(24, schedule.length))
      .map(s => ({
        x: s.monthIndex,
        y: s.balance
      }));

    // IMPORTANT: overwrite amort.schedule so drawer charts work
    return {
      ...l,
      amort: { ...l.amort, schedule },
      cumSchedule: schedule,
      miniPts
    };
  });
}

   else {
    allLoans = buildStaticLoans();
  }
     /* ============================
       Render KPI tiles
       ============================ */
    cachedKPIs = computeKPIs(allLoans);
    const kpis = cachedKPIs;
    
    const kpisEl = document.getElementById('kpis');
    kpisEl.innerHTML = `
      <div class="kpi" data-kpi="tpv"><h3>Total Portfolio Value</h3><p id="tpvTile">$${kpis.totalPrincipal.toLocaleString()}</p></div>
      <div class="kpi" data-kpi="rates"><h3>Avg Rate</h3><p>${(kpis.weightedRate * 100).toFixed(2)}%</p></div>
      <div class="kpi" data-kpi="payments"><h3>Monthly Income</h3><p>$${kpis.monthlyIncome.toFixed(2)}</p></div>
      <div class="kpi" data-kpi="distribution"><h3>Total Loans</h3><p>${allLoans.length}</p></div>
    `;
       /* ============================
       Wire KPI clicks
       ============================ */
    document.querySelectorAll('.kpi').forEach(k => {
      k.addEventListener('click', (ev) => {
        ev.stopPropagation();
        const key = k.getAttribute('data-kpi');
        if (key === 'distribution') renderDistributionDrawer();
        if (key === 'tpv') renderTPVDrawer();
        if (key === 'rates') renderRatesDrawer();
        if (key === 'payments') renderPaymentsDrawer();
      });
    });
  
  // Now it is safe: allLoans exists
    tpvSeriesData = tpvSeries(allLoans);   // assign to global
// --------------------------------------------------
// Sort loans by purchase date (match Earnings page)
// --------------------------------------------------
allLoans.sort((a, b) => {
  const da = new Date(a.purchaseDate || a.loanStartDate).getTime() || 0;
  const db = new Date(b.purchaseDate || b.loanStartDate).getTime() || 0;
  return da - db;
});

  
  const curIdx = getCurrentMonthIndex(allLoans) - 1;
  const tpvIdx = Math.min(curIdx, tpvSeriesData.length - 1);
  document.getElementById('tpvTile').textContent =
    `$${Math.round(tpvSeriesData[tpvIdx].value).toLocaleString()}`;

   /* ============================
       Render loan tiles with mini-charts (cumulative principal & interest)
       ============================ */
    const grid = document.getElementById('loanGrid');
    const tooltip = document.getElementById('tooltip');

    allLoans.forEach((loan, idx) => {
      const tile = document.createElement('div');
      tile.className = 'tile';
      tile.setAttribute('tabindex', '0');

      tile.innerHTML = `
<div class="tile-left">
  <!-- Line 1: Loan Name (bold) -->
  <div class="loan-name" style="font-weight:700;font-size:14px;">
    ${loan.loanName}
  </div>

  <!-- Line 2: School (bold) -->
  <div class="loan-name" style="font-weight:700;font-size:13px;">
    ${loan.school || ('School ')}
  </div>

  <!-- Line 3: Rate Â· Term Â· Matures -->
  <div class="loan-sub" style="margin-top:6px;">
    Rate: ${(loan.nominalRate * 100).toFixed(2)}%
    &nbsp;Â·&nbsp;
    Term: ${loan.termYears}y
    &nbsp;Â·&nbsp;
    Matures: ${
      (() => {
        const first = new Date(loan.loanStartDate + 'T00:00:00');
        const lastIdx = loan.amort.schedule[loan.amort.schedule.length - 1].monthIndex;
        first.setMonth(first.getMonth() + (lastIdx - 1));
        return first.toLocaleDateString(undefined, { month: "short", year: "numeric" });
      })()
    }
  </div>

  <!-- Line 4: Loan ID -->
  <div class="loan-sub">
    Loan ${loan.loanId}
  </div>
</div>



        <div class="chart-wrap">
          <div class="mini-label">Rate ${(loan.nominalRate * 100).toFixed(2)}%</div>
          <svg class="sparkline" viewBox="0 0 170 48" preserveAspectRatio="none" data-idx="${idx}" aria-hidden="true"></svg>
        </div>
      `;

      // Important: stop propagation on click so the page-level click listener doesn't close the drawer immediately.
      tile.addEventListener('click', e => { e.stopPropagation(); openDrawerForLoan(loan); });
      tile.addEventListener('keydown', e => { if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); openDrawerForLoan(loan); } });

      grid.appendChild(tile);

// render mini sparkline
const svg = tile.querySelector('svg.sparkline');
const w = 170, h = 48, pad = 6;

// Correct: use cumulative schedule
const fullSched = loan.cumSchedule || [];

if (!fullSched.length) {
  svg.innerHTML = "";   // nothing to plot
  return;
}

// build point arrays
const pPoints = fullSched.map(s => ({ y: s.cumPrincipal }));
const iPoints = fullSched.map(s => ({ y: s.cumInterest }));

const pathP = buildPathFromPoints(pPoints, w, h, pad);
const pathI = buildPathFromPoints(iPoints, w, h, pad);

// calculate x-position on chart based on month index
const maxMonth = Math.max(1, fullSched.length);
const xForMonth = month => {
  const stepX = (w - pad * 2) / Math.max(1, maxMonth - 1);
  return pad + (Math.min(Math.max(month, 1), maxMonth) - 1) * stepX;
};

// derive "current month index" based on loan purchase date â†’ today
const curMonthForLoan = getCurrentMonthForLoan(loan);

// render SVG
svg.innerHTML = `
  <path d="${pathI}" fill="none" stroke="#a78bfa" stroke-width="1.6"
        stroke-linecap="round" stroke-linejoin="round"></path>

  <path d="${pathP}" fill="none" stroke="#06b6d4" stroke-width="1.6"
        stroke-linecap="round" stroke-linejoin="round"></path>

  <g class="mini-hover"></g>

  <line class="current-line"
        x1="${xForMonth(curMonthForLoan)}"
        y1="2"
        x2="${xForMonth(curMonthForLoan)}"
        y2="${h - 2}"
        stroke="#111827"
        stroke-dasharray="3 3"
        stroke-opacity="0.6" />
`;



      // Hover tooltip for mini chart
      svg.addEventListener('mousemove', ev => {
      const rect = svg.getBoundingClientRect();
      const relativeX = ev.clientX - rect.left;
      const frac = relativeX / rect.width;

      // ---------------------------------
      // SAFETY CHECK â€” INSERT HERE
      // ---------------------------------
      if (!fullSched.length) return;

      const idxNearest = Math.round(frac * (fullSched.length - 1));
      const p = fullSched[Math.max(0, Math.min(fullSched.length - 1, idxNearest))];
      if (!p) return;
      // ---------------------------------

      tooltip.style.left = (ev.clientX) + 'px';
      tooltip.style.top = (ev.clientY - 10) + 'px';
      tooltip.style.display = 'block';
      const dateLabel = chartDateLabel(loan.loanStartDate, p.monthIndex);
      tooltip.innerHTML =
      `${dateLabel} â€¢ Principal $${p.cumPrincipal.toLocaleString()} â€¢ Interest $${p.cumInterest.toLocaleString()}`;

         // draw hover circles
      const hoverG = svg.querySelector('g.mini-hover');
      hoverG.innerHTML = '';
      const svgNS = 'http://www.w3.org/2000/svg';
      const stepX = (w - pad * 2) / Math.max(1, fullSched.length - 1);
      const iX = pad + idxNearest * stepX;

      const valsP = pPoints.map(pp => pp.y);
      const valsI = iPoints.map(pp => pp.y);
      const minP = Math.min(...valsP), maxP = Math.max(...valsP), rangeP = Math.max(1, maxP - minP);
      const minI = Math.min(...valsI), maxI = Math.max(...valsI), rangeI = Math.max(1, maxI - minI);

      const cyP = pad + (h - pad * 2) - ((p.cumPrincipal - minP) / rangeP) * (h - pad * 2);
      const cyI = pad + (h - pad * 2) - ((p.cumInterest - minI) / rangeI) * (h - pad * 2);

      const cP = document.createElementNS(svgNS, 'circle');
      cP.setAttribute('cx', iX); 
      cP.setAttribute('cy', cyP); 
      cP.setAttribute('r', 3.4); 
      cP.setAttribute('fill', '#06b6d4');
      cP.setAttribute('stroke', '#fff');
      cP.setAttribute('stroke-width', '1');
      hoverG.appendChild(cP);

      const cI = document.createElementNS(svgNS, 'circle');
      cI.setAttribute('cx', iX); 
      cI.setAttribute('cy', cyI); 
      cI.setAttribute('r', 3.4); 
      cI.setAttribute('fill', '#a78bfa');
      cI.setAttribute('stroke', '#fff');
      cI.setAttribute('stroke-width', '1');
      hoverG.appendChild(cI);
    
      });

      svg.addEventListener('mouseleave', () => {
        tooltip.style.display = 'none';
        const hoverG = svg.querySelector('g.mini-hover');
        if (hoverG) hoverG.innerHTML = '';
      });
    });

// ---------- Date helpers (replace CURRENT_MONTH usage) ----------
function monthsBetween(startDateStr, endDate = new Date()) {
  const start = new Date(startDateStr + 'T00:00:00');
  let months = (endDate.getFullYear() - start.getFullYear()) * 12 +
               (endDate.getMonth() - start.getMonth()) + 1;
  return Math.max(1, months);
}

// Global "current month index" measured from earliest purchase date
function getCurrentMonthIndex(loansList) {
  if (!loansList.length) return 1;
  const earliestMs = Math.min(
    ...loansList.map(l => new Date(l.purchaseDate + 'T00:00:00').getTime())
  );
  const earliest = new Date(earliestMs);
  let months = monthsBetween(earliest.toISOString().slice(0, 10));
  const maxLen = Math.max(...loansList.map(l => l.amort.schedule.length));
  return Math.min(months, maxLen);
}

// Per-loan index (today relative to that loan only)
function getCurrentMonthForLoan(loan) {
  if (!loan?.amort?.schedule?.length) return 1;
   let months = monthsBetween(loan.loanStartDate);
  return Math.min(months, loan.amort.schedule.length);
}
// Convert purchaseDate + offset months â†’ "Feb 15, 2025"
function offsetDateByMonths(startDateStr, offset) {
  const d = new Date(startDateStr + "T00:00:00");  // ensure no timezone shift
  d.setMonth(d.getMonth() + offset);
  return d.toLocaleDateString(undefined, {
    year: "numeric",
    month: "short",
    day: "numeric"
  });
}
// Format chart date labels
function chartDateLabel(startDateStr, monthIndex) {
  const d = new Date(startDateStr + "T00:00:00");
  d.setMonth(d.getMonth() + (monthIndex - 1));  // monthIndex is 1-based
  return d.toLocaleDateString(undefined, {
    month: "short",
    year: "numeric"
  });
}


  
/* ============================
   KPI Calculations
============================ */
function computeKPIs(list) {

  // Total Portfolio Value (purchase price sum)
  const totalPrincipal = list.reduce((sum, loan) => sum + loan.purchasePrice, 0);

  // Weighted Average Rate
  const weightedRate =
    totalPrincipal > 0
      ? list.reduce((sum, loan) => sum + loan.nominalRate * loan.purchasePrice, 0) / totalPrincipal
      : 0;

   // Expected Monthly Income for "today" based on calendar dates
  const curIdx = getCurrentMonthIndex(list) - 1;
  const monthlyIncome = list.reduce((sum, loan) => {
    const pay = loan.amort.schedule[curIdx]?.payment || 0;
    return sum + pay;
  }, 0);


  // Total loan count
  const loanCount = list.length;

  return {
    totalPrincipal,
    weightedRate,
    monthlyIncome,
    loanCount
  };
}

    /* ============================
       Small helper â€” create SVG path from points
       ============================ */
    function buildPathFromPoints(points, w, h, pad = 6) {
      if (!points.length) return '';

      const ys = points.map(p => p.y);
      const minY = Math.min(...ys);
      const maxY = Math.max(...ys);
      const range = Math.max(1, maxY - minY);
      const stepX = (w - pad * 2) / Math.max(1, points.length - 1);

      let d = '';
      points.forEach((p, i) => {
        const x = pad + i * stepX;
        const y = pad + (h - pad * 2) - ((p.y - minY) / range) * (h - pad * 2);
        d += (i === 0 ? `M ${x} ${y}` : ` L ${x} ${y}`);
      });

      return d;
    }

    /* ============================
       TPV (Total Portfolio Value) series
       Definition:
         TPV_loan(m) = initialPurchase + accruedInterestDuringGrace_upTo_m + cumulativePaymentsUpTo_m
       ============================ */
    function tpvSeries(loansList) {
      const maxMonths = Math.max(...loansList.map(l => l.amort.schedule.length));
      const series = [];

      for (let m = 1; m <= maxMonths; m++) {
        let total = 0;
        loansList.forEach(l => {
          const initial = l.purchasePrice;
          // accrued interest during grace months up to m
          const accrued = l.amort.schedule
            .filter(s => s.monthIndex <= m && s.payment === 0)
            .reduce((s, r) => s + r.interest, 0);
          // cumulative payments to date up to m
          const payments = l.amort.schedule
            .filter(s => s.monthIndex <= m)
            .reduce((s, r) => s + r.payment, 0);

          total += initial + accrued + payments;
        });
        series.push({ month: m, value: total });
      }

      return series;
    }

   
   

    /* ============================
       Drawer helpers
       ============================ */
    const drawer = document.getElementById('drawer');
    const drawerTitle = document.getElementById('drawerTitle');
    const drawerSub = document.getElementById('drawerSub');
    const drawerPrimary = document.getElementById('drawerPrimary');
    const drawerSecondary = document.getElementById('drawerSecondary');
    const drawerPrimaryTitle = document.getElementById('drawerPrimaryTitle');
    const drawerSecondaryTitle = document.getElementById('drawerSecondaryTitle');
    const drawerBody = document.getElementById('drawerBody');
    const amortBody = document.getElementById('amortBody');
    const drawerChartArea = document.getElementById('drawerChartArea');
    const drawerLegend = document.getElementById('drawerLegend');
    const drawerExtra = document.getElementById('drawerExtra');
    const drawerAmortContainer = document.getElementById('drawerAmortContainer');

    document.getElementById('closeBtn').addEventListener('click', () => closeDrawer());
    document.addEventListener('keydown', (e) => { if (e.key === 'Escape') closeDrawer(); });

    let currentLoan = null;
    let currentMode = null; // 'loan' or 'kpi'

    function closeDrawer() {
      drawer.classList.remove('open');
      drawer.setAttribute('aria-hidden', 'true');
      tooltip.style.display = 'none';
      currentLoan = null;
      currentMode = null;
    }

    /* ---------- Open drawer for loan ---------- */
    function openDrawerForLoan(loan) {
      drawerExtra.innerHTML = '';
      currentMode = 'loan';
      currentLoan = loan;

     drawerTitle.textContent = `${loan.loanName} â€” ${loan.school}`;
      drawerSub.textContent = `Purchased: ${loan.purchaseDate}`;
      drawerPrimaryTitle.textContent = 'Purchase Price';
      drawerSecondaryTitle.textContent = 'Rate';
      drawerPrimary.textContent = `$${loan.purchasePrice.toLocaleString()}`;
      drawerSecondary.textContent = `${(loan.nominalRate * 100).toFixed(2)}%`;

  /* render amort rows */
drawerAmortContainer.style.display = 'block';
amortBody.innerHTML = '';

// *** THIS WAS MISSING â€” MUST EXIST BEFORE ANY DATE CHECKS ***
const purchaseDate = new Date(loan.purchaseDate + "T00:00:00");

// walk full amort schedule (from loan start),
// but mark purchase row and dim pre-purchase rows
loan.amort.schedule.forEach((r) => {

  // calendar date for this amortization row
  const rowDate = new Date(loan.loanStartDate + "T00:00:00");
  rowDate.setMonth(rowDate.getMonth() + (r.monthIndex - 1));

  const isBeforePurchase = rowDate < purchaseDate;
  const isPurchaseRow    = rowDate.getTime() === purchaseDate.getTime();

  const tr = document.createElement('tr');

  tr.innerHTML = `
    <td style="text-align:left">${offsetDateByMonths(loan.loanStartDate, r.monthIndex - 1)}</td>
    <td style="text-align:right">$${Number(r.payment).toFixed(2)}</td>
    <td style="text-align:right">$${Number(r.principalPaid).toFixed(2)}</td>
    <td style="text-align:right">$${Number(r.interest).toFixed(2)}</td>
    <td style="text-align:right">$${Number(r.balance).toFixed(2)}</td>
  `;

  // lighter rows before purchase date
  if (isBeforePurchase) {
    tr.style.opacity = "0.45";
  }

  // thin green horizontal line at the purchase row
  if (isPurchaseRow) {
    tr.querySelectorAll('td').forEach(td => {
      td.style.borderTop = "2px solid #22c55e";
    });
  }

  amortBody.appendChild(tr);
});




      /* build drawer chart (multi-line with legend & current date marker) */
      drawerChartArea.innerHTML = '';
      drawerLegend.style.display = 'flex';
      drawerLegend.innerHTML = `
        <div class="item"><span class="sw" style="background:#0f172a"></span>Balance</div>
        <div class="item"><span class="sw" style="background:#06b6d4"></span>Cum Principal</div>
        <div class="item"><span class="sw" style="background:#a78bfa"></span>Cum Interest</div>
        <div class="item"><span class="sw" style="background:#fb7185"></span>Total</div>
      `;

      const svgNS = 'http://www.w3.org/2000/svg';
      const w = 480, h = 240, pad = 28;
      const svg = document.createElementNS(svgNS, 'svg');
      svg.setAttribute('viewBox', `0 0 ${w} ${h}`);
      svg.setAttribute('width', '100%');
      svg.setAttribute('height', '100%');

      // The dynamic engine stores everything inside loan.amort.schedule
    const schedule = loan.amort?.schedule || [];

    if (!schedule.length) {
    drawerChartArea.innerHTML = "<p>No schedule data available</p>";
    return;
    }

      // Build series
      const balances = schedule.map(s => ({ x: s.monthIndex, y: s.balance }));
      const cumP     = schedule.map(s => ({ x: s.monthIndex, y: s.cumPrincipal }));
      const cumI     = schedule.map(s => ({ x: s.monthIndex, y: s.cumInterest }));
      const cumT     = schedule.map(s => ({ x: s.monthIndex, y: s.cumTotal }));


      // global Y range for consistent scaling
      const allYs = [
        ...balances.map(p => p.y),
        ...cumP.map(p => p.y),
        ...cumI.map(p => p.y),
        ...cumT.map(p => p.y)
      ];
      const maxY = Math.max(...allYs);
      const minY = Math.min(...allYs);
      const range = Math.max(1, maxY - minY);

      const stepX = (w - pad * 2) / Math.max(1, schedule.length - 1);
      function toXY(point, i) {
        const x = pad + i * stepX;
        const y = pad + (h - pad * 2) - ((point.y - minY) / range) * (h - pad * 2);
        return [x, y];
      }
      function buildPath(arr) {
        return arr.map((p, i) => {
          const [x, y] = toXY(p, i);
          return (i === 0 ? `M ${x} ${y}` : ` L ${x} ${y}`);
        }).join(' ');
      }

      // subtle grid lines
      for (let gy = 0; gy < 5; gy++) {
        const y = pad + gy * ((h - pad * 2) / 4);
        const line = document.createElementNS(svgNS, 'line');
        line.setAttribute('x1', pad);
        line.setAttribute('x2', w - pad);
        line.setAttribute('y1', y);
        line.setAttribute('y2', y);
        line.setAttribute('stroke', '#eef2f7');
        line.setAttribute('stroke-width', '1');
        svg.appendChild(line);
      }

      const pathBal = buildPath(balances);
      const pathP = buildPath(cumP);
      const pathI = buildPath(cumI);
      const pathT = buildPath(cumT);

      const elBal = document.createElementNS(svgNS, 'path');
      elBal.setAttribute('d', pathBal);
      elBal.setAttribute('fill', 'none');
      elBal.setAttribute('stroke', '#0f172a');
      elBal.setAttribute('stroke-width', '2');
      svg.appendChild(elBal);

      const elP = document.createElementNS(svgNS, 'path');
      elP.setAttribute('d', pathP);
      elP.setAttribute('fill', 'none');
      elP.setAttribute('stroke', '#06b6d4');
      elP.setAttribute('stroke-width', '1.6');
      svg.appendChild(elP);

      const elI = document.createElementNS(svgNS, 'path');
      elI.setAttribute('d', pathI);
      elI.setAttribute('fill', 'none');
      elI.setAttribute('stroke', '#a78bfa');
      elI.setAttribute('stroke-width', '1.6');
      svg.appendChild(elI);

      const elT = document.createElementNS(svgNS, 'path');
      elT.setAttribute('d', pathT);
      elT.setAttribute('fill', 'none');
      elT.setAttribute('stroke', '#fb7185');
      elT.setAttribute('stroke-width', '1.4');
      svg.appendChild(elT);

            // current date marker based on today's date vs. this loan's purchase date
      const curMonthForLoan = getCurrentMonthForLoan(loan);
      const maxMonth = schedule.length;
      const curX = pad + (Math.max(1, Math.min(curMonthForLoan, maxMonth)) - 1) * stepX;

      const curLine = document.createElementNS(svgNS, 'line');
      curLine.setAttribute('x1', curX);
      curLine.setAttribute('x2', curX);
      curLine.setAttribute('y1', pad);
      curLine.setAttribute('y2', h - pad);
      curLine.setAttribute('stroke', '#111827');
      curLine.setAttribute('stroke-dasharray', '3 4');
      curLine.setAttribute('stroke-opacity', '0.6');
      svg.appendChild(curLine);

      // hover overlay (vertical line and circles)
      const vLine = document.createElementNS(svgNS, 'line');
      vLine.setAttribute('stroke', '#0f172a');
      vLine.setAttribute('stroke-width', '1');
      vLine.setAttribute('stroke-dasharray', '3 4');
      vLine.setAttribute('opacity', '0.6');
      svg.appendChild(vLine);

      const circles = document.createElementNS(svgNS, 'g');
      svg.appendChild(circles);

// Drawer hover interactions
svg.addEventListener('mousemove', (ev) => {
  const rect = svg.getBoundingClientRect();
  const x = ev.clientX - rect.left;

  let idx = Math.round((x - pad) / stepX);
  idx = Math.max(0, Math.min(schedule.length - 1, idx));

  const px = pad + idx * stepX;
  const row = schedule[idx];

  // vertical hover line
  vLine.setAttribute('x1', px);
  vLine.setAttribute('x2', px);
  vLine.setAttribute('y1', pad);
  vLine.setAttribute('y2', h - pad);

  circles.innerHTML = '';

  // 4 series: Balance, Cum P, Cum I, Total
  const series = [
    { val: balances[idx].y, color: '#0f172a' },
    { val: cumP[idx].y,     color: '#06b6d4' },
    { val: cumI[idx].y,     color: '#a78bfa' },
    { val: cumT[idx].y,     color: '#fb7185' }
  ];

  // draw hover dots
  series.forEach(s => {
    const [cx, cy] = toXY({ y: s.val }, idx);
    const dot = document.createElementNS(svgNS, 'circle');
    dot.setAttribute('cx', cx);
    dot.setAttribute('cy', cy);
    dot.setAttribute('r', 4);
    dot.setAttribute('fill', s.color);
    dot.setAttribute('stroke', '#fff');
    dot.setAttribute('stroke-width', '1.2');
    circles.appendChild(dot);
  });

  // Calendar date label
  const dateLabel = chartDateLabel(loan.loanStartDate, row.monthIndex);

  // Tooltip
  tooltip.style.display = 'block';
  tooltip.style.left = ev.clientX + 'px';
  tooltip.style.top = (ev.clientY - 10) + 'px';
  tooltip.innerHTML =
    `${dateLabel}<br>
     Balance $${row.balance.toLocaleString()}<br>
     Principal $${row.cumPrincipal.toLocaleString()}<br>
     Interest $${row.cumInterest.toLocaleString()}`;
}); // <-- closes mousemove listener

// Hide hover state on leave
svg.addEventListener('mouseleave', () => {
  vLine.setAttribute('y1', 0);
  vLine.setAttribute('y2', 0);
  circles.innerHTML = '';
  tooltip.style.display = 'none';
}); // <-- closes mouseleave listener

// These lines stay at the end of the drawer-opening function
drawerChartArea.appendChild(svg);
drawer.classList.add('open');
drawer.setAttribute('aria-hidden', 'false');
drawerBody.scrollTop = 0;

} // <-- THIS closes openDrawerForLoan(loan) â€” required


    /* ============================
       KPI drawers: Distribution, TPV, Rates, Payments
       (each removes amortization as requested)
       ============================ */

    function monthLabel(dateStr) {
      const d = new Date(dateStr + 'T00:00:00');
      return d.toLocaleString(undefined, { year: 'numeric', month: 'short' });
    }

    function renderDistributionDrawer() {
      currentMode = 'kpi';
      currentLoan = null;

      drawerTitle.textContent = 'Distribution â€” Loans by Purchase Month';
      drawerSub.textContent = 'Number of loans purchased by month';
      drawerPrimaryTitle.textContent = '';
      drawerPrimary.textContent = '';
      drawerSecondaryTitle.textContent = 'Total Invested';

      const totalInvested = allLoans.reduce((s, l) => s + l.purchasePrice, 0);
      drawerSecondary.textContent = `$${totalInvested.toLocaleString()}`;

      drawerAmortContainer.style.display = 'none';
      drawerExtra.innerHTML = '';

      // counts by month
      const counts = {};
      allLoans.forEach(l => { const m = monthLabel(l.purchaseDate); counts[m] = (counts[m] || 0) + 1; });
      const months = Object.keys(counts);

      drawerChartArea.innerHTML = '';
      drawerLegend.style.display = 'none';

      // simple bar chart SVG
      const svgNS = 'http://www.w3.org/2000/svg';
      const w = 480, h = 220, pad = 30;
      const svg = document.createElementNS(svgNS, 'svg');
      svg.setAttribute('viewBox', `0 0 ${w} ${h}`);
      svg.setAttribute('width', '100%');
      svg.setAttribute('height', '100%');

      const maxCount = Math.max(...Object.values(counts));
      months.forEach((m, i) => {
        const barW = (w - pad * 2) / months.length * 0.7;
        const gap = ((w - pad * 2) / months.length - barW) / 2;
        const x = pad + i * ((w - pad * 2) / months.length) + gap;
        const barH = (counts[m] / Math.max(1, maxCount)) * (h - pad * 2);
        const y = h - pad - barH;

        const rect = document.createElementNS(svgNS, 'rect');
        rect.setAttribute('x', x); rect.setAttribute('y', y);
        rect.setAttribute('width', barW); rect.setAttribute('height', barH);
        rect.setAttribute('fill', '#06b6d4');
        svg.appendChild(rect);

        const text = document.createElementNS(svgNS, 'text');
        text.setAttribute('x', x + barW / 2);
        text.setAttribute('y', h - pad + 14);
        text.setAttribute('font-size', '11');
        text.setAttribute('text-anchor', 'middle');
        text.setAttribute('fill', '#475569');
        text.textContent = m;
        svg.appendChild(text);

        rect.addEventListener('mousemove', (ev) => {
          tooltip.style.display = 'block';
          tooltip.style.left = ev.clientX + 'px';
          tooltip.style.top = (ev.clientY - 12) + 'px';
          tooltip.innerHTML = `${m} â€¢ ${counts[m]} loans`;
        });
        rect.addEventListener('mouseleave', () => tooltip.style.display = 'none');
      });

      // current month marker on the right edge (visual cue)
      const curLine = document.createElementNS(svgNS, 'line');
      curLine.setAttribute('x1', pad + (w - pad * 2));
      curLine.setAttribute('x2', pad + (w - pad * 2));
      curLine.setAttribute('y1', pad);
      curLine.setAttribute('y2', h - pad);
      curLine.setAttribute('stroke', '#111827');
      curLine.setAttribute('stroke-dasharray', '3 4');
      curLine.setAttribute('stroke-opacity', '0.3');
      svg.appendChild(curLine);

      drawerChartArea.appendChild(svg);

      // table listing loans
      drawerExtra.innerHTML = `
        <div style="margin-top:10px">
          <strong class="small">Loans</strong>
          <div style="max-height:220px; overflow:auto; margin-top:6px; border-radius:6px; padding:6px; border:1px solid var(--border);background:var(--card)">
            <table style="width:100%; font-size:13px">
              <thead>
                <tr><th>Loan</th><th>Purchase</th><th>Rate</th><th style="text-align:right">Balance</th></tr>
              </thead>
              <tbody>
                ${allLoans.map(l => `<tr>
                  <td style="text-align:left">Loan ${l.loanId}</td>
                  <td style="text-align:left">${l.purchaseDate}</td>
                  <td style="text-align:left">${(l.nominalRate * 100).toFixed(2)}%</td>
                  <td style="text-align:right">$${l.purchasePrice.toLocaleString()}</td>
                </tr>`).join('')}
              </tbody>
            </table>
          </div>
        </div>
      `;

      drawer.classList.add('open');
      drawer.setAttribute('aria-hidden', 'false');
      drawerBody.scrollTop = 0;
    }

function renderTPVDrawer() {
  currentMode = 'kpi';
  currentLoan = null;

  drawerTitle.textContent = 'Total Portfolio Value';
  drawerSub.textContent = 'Purchase + accrued interest (grace) + cumulative payments';

  drawerPrimaryTitle.textContent = 'Current TPV';
  const curMonthIdx = getCurrentMonthIndex(allLoans);
  const curVal = tpvSeriesData[Math.min(curMonthIdx - 1, tpvSeriesData.length - 1)].value;
  drawerPrimary.textContent = `$${Math.round(curVal).toLocaleString()}`;

  drawerSecondaryTitle.textContent = 'Total Invested';
  drawerSecondary.textContent =
    `$${allLoans.reduce((s, l) => s + l.purchasePrice, 0).toLocaleString()}`;

  drawerAmortContainer.style.display = 'none';
  drawerExtra.innerHTML = '';
  drawerChartArea.innerHTML = '';
  drawerLegend.style.display = 'none';

  /* ============================
     SVG + scale
  ============================ */
  const svgNS = 'http://www.w3.org/2000/svg';
  const w = 480, h = 220, pad = 30;
  const svg = document.createElementNS(svgNS, 'svg');
  svg.setAttribute('viewBox', `0 0 ${w} ${h}`);
  svg.setAttribute('width', '100%');
  svg.setAttribute('height', '100%');

  const vals = tpvSeriesData.map(d => d.value);
  const maxV = Math.max(...vals);
  const minV = Math.min(...vals);
  const range = Math.max(1, maxV - minV);
  const stepX = (w - pad * 2) / Math.max(1, tpvSeriesData.length - 1);

  /* ============================
     Line
  ============================ */
  let pts = '';
  tpvSeriesData.forEach((d, i) => {
    const x = pad + i * stepX;
    const y = pad + (h - pad * 2) -
      ((d.value - minV) / range) * (h - pad * 2);
    pts += `${x},${y} `;
  });

  const poly = document.createElementNS(svgNS, 'polyline');
  poly.setAttribute('points', pts);
  poly.setAttribute('fill', 'none');
  poly.setAttribute('stroke', '#0ea5e9');
  poly.setAttribute('stroke-width', '2');
  svg.appendChild(poly);

  /* ============================
     Hover visuals
  ============================ */
  const hoverLine = document.createElementNS(svgNS, 'line');
  hoverLine.setAttribute('stroke', '#111827');
  hoverLine.setAttribute('stroke-width', '1');
  hoverLine.setAttribute('stroke-dasharray', '3 4');
  hoverLine.setAttribute('y1', pad);
  hoverLine.setAttribute('y2', h - pad);
  hoverLine.style.opacity = '0';
  hoverLine.style.pointerEvents = 'none';
  svg.appendChild(hoverLine);

  const hoverDot = document.createElementNS(svgNS, 'circle');
  hoverDot.setAttribute('r', '4');
  hoverDot.setAttribute('fill', '#0ea5e9');
  hoverDot.setAttribute('stroke', '#fff');
  hoverDot.setAttribute('stroke-width', '1.2');
  hoverDot.style.opacity = '0';
  hoverDot.style.pointerEvents = 'none';
  svg.appendChild(hoverDot);

  function hideTPVHover() {
    hoverLine.style.opacity = '0';
    hoverDot.style.opacity = '0';
    tooltip.style.display = 'none';
  }

  /* ============================
     X-axis labels
  ============================ */
  const earliest = new Date(
    Math.min(...allLoans.map(l =>
      new Date(l.purchaseDate + 'T00:00:00').getTime()
    ))
  );

  const labelCount = 6;
  const skip = Math.max(1, Math.floor(tpvSeriesData.length / labelCount));

  for (let i = 0; i < tpvSeriesData.length; i += skip) {
    const x = pad + i * stepX;
    const d = new Date(earliest);
    d.setMonth(d.getMonth() + i);

    const text = document.createElementNS(svgNS, 'text');
    text.setAttribute('x', x);
    text.setAttribute('y', h - pad + 14);
    text.setAttribute('font-size', '11');
    text.setAttribute('text-anchor', 'middle');
    text.setAttribute('fill', '#475569');
    text.textContent = d.toLocaleDateString(undefined, {
      month: 'short',
      year: 'numeric'
    });
    svg.appendChild(text);
  }

  /* ============================
     Current month marker
  ============================ */
  const curIdx = Math.min(curMonthIdx - 1, tpvSeriesData.length - 1);
  const curX = pad + curIdx * stepX;
  const curLine = document.createElementNS(svgNS, 'line');
  curLine.setAttribute('x1', curX);
  curLine.setAttribute('x2', curX);
  curLine.setAttribute('y1', pad);
  curLine.setAttribute('y2', h - pad);
  curLine.setAttribute('stroke', '#111827');
  curLine.setAttribute('stroke-dasharray', '3 4');
  curLine.setAttribute('stroke-opacity', '0.6');
  svg.appendChild(curLine);

  /* ============================
     Hover hit rects
  ============================ */
  tpvSeriesData.forEach((d, i) => {
    const hit = document.createElementNS(svgNS, 'rect');
    hit.setAttribute('x', pad + i * stepX - stepX / 2);
    hit.setAttribute('y', pad);
    hit.setAttribute('width', Math.max(1, stepX));
    hit.setAttribute('height', h - pad * 2);
    hit.setAttribute('fill', 'transparent');

    hit.addEventListener('mousemove', (ev) => {
      const x = pad + i * stepX;
      const y =
        pad + (h - pad * 2) -
        ((d.value - minV) / range) * (h - pad * 2);

      hoverLine.setAttribute('x1', x);
      hoverLine.setAttribute('x2', x);
      hoverDot.setAttribute('cx', x);
      hoverDot.setAttribute('cy', y);

      hoverLine.style.opacity = '0.6';
      hoverDot.style.opacity = '1';

      const hoverDate = new Date(earliest);
      hoverDate.setMonth(hoverDate.getMonth() + (d.month - 1));

      tooltip.style.display = 'block';
      tooltip.style.left = ev.clientX + 'px';
      tooltip.style.top = (ev.clientY - 12) + 'px';
      tooltip.innerHTML =
        `${hoverDate.toLocaleDateString(undefined, {
          month: 'short',
          year: 'numeric'
        })} â€¢ TPV $${Math.round(d.value).toLocaleString()}`;
    });

    hit.addEventListener('mouseleave', hideTPVHover);
    svg.appendChild(hit);
  });

  svg.addEventListener('mouseleave', hideTPVHover);
  drawerChartArea.addEventListener('mouseleave', hideTPVHover);

  drawerChartArea.appendChild(svg);

  /* ============================
     Snapshot table (unchanged)
  ============================ */
  drawerExtra.innerHTML = `
  <strong class="small">TPV Snapshot</strong>
  <div style="max-height:45vh;overflow:auto;margin-top:6px;
        border-radius:6px;padding:6px;
        border:1px solid var(--border);background:var(--card)">
    <table style="width:100%;font-size:13px">
      <thead>
        <tr>
          <th>Date</th>
          <th style="text-align:right">TPV</th>
        </tr>
      </thead>
      <tbody>
        ${(() => {
          // Portfolio started
          const earliestTs = Math.min(
            ...allLoans.map(l =>
              new Date(l.purchaseDate + "T00:00:00").getTime()
            )
          );
          const startDate = new Date(earliestTs);
          const startTPV = Math.round(tpvSeriesData[0].value);

          // Current TPV
          const today = new Date();
          const monthsSinceStart =
            (today.getFullYear() - startDate.getFullYear()) * 12 +
            (today.getMonth() - startDate.getMonth());
          const curIdx = Math.max(
            0,
            Math.min(monthsSinceStart, tpvSeriesData.length - 1)
          );
          const currentTPV = Math.round(tpvSeriesData[curIdx].value);

          // Projected end
          const projectedEndTPV = Math.round(
            tpvSeriesData[tpvSeriesData.length - 1].value
          );
          const projectedEndDate = (() => {
            const maxTs = Math.max(...allLoans.map(l => {
              const d = new Date(l.purchaseDate + "T00:00:00");
              const lastIdx = l.amort.schedule[l.amort.schedule.length - 1].monthIndex;
              d.setMonth(d.getMonth() + (lastIdx - 1));
              return d.getTime();
            }));
            return new Date(maxTs);
          })();

          return `
            <tr>
              <td>Portfolio Started<br>
                <span style="color:var(--muted)">${startDate.toLocaleDateString()}</span>
              </td>
              <td style="text-align:right">$${startTPV.toLocaleString()}</td>
            </tr>

            <tr>
              <td>Current TPV<br>
                <span style="color:var(--muted)">${today.toLocaleDateString()}</span>
              </td>
              <td style="text-align:right">$${currentTPV.toLocaleString()}</td>
            </tr>

            <tr>
              <td>Projected End Date<br>
                <span style="color:var(--muted)">${projectedEndDate.toLocaleDateString()}</span>
              </td>
              <td style="text-align:right">$${projectedEndTPV.toLocaleString()}</td>
            </tr>
          `;
        })()}
      </tbody>
    </table>
  </div>
`;

  drawer.classList.add('open');
  drawer.setAttribute('aria-hidden', 'false');
  drawerBody.scrollTop = 0;
}


    function renderRatesDrawer() {
      currentMode = 'kpi';
      currentLoan = null;

      drawerTitle.textContent = 'Rates Distribution';
      drawerSub.textContent = 'Histogram of loan nominal rates';
      const rates = allLoans.map(l => l.nominalRate * 100);
      const minRate = Math.min(...rates);
      const maxRate = Math.max(...rates);

      drawerPrimaryTitle.textContent = 'Avg Rate';
      drawerPrimary.textContent = `${(cachedKPIs.weightedRate * 100).toFixed(2)}%`;

      drawerSecondaryTitle.textContent = 'Rate Range';
      drawerSecondary.textContent = `${minRate.toFixed(2)}% â€“ ${maxRate.toFixed(2)}%`;

      drawerAmortContainer.style.display = 'none';
      drawerExtra.innerHTML = '';
      drawerChartArea.innerHTML = '';
      drawerLegend.style.display = 'none';

      // histogram
      const min = minRate;
      const max = maxRate;
      const bins = 5;
      const width = (max - min) / bins || 1;
      const counts = new Array(bins).fill(0);
      rates.forEach(r => {
        let idx = Math.floor((r - min) / Math.max(0.0001, width));
        if (idx >= bins) idx = bins - 1;
        counts[idx]++;
      });

      const svgNS = 'http://www.w3.org/2000/svg';
      const w = 480, h = 220, pad = 30;
      const svg = document.createElementNS(svgNS, 'svg');
      svg.setAttribute('viewBox', `0 0 ${w} ${h}`);
      svg.setAttribute('width', '100%');
      svg.setAttribute('height', '100%');

      const maxC = Math.max(...counts, 1);
      for (let i = 0; i < bins; i++) {
        const barW = (w - pad * 2) / bins * 0.7;
        const gap = ((w - pad * 2) / bins - barW) / 2;
        const x = pad + i * ((w - pad * 2) / bins) + gap;
        const barH = (counts[i] / maxC) * (h - pad * 2);
        const y = h - pad - barH;

        const rect = document.createElementNS(svgNS, 'rect');
        rect.setAttribute('x', x);
        rect.setAttribute('y', y);
        rect.setAttribute('width', barW);
        rect.setAttribute('height', barH);
        rect.setAttribute('fill', '#7c3aed');
        svg.appendChild(rect);

        const label = `${(min + i * width).toFixed(2)}-${(min + (i + 1) * width).toFixed(2)}`;
        const text = document.createElementNS(svgNS, 'text');
        text.setAttribute('x', x + barW / 2);
        text.setAttribute('y', h - pad + 14);
        text.setAttribute('font-size', '11');
        text.setAttribute('text-anchor', 'middle');
        text.setAttribute('fill', '#475569');
        text.textContent = label;
        svg.appendChild(text);

        rect.addEventListener('mousemove', (ev) => {
          tooltip.style.display = 'block';
          tooltip.style.left = ev.clientX + 'px';
          tooltip.style.top = (ev.clientY - 12) + 'px';
          tooltip.innerHTML = `${counts[i]} loans (${label}%)`;
        });
        rect.addEventListener('mouseleave', () => tooltip.style.display = 'none');
      }

      drawerChartArea.appendChild(svg);

      // table sorted by rate
      const sorted = allLoans.slice().sort((a, b) => b.nominalRate - a.nominalRate);
      drawerExtra.innerHTML = `
        <div style="margin-top:10px">
          <strong class="small">Loans sorted by rate</strong>
          <div style="max-height:45vh;overflow:auto;margin-top:6px;border-radius:6px;padding:6px;border:1px solid var(--border);background:var(--card)">
            <table style="width:100%;font-size:13px">
              <thead>
                <tr>
                  <th>Loan</th>
                  <th>Rate</th>
                  <th>Purchase</th>
                  <th style="text-align:right">Balance</th>
                </tr>
              </thead>
              <tbody>
                ${sorted.map(l => `
                <tr
                data-loan-id="${l.loanId}"
                style="--loan-color:${window.KPI_COLOR_MAP?.[l.loanId] || 'var(--text)'}"
                  >
                  <td>
                    <span style="
                     display:inline-block;
                    width:10px;
                    height:10px;
                    border-radius:2px;
                    background:var(--loan-color);
                    margin-right:6px;
                   vertical-align:middle;
                  "></span>
                  ${l.loanName}
                  </td>
                  <td style="text-align:left">${(l.nominalRate * 100).toFixed(2)}%</td>
                  <td style="text-align:left">${l.purchaseDate}</td>
                  <td style="text-align:right">$${l.purchasePrice.toLocaleString()}</td>
                </tr>`).join('')}
              </tbody>
            </table>
          </div>
        </div>
      `;

      drawer.classList.add('open');
      drawer.setAttribute('aria-hidden', 'false');
      drawerBody.scrollTop = 0;
    }

    function renderPaymentsDrawer() {
      currentMode = 'kpi';
      currentLoan = null;

      drawerTitle.textContent = 'Total Expected Payments (monthly)';
      drawerSub.textContent = 'Sum of scheduled payments across loans';
      drawerPrimaryTitle.textContent = 'Monthly Income';
      drawerPrimary.textContent = `$${Math.round(cachedKPIs.monthlyIncome).toLocaleString()}`;
      drawerSecondaryTitle.textContent = 'Total Invested';
      drawerSecondary.textContent =
      `$${allLoans.reduce((s,l) => s + l.purchasePrice, 0).toLocaleString()}`;

      drawerAmortContainer.style.display = 'none';
      drawerExtra.innerHTML = '';

      // Build months from earliest purchase to last schedule end
      const monthIndex = d => new Date(d + 'T00:00:00').getTime();
      const minDate = Math.min(...allLoans.map(l => monthIndex(l.purchaseDate)));
      const maxDate = Math.max(...allLoans.map(l => {
        const lastMonth = l.amort.schedule[l.amort.schedule.length - 1].monthIndex;
        const pd = new Date(l.purchaseDate + 'T00:00:00');
        pd.setMonth(pd.getMonth() + lastMonth);
        return pd.getTime();
      }));

      const months = [];

      const cursor = new Date(minDate);
      cursor.setDate(1);
      while (cursor.getTime() <= maxDate) {
        months.push(new Date(cursor.getTime()).toISOString().slice(0, 7));
        cursor.setMonth(cursor.getMonth() + 1);
      }

      // ---- Compute today's month index *after* months[] is built ----
      const today = new Date();
      today.setDate(1); // align to month start
      const todayStr = today.toISOString().slice(0, 7);

      let todayIndex = months.indexOf(todayStr);
      if (todayIndex === -1) {
        // clamp to range if today is outside series
        const first = new Date(months[0] + '-01T00:00:00');
        const last = new Date(months[months.length - 1] + '-01T00:00:00');
        todayIndex = today < first ? 0 : months.length - 1;
      }


      // compute total payments by month
      const paymentsByMonth = months.map(m => {
        return allLoans.reduce((s, l) => {
          const pd = new Date(l.purchaseDate + 'T00:00:00');
          const ym = m.split('-');
          const md = new Date(parseInt(ym[0]), parseInt(ym[1]) - 1, 1);
          const monthsSince = (md.getFullYear() - pd.getFullYear()) * 12 + (md.getMonth() - pd.getMonth());
          // compute index of this month relative to purchase date
          const idx = monthsSince;

          // If the loan has not started â†’ no payment
          if (idx < 0) return s;

          // If the loan is already finished â†’ no payment
          if (idx >= l.amort.schedule.length) return s;

          // Otherwise use the correct amortization row
          const entry = l.amort.schedule[idx];
           s += entry.payment;
          return s;

        }, 0);
      });

      // timeseries chart
      drawerChartArea.innerHTML = '';
      drawerLegend.style.display = 'none';
      const svgNS = 'http://www.w3.org/2000/svg';
      const w = 480, h = 220, pad = 30;
      const svg = document.createElementNS(svgNS, 'svg');
      svg.setAttribute('viewBox', `0 0 ${w} ${h}`);
      svg.setAttribute('width', '100%');
      svg.setAttribute('height', '100%');

      const maxPay = Math.max(...paymentsByMonth);
      const minPay = Math.min(...paymentsByMonth);
      const range = Math.max(1, maxPay - minPay);
      const stepX = (w - pad * 2) / Math.max(1, months.length - 1);

      let pts = '';
      paymentsByMonth.forEach((p, i) => {
        const x = pad + i * stepX;
        const y = pad + (h - pad * 2) - ((p - minPay) / range) * (h - pad * 2);
        pts += `${x},${y} `;
      });

      const poly = document.createElementNS(svgNS, 'polyline');
      poly.setAttribute('points', pts);
      poly.setAttribute('fill', 'none');
      poly.setAttribute('stroke', '#fb7185');
      poly.setAttribute('stroke-width', '2');
      svg.appendChild(poly);

      // ---- Today Vertical Line ----
const todayX = pad + todayIndex * stepX;

const vLine = document.createElementNS(svgNS, 'line');
vLine.setAttribute('x1', todayX);
vLine.setAttribute('x2', todayX);
vLine.setAttribute('y1', pad);
vLine.setAttribute('y2', h - pad);
vLine.setAttribute('stroke', '#111827');
vLine.setAttribute('stroke-dasharray', '3 3');
vLine.setAttribute('stroke-opacity', '0.6');

svg.appendChild(vLine);


// ----- Hover Interaction (correct) -----
const hoverLine = document.createElementNS(svgNS, 'line');
hoverLine.setAttribute('stroke', '#64748b');
hoverLine.setAttribute('stroke-dasharray', '3 3');
hoverLine.setAttribute('stroke-width', '1');
hoverLine.style.opacity = 0;
svg.appendChild(hoverLine);

const hoverDot = document.createElementNS(svgNS, 'circle');
hoverDot.setAttribute('r', 4);
hoverDot.setAttribute('fill', '#fb7185');
hoverDot.setAttribute('stroke', '#fff');
hoverDot.setAttribute('stroke-width', '1.2');
hoverDot.style.opacity = 0;
svg.appendChild(hoverDot);

svg.addEventListener('mousemove', (ev) => {
  const rect = svg.getBoundingClientRect();
  const mouseX = ev.clientX - rect.left;
  let idx = Math.round((mouseX - pad) / stepX);

  idx = Math.max(0, Math.min(months.length - 1, idx));

  const x = pad + idx * stepX;
  const y = pad + (h - pad * 2) - ((paymentsByMonth[idx] - minPay) / range) * (h - pad * 2);

  // Show line + dot
  hoverLine.setAttribute('x1', x);
  hoverLine.setAttribute('x2', x);
  hoverLine.setAttribute('y1', pad);
  hoverLine.setAttribute('y2', h - pad);
  hoverLine.style.opacity = 1;

  hoverDot.setAttribute('cx', x);
  hoverDot.setAttribute('cy', y);
  hoverDot.style.opacity = 1;

  // Tooltip: YYYY-MM â€¢ $N
  tooltip.style.display = 'block';
  tooltip.style.left = ev.clientX + 'px';
  tooltip.style.top = (ev.clientY - 12) + 'px';
  tooltip.innerHTML =
    `${months[idx]} â€¢ $${Math.round(paymentsByMonth[idx]).toLocaleString()}`;
});

svg.addEventListener('mouseleave', () => {
  hoverLine.style.opacity = 0;
  hoverDot.style.opacity = 0;
  tooltip.style.display = 'none';
});

      
      // ---- Sparse X-Axis Labels (cleaned) ----
const labelCount = 6;
const skip = Math.max(1, Math.floor(months.length / labelCount));

for (let i = 0; i < months.length; i += skip) {
  const x = pad + i * stepX;

  const text = document.createElementNS(svgNS, 'text');
  text.setAttribute('x', x);
  text.setAttribute('y', h - pad + 14);
  text.setAttribute('font-size', '11');
  text.setAttribute('text-anchor', 'middle');
  text.setAttribute('fill', '#475569');

  // show YYYY-MM
  text.textContent = months[i];

  svg.appendChild(text);
}

      drawerChartArea.appendChild(svg);

      drawerExtra.innerHTML = `
        <div style="margin-top:10px">
          <strong class="small">Monthly expected payments</strong>
          <div style="max-height:220px;overflow:auto;margin-top:6px;border-radius:6px;padding:6px;border:1px solid var(--border);background:var(--card)">
            <table style="width:100%;font-size:13px">
              <thead><tr><th>Month</th><th style="text-align:right">Payments</th></tr></thead>
              <tbody>
                ${months.map((m, i) => `<tr><td style="text-align:left">${m}</td><td style="text-align:right">$${Math.round(paymentsByMonth[i]).toLocaleString()}</td></tr>`).join('')}
              </tbody>
            </table>
          </div>
        </div>
      `;

      drawer.classList.add('open');
      drawer.setAttribute('aria-hidden', 'false');
      drawerBody.scrollTop = 0;
    }

    /* ============================
       CSV / copy / download / print
       ============================ */
    function amortToCSV(loan) {
      const rows = [['Month', 'Payment', 'Principal', 'Interest', 'Balance']];
      loan.amort.schedule.forEach(r =>
        rows.push([r.monthIndex, r.payment.toFixed(2), r.principalPaid.toFixed(2), r.interest.toFixed(2), r.balance.toFixed(2)])
      );
      return rows.map(r => r.join(',')).join('\n');
    }

    document.getElementById('copyCsvBtn')?.addEventListener('click', async () => {
      if (currentMode !== 'loan' || !currentLoan) return alert('Open an individual loan drawer to copy CSV');
      const csv = amortToCSV(currentLoan);
      try { await navigator.clipboard.writeText(csv); alert('CSV copied to clipboard'); }
      catch (e) { alert('Copy failed â€” browser denied clipboard access'); }
    });

    document.getElementById('downloadCsvBtn')?.addEventListener('click', () => {
      if (currentMode === 'loan' && currentLoan) {
        const csv = amortToCSV(currentLoan);
        const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a'); a.href = url; a.download = `loan-${currentLoan.loanId}-amort.csv`;
        document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
      } else {
        alert('Download CSV is supported for individual loan drawers only.');
      }
    });

    document.getElementById('printBtn')?.addEventListener('click', () => window.print());

    // Accessibility tweak: hide tooltip when grid scrolls
    document.querySelector('.grid').addEventListener('scroll', () => tooltip.style.display = 'none');

    /* ============================
       Click outside to close drawer
       - If drawer is open, close it when user clicks anywhere that's
         not inside the drawer AND not on another tile.
       - Important: tile clicks call stopPropagation so the tile's click
         will open drawer and not cause immediate close.
       ============================ */
    document.addEventListener('click', function (e) {
      if (!drawer.classList.contains('open')) return;

      const clickedInsideDrawer = drawer.contains(e.target);
      const clickedTile = !!e.target.closest('.tile'); // matches all tiles

      // If the click is outside both drawer and tiles â†’ close
      if (!clickedInsideDrawer && !clickedTile) {
        closeDrawer();
      }
    });

    /* ============================
       Theme toggle (matches ROI)
       ============================ */
    const themeToggleBtn = document.getElementById('themeToggle');
    const root = document.documentElement;

    function setTheme(mode) {
      root.setAttribute('data-theme', mode);
      if (mode === 'dark') {
        themeToggleBtn.textContent = 'â˜€ï¸';
      } else {
        themeToggleBtn.textContent = 'ðŸŒ™';
      }
      try { localStorage.setItem('amortTheme', mode); } catch (e) {}
    }

    const stored = (() => { try { return localStorage.getItem('amortTheme'); } catch (e) { return null; } })();
    if (stored === 'dark' || (!stored && window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches)) {
      setTheme('dark');
    } else {
      setTheme('light');
    }

    themeToggleBtn.addEventListener('click', () => {
      const current = root.getAttribute('data-theme') === 'dark' ? 'dark' : 'light';
      setTheme(current === 'dark' ? 'light' : 'dark');
    });

}
  // Set Current Date in header
const currentDateEl = document.getElementById('currentDateLabel');
if (currentDateEl) {
  const today = new Date();
  const formatted = today.toLocaleDateString(undefined, {
    year: 'numeric',
    month: 'long',
    day: 'numeric'
  });
  currentDateEl.textContent = `Current Date: ${formatted}`;
}

    init();   // The ONLY startup call
  </script>
</body>
</html><!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Loan Portfolio â€” Earnings</title>

  <style>
   :root {
    --bg:#f0f4f8;
    --surface:#f1f5f9;
    --card:#ffffff;
    --text:#0f172a;
    --muted:#64748b;
    --border:#e2e8f0;
    --shadow:rgba(0,0,0,0.08);

    --brand:#0ea5e9;
    --brand-strong:#0284c7;

    --accent1:#7c3aed;
    --accent2:#0ea5e9;
    --accent3:#14b8a6;
    --accent4:#f97316;
    --accent5:#ef4444;

    --stat-bg:#f8fafc;
    --stat-border:#e2e8f0;

    --grad-top:var(--surface);
    --grad-bottom:var(--card);

    --font-smooth:antialiased;

    --tile-bg:var(--card);
    --tile-hover-bg:#f8fafc;

    --drawer-bg:var(--card);
    --drawer-shadow:rgba(0,0,0,0.10);

    --grid-strong: #cbd5e1;
    --grid-light: #e2e8f0;
    --table-header: var(--surface);
    }



 html[data-theme="dark"] {
  color-scheme: dark;

  --bg:#0b1220;
  --surface:#1e293b;
  --card:#1e293b;

  --text:#e6eef8;
  --muted:#9aa6b2;
  --border:#334155;

  --shadow:0 12px 30px rgba(2,6,23,0.6);

  --grad-top:#071829;
  --grad-bottom:#0b1220;

  --tile-bg:#1e293b;
  --tile-hover-bg:#243447;
  --drawer-bg: var(--card);
  --drawer-shadow:rgba(2,6,23,0.55);

  --grid-strong:#334155;
  --grid-light:#1e293b;

  --table-header:#0f172a;
}


    html, body {
    height:100%;
    margin:0;
    font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, Arial;
    color: var(--text);
    -webkit-font-smoothing: antialiased;
    }


   body {
    background: linear-gradient(180deg, var(--grad-top) 0%, var(--grad-bottom) 100%);
    background-color: var(--bg);
    -webkit-font-smoothing: var(--font-smooth);
    transition: background-color .25s ease, color .25s ease;
    }


   .app{
    max-width:1200px;
    margin:20px auto 0 auto;
    padding:16px 16px 0 16px;
    transition:color .25s ease;
    }

    /* MATCH AMORT HEADER SPACING */
   header {
    display:flex;
    flex-direction:column;
    gap:8px;
    margin-bottom:8px;     /* match amort */
    padding:0;
    transition:color .25s ease;
    }

    body > .app {
    background: transparent;
    padding-top:16px;
    margin-top:0;
    }

    
   header{
    display:flex;
    flex-direction:column;
    gap:8px;
    margin-bottom:8px;
    padding:0;
    transition:color .25s ease;
    }


    .header-top{
      display:flex;
      align-items:center;
      justify-content:space-between;
    }

  .header-controls {
    display:flex;
    gap:10px;
    align-items:center;
    }


    h1 {
      font-size:20px;
      margin:0;
    }

    .lead {
    margin: 4px 0 0 0;
    font-size: 13px;
    color: var(--muted);
    }

     p.lead {
      margin: 0px 0;
      color: var(--muted);
      font-size: 13px;
    }

    .current-date {
      font-size:13px;
      color:var(--muted);
      margin-top:4px;
    }

    .actions { display:flex; gap:8px; align-items:center }
    .btn{
      padding:8px 12px;
      border-radius:8px;
      border:1px solid var(--border);
      background:var(--card);
      cursor:pointer;
      font-weight:600;
      color:var(--text);
      transition:background-color .25s ease, color .25s ease, border-color .25s ease, box-shadow .25s ease;
    }
    .btn.primary{
      background:linear-gradient(90deg,var(--brand),var(--accent2));
      color:white;
      border:none;
      box-shadow:var(--shadow);
    }
    .close-btn{
      background:var(--card-muted);
      border:1px solid var(--border);
      padding:8px;
      border-radius:8px;
      cursor:pointer;
      color:var(--text);
      transition:background-color .25s ease, color .25s ease, border-color .25s ease, box-shadow .25s ease;
    }

    /* Fix KPI vertical alignment to match amort */
.kpis {
  display:grid;
  grid-template-columns:repeat(4,1fr);
  gap:12px;
  margin:14px 0 18px;   /* match amort */
}

.kpi {
  background:var(--card);
  padding:12px;         /* match amort */
  border-radius:10px;   /* match amort */
  box-shadow:var(--shadow);
  border:1px solid var(--border);
  cursor:pointer;
  transition: transform .18s, box-shadow .18s,
              background-color .25s ease,
              color .25s ease, border-color .25s ease;
}

.kpi:hover {
  transform: translateY(-2px);    /* match amort */
  box-shadow: 0 6px 16px rgba(0,0,0,0.15);
}

.kpi h3 {
  margin:0;
  font-size:12px;
  color:var(--muted);
}

.kpi p {
  margin:8px 0 0;
  font-size:18px;
  font-weight:700;
}


    .grid{
      display:grid;
      grid-template-columns:repeat(2,1fr);
      gap:12px;
      height:calc(100vh - 320px);
      overflow:auto;
      padding-right:6px;
    }
    @media(max-width:900px){
      .grid{ grid-template-columns:1fr; height:auto; }
      .kpis{ grid-template-columns:repeat(2,1fr); }
    }

/* --- Unified Loan Tile Style (matches Amort exactly) --- */

.tile {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 10px 12px;
  border-radius: 12px;
  background: var(--card);
  min-height: 110px;
  cursor: pointer;
  overflow: hidden;
  border: 1px solid var(--border);
  transition: transform .18s ease, box-shadow .24s ease, background .28s ease;
}

.tile:hover {
  transform: translateY(-3px);
  box-shadow: var(--shadow);
}

/* left side */
.tile-left {
  flex: 1;
  padding-right: 10px;
}

.loan-name {
  font-weight: 600;
  font-size: 13px;
}

.loan-sub {
  font-size: 12px;
  color: var(--muted);
  margin-top: 6px;
}

.loan-meta {
  display: flex;
  gap: 8px;
  font-size: 12px;
  color: var(--muted);
  margin-top: 8px;
}
    .chart-wrap{
      width:170px;
      flex-shrink:0;
      display:flex;
      flex-direction:column;
      align-items:flex-end;
    }
    .mini-label{
      font-size:12px;
      color:var(--muted);
      margin-bottom:6px;
      text-align:right;
      width:100%;
    }

/* ============================================================
   AMORT-STYLE DRAWER FOR EARNINGS (WIDE VERSION)
   ============================================================ */

/* Base Drawer */
.drawer {
  position: fixed;
  right: 0;
  top: 0;
  height: 100vh;

  /* *** KEEP WIDE DRAWER *** */
  width: 760px;
  max-width: 1000px;

  background: var(--card);
  box-shadow: -28px 0 80px rgba(2,6,23,0.14);
  transform: translateX(110%);
  transition:
    transform .28s cubic-bezier(.2,.9,.3,1),
    background-color .25s ease,
    color .25s ease,
    border-color .25s ease,
    box-shadow .25s ease;
  z-index: 120;
  overflow: hidden;
  padding: 0;
  border-left: 1px solid var(--border);
  display: flex;
  flex-direction: column;
  opacity: 0;
}

.drawer.open {
  transform: translateX(0);
  opacity: 1;
  animation: drawerIn .28s cubic-bezier(.2,.9,.3,1);
}

@keyframes drawerIn {
  from { transform: translateX(30%); opacity: 0; }
  to   { transform: translateX(0);   opacity: 1; }
}

/* Drawer Header */
.drawer-header {
  padding: 20px;
  flex-shrink: 0;
  background: var(--card);
  transition: background-color .25s ease, color .25s ease;
}

.drawer-head {
  display: flex;
  align-items: start;
  justify-content: space-between;
  gap: 8px;
}

.drawer h2 {
  margin: 0 0 6px;
  font-size: 20px;
  font-weight: 600;
}

.muted {
  color: var(--muted);
  font-size: 13px;
  margin-bottom: 10px;
}

/* Close Button */
.close-btn {
  background: #f1f5f9;
  border: none;
  padding: 8px;
  border-radius: 8px;
  cursor: pointer;
  transition: background-color .25s ease, color .25s ease;
}

html[data-theme="dark"] .close-btn {
  background: #0f172a;
  color: var(--text);
}

/* Drawer Body */
.drawer-body,
#drawerBody {
  flex: 1 1 auto;
  overflow-y: auto;
  overflow-x: hidden !important;
  padding: 0 20px 20px;
  display: flex;
  flex-direction: column;
  gap: 20px;
}

/* Drawer Chart */
.drawer-chart {
  height: 240px; /* Slightly taller for stacked earnings */
  background: var(--chart-bg);
  border-radius: 8px;
  border: 1px solid rgba(15,23,42,0.03);
  display: flex;
  align-items: center;
  justify-content: center;
  margin-bottom: 8px;
  position: relative;
  padding: 8px;
  box-shadow: 0 6px 18px rgba(15,23,42,0.06);
  transition:
    background-color .25s ease,
    color .25s ease,
    border-color .25s ease,
    box-shadow .25s ease;
}

.drawer-chart svg {
  width: 100%;
  height: 100%;
}

.legend {
  display: flex;
  gap: 10px;
  font-size: 12px;
  align-items: center;
  margin-top: 6px;
}

.legend .item {
  display: flex;
  gap: 6px;
  align-items: center;
}

.legend .sw {
  width: 12px;
  height: 8px;
  border-radius: 2px;
}

/* Primary + Secondary Stat Boxes (matching amort) */
.stat-boxes,
.drawer-info-row {
  display: flex;
  gap: 12px;
  margin: 0 0 12px;
  align-items: center;
}

.info-card,
.stat-box {
  flex: 1;
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: 10px;
  padding: 12px;
  display: flex;
  flex-direction: column;
  justify-content: center;
  min-height: 56px;
  transition: background-color .25s ease, border-color .25s ease;
}

.info-card.small,
.stat-box.small {
  width: 160px;
}

.muted-small,
.stat-label {
  font-size: 12px;
  color: var(--muted);
  margin-bottom: 6px;
}

.main-val,
.stat-value {
  font-size: 18px;
  font-weight: 700;
}

/* Drawer Table */
.amort-wrap {
  border: 1px solid var(--border);
  border-radius: 8px;
  padding: 8px;
  max-height: 40vh;
  overflow: auto;
  background: var(--card);
  transition:
    background-color .25s ease,
    border-color .25s ease,
    color .25s ease;
}

/* ============================================
   FIX: Make earnings drawer tables match amort
   ============================================ */

.drawer table,
.drawer .amort-wrap table {
  font-size: 13px !important;        /* match amort */
}

.drawer thead th,
.drawer .amort-wrap thead th {
  font-size: 13px !important;        /* match amort */
  padding: 8px !important;           /* match amort */
}

.drawer td,
.drawer .amort-wrap td {
  font-size: 13px !important;        /* match amort */
  padding: 8px !important;           /* match amort */
  border-bottom: 1px dashed rgba(15,23,42,0.04);
}

html[data-theme="dark"] .drawer td {
  border-bottom: 1px dashed rgba(148,163,184,0.24);
}

    
.drawer table {
  width: 100%;
  border-collapse: collapse;
  margin-top: 10px;
}

thead th {
  position: sticky;
  top: 0;
  background: var(--card);
  padding: 8px;
  text-align: left;
  color: var(--muted);
  font-weight: 700;
  border-bottom: 1px solid var(--border);
}

td {
  padding: 8px;
  border-bottom: 1px dashed rgba(15,23,42,0.04);
  text-align: left;
  transition: color .25s ease, border-color .25s ease;
}

td:first-child,
th:first-child {
  text-align: left;
}

/* Footer */
.drawer-footer {
  padding: 20px;
  flex-shrink: 0;
  background: var(--card);
  transition: background-color .25s ease;
}

.actions {
  display: flex;
  gap: 8px;
}

/* Dark Mode Overrides (match amort) */
html[data-theme="dark"] .drawer {
  background: var(--drawer-bg);
  border-left: 1px solid var(--border);
  box-shadow: -28px 0 80px var(--drawer-shadow);
}

html[data-theme="dark"] .amort-wrap {
  background: var(--card);
}

html[data-theme="dark"] thead th {
  background: var(--surface);
  color: var(--text);
  border-bottom: 1px solid var(--border);
}

html[data-theme="dark"] td {
  border-bottom: 1px dashed rgba(148,163,184,0.24);
}

html[data-theme="dark"] .legend .sw {
  opacity: 0.9;
}

/* Mobile */
@media(max-width:760px) {
  .drawer {
    width: 100%;
    max-width: none;
  }
}


    /* Theme toggle */
    .theme-icon{
      background:var(--card);
      border:1px solid var(--border);
      font-size:18px;
      cursor:pointer;
      transition:background-color .25s ease, color .25s ease, border-color .25s ease, box-shadow .25s ease, transform .2s ease;
      width:38px;
      height:38px;
      border-radius:10px;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      box-shadow:var(--shadow);
    }
    .theme-icon:hover{ opacity:0.95; transform:translateY(-1px); }

    .lens-tooltip-html {
      position: fixed;
      z-index: 9999;
      pointer-events: none;
      background: rgba(0,0,0,0.85);     /* solid black like amort */
      color: #ffffff;                   /* white text */
      padding: 6px 10px;
      font-size: 12px;
      font-weight: 600;
      border-radius: 6px;
      border: 1px solid rgba(255,255,255,0.15);
      box-shadow: 0 6px 18px rgba(0,0,0,0.45);
      white-space: nowrap;
    }

/* KPI3 ONLY: force neutral text */
.kpi3-table td,
.kpi3-table td *,
.kpi3-table a {
  color: var(--text) !important;
}

/* KPI4 table: color text to match loan swatch */
.kpi4-table tbody tr td:nth-child(2),
.kpi4-table tbody tr td:nth-child(3),
.kpi4-table tbody tr td:nth-child(4),
.kpi4-table tbody tr td:nth-child(5) {
  color: inherit !important;
}

.kpi4-table tbody tr {
  color: var(--text);
}

.kpi4-table tbody tr[data-loan-id] {
  --loan-color: var(--text);
}

    .kpi4-table tbody tr[data-loan-id] {
  cursor: pointer;
}


.kpi4-table tbody tr[data-loan-id] td {
  color: var(--loan-color) !important;
}

    
    /* KPI4 table */
#drawerExtra table {
  width: 100%;
  border-collapse: collapse;
}

#drawerExtra th {
  color: var(--muted);
  font-weight: 600;
  text-align: left;
  padding: 8px;
}

#drawerExtra td {
  color: inherit;
  padding: 8px;
}


#drawerExtra tbody tr {
  transition: background 0.15s ease;
}

#drawerExtra tbody tr:hover {
  background: rgba(100, 116, 139, 0.15);
}


    
  </style>
</head>
<body>
  <div class="app" role="main">
<header>
  <div class="header-top">
    <div>
      <h1>Loan Portfolio â€” Earnings</h1>
      <p class="lead">Cumulative principal, interest, and fees, with stacked earnings visuals.</p>
    </div>

    <div class="header-controls">
      <div style="font-size:13px; color:var(--muted)">
        Name: <strong style="color:var(--brand)">Jeff Customer</strong>
      </div>
      <button id="themeToggle" class="theme-icon" title="Toggle dark mode">ðŸŒ™</button>
    </div>
  </div>
   <div class="current-date" id="currentDateLabel">
    Current Date: <span id="currentDate"></span>
  </div>
</header>



    <section class="kpis" id="kpis">
      <div class="kpi" data-kpi="net">
        <h3>Net Earnings to Date</h3>
        <p id="kpiNetToDate">--</p>
      </div>

      <div class="kpi" data-kpi="projected">
        <h3>Projected Lifetime Earnings</h3>
        <p id="kpiNetProj">--</p>
      </div>

      <div class="kpi" data-kpi="avgMonthly">
        <h3>Average Monthly Earnings To Date</h3>
        <p id="kpiAvgMonth">--</p>
      </div>

      <div class="kpi" data-kpi="fees">
        <h3>Projected Avg Monthly Earnings</h3>
        <p id="kpiFees">--</p>
      </div>
    </section>
    <section class="grid" id="loanGrid" aria-live="polite"></section>
  </div>

  <!-- Drawer -->
  <aside id="drawer" class="drawer" aria-hidden="true">
    <div class="drawer-header">
      <div class="drawer-head">
        <div>
          <h2 id="drawerTitle">Drawer</h2>
          <div class="muted" id="drawerSub">details</div>
        </div>

        <div style="display:flex;gap:8px;align-items:center">
          <button class="btn" id="downloadCsvBtn">Download CSV</button>
          <button class="close-btn" id="closeBtn" aria-label="Close drawer">âœ•</button>
        </div>
      </div>
    </div>

    <div id="drawerBody" class="drawer-body">
      <div class="drawer-chart" id="drawerChartArea"></div>
      <div class="legend" id="drawerLegend" style="display:none"></div>

      <div style="display:flex;gap:10px;margin-bottom:8px">
        <div style="flex:1;background:var(--surface);padding:10px;border-radius:8px;border:1px solid var(--border)">
          <div style="font-size:12px;color:var(--muted)" id="drawerPrimaryTitle">Purchase Price</div>
          <div id="drawerPrimary" style="font-weight:800;font-size:18px"></div>
        </div>
        <div style="width:120px;background:var(--surface);padding:10px;border-radius:8px;border:1px solid var(--border)">
          <div style="font-size:12px;color:var(--muted)" id="drawerSecondaryTitle">Rate</div>
          <div id="drawerSecondary" style="font-weight:800;font-size:16px"></div>
        </div>
      </div>

      <div id="drawerExtra"></div>

    <div class="drawer-footer">
      <div class="actions">
        <button class="btn" id="printBtn">Print</button>
        <button class="btn primary" id="copyCsvBtn">Copy CSV</button>
      </div>
    </div>
</aside>


  <!-- KPI Drawers -->
  <aside id="kpiDrawer1" class="drawer kpi-drawer" aria-hidden="true">
    <div class="drawer-head">
      <div>
        <h2 id="kpi1Title">KPI 1</h2>
        <div id="kpi1Sub" class="drawer-subtitle"></div>
      </div>
      <div style="display:flex;gap:8px;align-items:center">
        <button class="btn" id="downloadCsvBtn">Download CSV</button>
        <button class="close-btn kpi-close" data-kpi-close="kpiDrawer1" aria-label="Close KPI drawer">âœ•</button>
      </div>
    </div>
    <div class="drawer-info-row">
      <div class="info-card">
        <div class="muted-small" id="kpi1PrimaryTitle"></div>
        <div id="kpi1Primary" class="main-val"></div>
      </div>
      <div class="info-card small">
        <div class="muted-small" id="kpi1SecondaryTitle"></div>
        <div id="kpi1Secondary" class="main-val small"></div>
      </div>
    </div>
    <div class="drawer-body">
    </div>
    <div class="drawer-actions">
      <button class="btn" data-kpi-close="kpiDrawer1">Close</button>
      <div class="spacer"></div>
      <button class="btn primary">Export</button>
    </div>
    <div class="actions" style="padding-top:10px">
      <button class="btn" id="printBtn">Print</button>
      <button class="btn primary" id="copyCsvBtn">Copy CSV</button>
    </div>
  </aside>



  <script type="module">
    import {
      addMonths,
      monthDiff,
      formatDate,
      formatMonthYear,
      buildAmortSchedule,
      attachSchedules,
      buildPortfolioViews
    } from "../js/loanEngine.js";

    // --------------------------
    // Settings & base data
    // --------------------------
   
    function formatCurrency(value) {
  if (!Number.isFinite(value)) return "$0.00";
  return "$" + value.toLocaleString("en-US", {
    minimumFractionDigits: 2,
    maximumFractionDigits: 2
  });
}

    
    function OLD_addMonths(date, months) {
      const d = new Date(date);
      d.setMonth(d.getMonth() + months);
      return d;
    }

    function OLD_monthDiff(d1, d2) {
      return (d2.getFullYear() - d1.getFullYear()) * 12 +
             (d2.getMonth() - d1.getMonth());
    }

    let loans = [];
    let portfolioViews = null;

    async function loadLoansFromBackend() {
      try {
        const res = await fetch("https://loan-dashboard-api.jeff-263.workers.dev/loans");
        const data = await res.json();
        const arr = data.loans || [];
        loans = arr.map(l => ({
          ...l,
          loanStartDate: l.loanStartDate || "",
        }));
      } catch (err) {
        console.error("Failed to load loans from backend", err);
        loans = [];
      }
    }

    document.getElementById("currentDate").textContent = formatDate(new Date());

    let stackedBarGroupCounter = 0;

    function prepareStackedBar(bar, groupId, index, isPositive = true){
      bar.setAttribute("data-stack-group", groupId);
      bar.setAttribute("data-stack-index", index);
    }

    // --------------------------
    // Amortization + earnings
    // --------------------------
    function calcAmort(principal, annualRate, termYears, graceYears){
      const monthlyRate = annualRate / 12;
      const totalMonths = Math.round((termYears + graceYears) * 12);
      const graceMonths = Math.round(graceYears * 12);
      const repayMonths = Math.max(1, totalMonths - graceMonths);

      let balance = principal;
      const schedule = [];

      // Grace period: interest-only, interest accrues on balance
      for (let m = 1; m <= graceMonths; m++) {
        const interest = +(balance * monthlyRate).toFixed(2);
        balance = +(balance + interest).toFixed(2);
        schedule.push({
          monthIndex: m,
          payment: 0,
          principalPaid: 0,
          interest,
          balance
        });
      }

      // Repayment period: standard amortization
      const payment = monthlyRate === 0
        ? +(balance / repayMonths).toFixed(2)
        : +((balance * monthlyRate) / (1 - Math.pow(1 + monthlyRate, -repayMonths))).toFixed(2);

      for (let m = 1; m <= repayMonths; m++) {
        const interest = +(balance * monthlyRate).toFixed(2);
        const principalPaid = +Math.min(
          balance,
          +(payment - interest).toFixed(2)
        );
        balance = +(Math.max(0, balance - principalPaid).toFixed(2));

        schedule.push({
          monthIndex: graceMonths + m,
          payment: +payment.toFixed(2),
          principalPaid,
          interest,
          balance
        });
      }

      return { payment, schedule };
    }

    let loansWithEarnings = [];
    // Loans hidden via KPI1 table toggle
const hiddenLoans = new Set();


function rebuildLoansWithEarnings() {
  loansWithEarnings = loans.map((raw, idx) => {
    // Normalize fields from backend
    // Keep a NUMERIC internal id for charts/colors,
    // and a separate loanId that can be your random 10-char ID.
    const id = raw.id ?? (idx + 1);
    const loanId = raw.loanId ?? id;

    // Purchase price is what you paid (should NOT drive amort math)
const purchasePrice = Number(raw.purchasePrice ?? 0);

const balanceForAmort = Number(
  raw.balanceAtPurchase ??
  raw.principal ??
  raw.balance ??
  raw.originalBalance ??
  raw.faceValue ??
  purchasePrice
);

// Normalize rate and term inputs explicitly
const nominalRate = Number(
  raw.nominalRate ??
  raw.rate ??
  raw.interestRate ??
  0
);

const termYears = Number(
  raw.termYears ??
  raw.term ??
  raw.years ??
  0
);

const graceYears = Number(
  raw.graceYears ??
  raw.grace ??
  0
);

// Normalize fee inputs (restore legacy backend fields)
const upfrontFee = Number(
  raw.upfrontFee ??
  raw.upfront_fee ??
  raw.originationFee ??
  0
);

// Monthly servicing fee (legacy-compatible)
const monthlyFee = Number(
  raw.monthlyFee ??
  raw.monthlyServicingFee ??
  raw.servicingFee ??
  raw.fee ??
  0
);

// Month (ownership-based) when monthly fee begins
const monthlyFeeStart = Number(
  raw.monthlyFeeStart ??
  raw.feeStartMonth ??
  1
);


    
const normalizedLoan = {
  ...raw,
  loanId,
  id,
  loanName: raw.loanName ?? `Loan ${loanId}`,
  school: raw.school ?? "No school listed",
  loanStartDate: raw.loanStartDate || raw.purchaseDate || "",
  purchaseDate: raw.purchaseDate || "",
  purchasePrice,
  balanceForAmort,
  nominalRate,
  termYears,
  graceYears,
  upfrontFee,
  monthlyFeeStart,
  monthlyFee
};

const amort = calcAmort(
  normalizedLoan.balanceForAmort,
  normalizedLoan.nominalRate,
  normalizedLoan.termYears,
  normalizedLoan.graceYears
);

        const loanStart = new Date(normalizedLoan.loanStartDate);
        const purchaseDt = new Date(normalizedLoan.purchaseDate);
        const monthsSinceStartRaw = monthDiff(loanStart, purchaseDt);
        const monthsSinceStart = Number.isFinite(monthsSinceStartRaw) ? monthsSinceStartRaw : 0;

        amort.schedule = amort.schedule.map(row => {
          const ownershipMonthIndex = row.monthIndex - monthsSinceStart;
          const loanDate = addMonths(loanStart, row.monthIndex - 1);
          const ownershipDate = ownershipMonthIndex >= 1
            ? addMonths(purchaseDt, ownershipMonthIndex - 1)
            : null;

          return {
            ...row,
            ownershipMonthIndex,
            isOwned: ownershipMonthIndex >= 1,
            loanDate,
            ownershipDate
          };
        });

        let cumPrincipal = 0;
        let cumInterest  = 0;
        let cumFees      = 0;

        const termMonths = Math.max(
          1,
          Math.round(normalizedLoan.termYears * 12)
        );

        const balanceAtPurchase = amort.schedule[Math.max(0, monthsSinceStart - 1)]?.balance || 0;

        const earningsSchedule = amort.schedule.map(row => {
          const m = row.monthIndex;

// ---------------------------
// FEES (explicit business rule)
// ---------------------------

// $150 upfront fee at ownership month 1
const upfrontFeeThisMonth =
  row.isOwned && row.ownershipMonthIndex === 1
    ? 150
    : 0;

// 12.5 bps (0.125%) of current balance each owned month
const balance = Number(row.balance ?? 0);
const monthlyBalanceFee =
  row.isOwned && balance > 0
    ? +(balance * 0.00125).toFixed(2)
    : 0;

const feeThisMonth = upfrontFeeThisMonth + monthlyBalanceFee;



          if (row.isOwned) {
            cumFees      = +(cumFees + feeThisMonth).toFixed(2);
            cumPrincipal = +(cumPrincipal + row.principalPaid).toFixed(2);
            cumInterest  = +(cumInterest + row.interest).toFixed(2);
          }

          // Net earnings = principal + interest â€“ fees
          const netEarnings = +(cumPrincipal + cumInterest - cumFees).toFixed(2);

          return {
            ...row,
            feeThisMonth,
            cumPrincipal,
            cumInterest,
            cumFees,
            netEarnings,
            interestPaid: row.interest,
            principalPaid: row.principalPaid,
            loanDate: row.loanDate,
            ownershipDate: row.ownershipDate
          };
        }).filter(r => r.isOwned);

        return {
          ...normalizedLoan,
          amort,
          earningsSchedule,
          balanceAtPurchase,
          monthsSinceStart
        };
      });

// Canonical loan order: earliest purchase date first
loansWithEarnings.sort((a, b) => {
  const da = new Date(a.purchaseDate).getTime() || 0;
  const db = new Date(b.purchaseDate).getTime() || 0;
  return da - db;
});

// Build stable color map from this order
buildLoanColorMap(loansWithEarnings);

  
      window.LoanMap = Object.fromEntries(
        loansWithEarnings.map(l => [l.loanName, l])
      );
    }

// High-contrast categorical palette (no yellow)
const KPI_PALETTE = [
  "#2563eb", // blue
  "#dc2626", // red
  "#16a34a", // green
  "#7c3aed", // purple
  "#ea580c", // orange
  "#0891b2", // cyan
  "#9333ea", // violet
  "#15803d", // dark green
  "#b91c1c", // dark red
  "#1e40af", // navy
  "#c2410c", // burnt orange
  "#0f766e"  // teal
];

// Build color map based on SORTED loan order
function buildLoanColorMap(sortedLoans) {
  const map = {};
  sortedLoans.forEach((loan, idx) => {
    map[loan.loanId] = KPI_PALETTE[idx % KPI_PALETTE.length];
  });
  window.KPI_COLOR_MAP = map;
}
    
    // --------------------------
    // KPI calculations
    // --------------------------
function computeEarningsKPIs(list) {
  let totalNetToDate = 0;
  let totalNetProjected = 0;
  let totalFeesToDate = 0;
  let totalFeesProjected = 0;
  let totalPrincipal = 0;
  let monthsCounted = 1;
  let projectedNetTotal = 0;
let projectedMonthsTotal = 0;


  const TODAY = new Date();
  TODAY.setHours(0, 0, 0, 0);

// --- KPI3 start for Method A: earliest LOAN start month (calendar timeline) ---
const startTimes = list
  .map(l => new Date(l.loanStartDate || l.purchaseDate || TODAY).getTime())
  .filter(t => Number.isFinite(t));

const portfolioStart = startTimes.length
  ? new Date(Math.min(...startTimes))
  : TODAY;

portfolioStart.setHours(0,0,0,0);

// expose portfolio start for KPI3 chart math (if used elsewhere)
window.__PORTFOLIO_START__ = portfolioStart;



  list.forEach(l => {
    totalPrincipal += Number(l.purchasePrice || 0);

    const sched = l.earningsSchedule || [];
    if (!sched.length) return;

    const lastIdx = sched.length - 1;
     const atEnd = sched[lastIdx];

    // KPI4 â€” projected avg monthly earnings (lifetime)
    projectedNetTotal += Number(atEnd.netEarnings || 0);
    projectedMonthsTotal += sched.length;


    // Use PURCHASE date (ownership timeline)
    const purchase = new Date(l.purchaseDate || l.loanStartDate);
    purchase.setHours(0, 0, 0, 0);

    const diffRaw = monthDiff(purchase, TODAY);
    const diff = Number.isFinite(diffRaw) ? Math.max(1, diffRaw) : 1;

    const currentIdx = Math.max(0, Math.min(diff - 1, lastIdx));
    const atCurrent = sched[currentIdx];

    // KPI3 requires TRUE cumulative net-to-date per loan
    totalNetToDate += Number(atCurrent?.netEarnings || 0);


    totalFeesToDate += Number(atCurrent.cumFees || 0);

    // projected = last owned-row in schedule (future owned months exist in sched)
   
    totalNetProjected += Number(atEnd.netEarnings || 0);
    totalFeesProjected += Number(atEnd.cumFees || 0);

    monthsCounted = Math.max(monthsCounted, Math.min(diff, sched.length));
  });

  const projectedAvgMonthlyNet =
  projectedMonthsTotal > 0
    ? projectedNetTotal / projectedMonthsTotal
    : 0;


// --- KPI3 Avg Monthly Earnings (Method A: calendar months) ---
const portfolioMonths =
  Math.max(1, monthDiff(portfolioStart, TODAY) + 1);

const avgMonthlyNet = totalNetToDate / portfolioMonths;
const monthsCountedKpi3 = portfolioMonths;

  return {
  totalNetToDate,
  totalNetProjected,
  totalFeesToDate,
  totalFeesProjected,
  totalPrincipal,
  avgMonthlyNet,
  monthsCounted: monthsCountedKpi3,
  projectedAvgMonthlyNet
  };
  }


    function getCurrentEarningsRow(loan) {
  const TODAY = new Date();
  TODAY.setHours(0, 0, 0, 0);

  const sched = loan.earningsSchedule || [];
  if (!sched.length) {
    return { row: { netEarnings:0, cumPrincipal:0, cumInterest:0, cumFees:0 }, idx: 0 };
  }

  // Use PURCHASE date (ownership timeline), not loan start date
  const purchase = new Date(loan.purchaseDate || loan.loanStartDate);
  purchase.setHours(0, 0, 0, 0);

  const lastIdx = sched.length - 1;

  const diffRaw = monthDiff(purchase, TODAY);
  const diff = Number.isFinite(diffRaw) ? Math.max(1, diffRaw) : 1;

  const idx = Math.max(0, Math.min(diff - 1, lastIdx));
  return { row: sched[idx], idx };
}


    let kpis = computeEarningsKPIs(loansWithEarnings);
    let totalPrincipal = 0;

    let miniHtmlTooltip = null;
    function getMiniHtmlTooltip() {
      if (!miniHtmlTooltip) {
        miniHtmlTooltip = document.createElement("div");
        miniHtmlTooltip.className = "lens-tooltip-html";
        miniHtmlTooltip.style.display = "none";
        document.body.appendChild(miniHtmlTooltip);
      }
      return miniHtmlTooltip;
    }

    function setMiniTooltipContent(lines) {
      const el = getMiniHtmlTooltip();
      el.innerHTML = lines.join("<br>");
    }

    function positionMiniTooltip(clientX, clientY, radius) {
      const el = getMiniHtmlTooltip();
      const rect = el.getBoundingClientRect();

      const padding = 12;

      // Default: centered above lens
      let x = clientX - rect.width / 2;
      let y = clientY - radius - rect.height - 8;

      // Clamp horizontally to viewport
      if (x < padding) {
        x = padding;
      } else if (x + rect.width > window.innerWidth - padding) {
        x = window.innerWidth - rect.width - padding;
      }

      // If too close to top, move below lens
      if (y < padding) {
        y = clientY + radius + 8;
      }

      el.style.left = `${x}px`;
      el.style.top  = `${y}px`;
      el.style.display = "block";
    }


    function hideMiniTooltip() {
      if (miniHtmlTooltip) miniHtmlTooltip.style.display = "none";
    }

    // --------------------------
    // Mini stacked earnings chart (per tile)
    // --------------------------
    
    // --------------------------
    // Mini stacked earnings chart (per tile)
    // --------------------------
    function createMiniStackedEarningsSVG(containerEl, earningsSchedule, loan){
      containerEl.innerHTML = "";
      const svgNS = "http://www.w3.org/2000/svg";
      const w = 170;
      const h = 48;
      const padL = 4, padR = 4, padT = 4, padB = 4;

      const data = earningsSchedule;

      let maxAbs = 0;
      data.forEach(d => {
        const pos = d.cumPrincipal + d.cumInterest;
        const neg = -d.cumFees;
        maxAbs = Math.max(maxAbs, pos, Math.abs(neg));
      });
      if(maxAbs <= 0) maxAbs = 1;

      const yZero = h/2;
      const halfHeight = (h - padT - padB) / 2;
      const scale = halfHeight / maxAbs;

      const count = data.length;
      const barW = (w - padL - padR) / Math.max(1, count);

      const svg = document.createElementNS(svgNS,"svg");
      svg.setAttribute("viewBox", `0 0 ${w} ${h}`);
      svg.setAttribute("width","100%");
      svg.setAttribute("height","48");

      const stackedGroupId = `stack-${stackedBarGroupCounter++}`;

      const axis = document.createElementNS(svgNS,"line");
      axis.setAttribute("x1",padL);
      axis.setAttribute("x2",w-padR);
      axis.setAttribute("y1",yZero);
      axis.setAttribute("y2",yZero);
      axis.setAttribute("stroke","#cbd5e1");
      axis.setAttribute("stroke-width","0.8");
      svg.appendChild(axis);

      data.forEach((d, i) => {
        const x = padL + i*barW;

        const principal = d.cumPrincipal;
        const interest = d.cumInterest;
        const negFees = -d.cumFees;

        const hPrin = principal * scale;
        const hInt  = interest  * scale;
        const hFees = Math.abs(negFees) * scale;

        const yInt  = yZero - hInt;
        const yPrin = yZero - hInt - hPrin;
        const yFee  = yZero;

        const barWidth = Math.max(1, barW-2);

        const rPrin = document.createElementNS(svgNS,"rect");
        rPrin.setAttribute("x", x+1);
        rPrin.setAttribute("y", yPrin);
        rPrin.setAttribute("width", barWidth);
        rPrin.setAttribute("height", hPrin);
        rPrin.setAttribute("fill", "#0ea5e9");
        rPrin.__value = principal;
        prepareStackedBar(rPrin, stackedGroupId, 0, true);

        const rInt = document.createElementNS(svgNS,"rect");
        rInt.setAttribute("x", x+1);
        rInt.setAttribute("y", yInt);
        rInt.setAttribute("width", barWidth);
        rInt.setAttribute("height", hInt);
        rInt.setAttribute("fill", "#22c55e");
        rInt.__value  = interest;
        prepareStackedBar(rInt, stackedGroupId, 1, true);

        const rFee = document.createElementNS(svgNS,"rect");
        rFee.setAttribute("x", x+1);
        rFee.setAttribute("y", yFee);
        rFee.setAttribute("width", barWidth);
        rFee.setAttribute("height", hFees);
        rFee.setAttribute("fill", "#ef4444");
        rFee.__value  = negFees;
        prepareStackedBar(rFee, stackedGroupId, 2, false);

        svg.appendChild(rPrin);
        svg.appendChild(rInt);
        svg.appendChild(rFee);
      });

      // ==== Correct Today line using ownership start ====
const TODAY = new Date();

const firstOwnDate = new Date(loan.purchaseDate);
const lastOwnDate  = new Date(data[data.length - 1].ownershipDate);

// Total owned months
let totalOwnedMonths = monthDiff(firstOwnDate, lastOwnDate);
if (!Number.isFinite(totalOwnedMonths) || totalOwnedMonths <= 0) {
  totalOwnedMonths = data.length - 1;
}

// Months from purchase to today
let ownedMonthsToToday = monthDiff(firstOwnDate, TODAY);
if (!Number.isFinite(ownedMonthsToToday)) ownedMonthsToToday = 0;

// Clamp
ownedMonthsToToday = Math.max(0, Math.min(ownedMonthsToToday, totalOwnedMonths));

// Convert to X position
const ratio = totalOwnedMonths > 0 ? (ownedMonthsToToday / totalOwnedMonths) : 0;
const currentX = padL + ratio * (w - padL - padR);

      const vline = document.createElementNS(svgNS, "line");
      vline.setAttribute("x1", currentX);
      vline.setAttribute("x2", currentX);
      vline.setAttribute("y1", 0);
      vline.setAttribute("y2", h);
      vline.setAttribute("stroke", "#64748b");
      vline.setAttribute("stroke-dasharray", "4,3");
      vline.setAttribute("stroke-width", "1");
      svg.appendChild(vline);

      containerEl.appendChild(svg);

      let lensInstance = null;
      const lensRadius = 20;
      const lensScale = 2;

      function handleMove(e){
        const rect = svg.getBoundingClientRect();
        const mouseX = ((e.clientX - rect.left) / rect.width) * w;
        const mouseY = ((e.clientY - rect.top) / rect.height) * h;
        const x = Math.max(lensRadius, Math.min(w - lensRadius, mouseX));
        const y = Math.max(lensRadius, Math.min(h - lensRadius, mouseY));

        if(!lensInstance){
          lensInstance = createLens(svg, lensRadius, lensScale);
          const barClones = Array.from(svg.querySelectorAll("rect"))
            .filter(r => r.__value !== undefined || r.getAttribute("fill"));
          barClones.forEach(r => lensInstance.content.appendChild(r.cloneNode(true)));
          svg.appendChild(lensInstance.group);
        }

        updateLens(lensInstance, x, y);

        const idx = Math.max(0, Math.min(data.length - 1, Math.floor((x - padL) / barW)));
        const row = data[idx];
        const loanStart = new Date(loan.loanStartDate);
        const tooltipDate = addMonths(loanStart, idx);
        const tooltipLines = [
          `Date: ${formatDate(tooltipDate)}`,
          `Principal: $${row.cumPrincipal.toFixed(2)}`,
          `Interest: $${row.cumInterest.toFixed(2)}`,
          `Fees: -$${row.cumFees.toFixed(2)}`,
          `Net: $${row.netEarnings.toFixed(2)}`
        ];

        setMiniTooltipContent(tooltipLines);
        positionMiniTooltip(e.clientX, e.clientY, lensRadius);
      }

      function handleLeave(){
        removeLens(svg, lensInstance);
        lensInstance = null;
        hideMiniTooltip();
      }

      svg.addEventListener("mousemove", handleMove);
      svg.addEventListener("mouseleave", handleLeave);
    }

// =======================================================
// NEW: Portfolio KPI Stacked Chart (aggregated rows)
// =======================================================
function createKpiStackedChart(container, rows, opts = {}) {
  const isKpi4 = opts.isKpi4 === true;

  const denseXAxis = opts.denseXAxis || false;

  container.innerHTML = "";

  const svgNS = "http://www.w3.org/2000/svg";
  const rect = container.getBoundingClientRect();
  const w = Math.max(360, rect.width || 700);
  const h = container.offsetHeight || 360;

  const padL = 64, padR = 10, padT = 20, padB = 20;


  const svg = document.createElementNS(svgNS, "svg");
  svg.setAttribute("viewBox", `0 0 ${w} ${h}`);
  svg.setAttribute("width", "100%");
  svg.setAttribute("height", "100%");

  // Collect all loanIds for color mapping
  const loanIds = new Set();
  rows.forEach(r => r.contributions.forEach(c => loanIds.add(c.loanId)));
  const loanIdList = [...loanIds];

  // Use global color map (already built in rebuildLoansWithEarnings)
  const colors = window.KPI_COLOR_MAP || {};

  // ----------------------------
  // Y scale + gridlines (KPI2 style)
  // ----------------------------
  let maxVal = 0;
  rows.forEach(r => {
    const totalPos = r.contributions
      .filter(c => c.net >= 0)
      .reduce((s, c) => s + c.net, 0);
    const totalNeg = r.contributions
      .filter(c => c.net < 0)
      .reduce((s, c) => s + Math.abs(c.net), 0);

    maxVal = Math.max(maxVal, totalPos, totalNeg);
  });
  if (maxVal < 1) maxVal = 1;

  const usableH = h - padT - padB;
  // Full vertical range for positive earnings (zero at bottom)
const scale = usableH / maxVal;
const yZero = padT + usableH;


  // Horizontal grid lines + Y-axis labels (like KPI2 / drawer chart)
  const gridBelowZero = 2;
  const gridAboveZero = 4;

  for (let gy = -gridBelowZero; gy <= gridAboveZero; gy++) {
    const y = yZero - gy * ((yZero - padT) / gridAboveZero);

    const gridLine = document.createElementNS(svgNS, "line");
    gridLine.setAttribute("x1", padL);
    gridLine.setAttribute("x2", w - padR);
    gridLine.setAttribute("y1", y);
    gridLine.setAttribute("y2", y);
    gridLine.setAttribute(
      "stroke",
      gy >= 0 ? "var(--grid-strong)" : "var(--grid-light)"
    );
    gridLine.setAttribute("stroke-width", "0.7");
    svg.appendChild(gridLine);

    // Positive ticks get labels
    if (gy > 0) {
      const lbl = document.createElementNS(svgNS, "text");
      const value = (maxVal / gridAboveZero) * gy;
      lbl.textContent = "$" + Math.round(value).toLocaleString();
      lbl.setAttribute("x", padL - 12);
      lbl.setAttribute("y", y + 4);
      lbl.setAttribute("font-size", "11");
      lbl.setAttribute("fill", "var(--text)");
      lbl.setAttribute("text-anchor", "end");
      svg.appendChild(lbl);
    }
  }

  // Zero axis
  const axis = document.createElementNS(svgNS, "line");
  axis.setAttribute("x1", padL);
  axis.setAttribute("x2", w - padR);
  axis.setAttribute("y1", yZero);
  axis.setAttribute("y2", yZero);
  axis.setAttribute("stroke", "var(--grid-strong)");
  axis.setAttribute("stroke-width", "1");
  svg.appendChild(axis);

  // ----------------------------
  // Stacked bars
  // ----------------------------
// Make KPI1 bars thinner (fixed width instead of auto-fill)
// Correct bar spacing across the full chart width
const barW = (w - padL - padR) / rows.length;


  rows.forEach((r, i) => {
    const x = padL + i * barW;
   // Make bars thinner but keep correct spacing
    // Allow overriding bar thickness (default: thick, fills width)
let bw;
if (opts.thinBars) {
  bw = Math.max(1, barW * 0.35);    // thin mode
} else {
  bw = Math.max(2, barW * 0.85);    // thick, fills horizontal space
}

    let yUp = yZero;

    // SORT to ensure stacking order is consistent every month
    const sortedContribs = loansWithEarnings
  .filter(l => !hiddenLoans.has(l.loanId))
  .map(l => r.contributions.find(c => c.loanId === l.loanId))
  .filter(Boolean);

sortedContribs.forEach(c => {
  const net = c.net || 0;
  const hVal = Math.max(0, net * scale);
  if (!Number.isFinite(hVal) || hVal <= 0) return;

  const bar = document.createElementNS(svgNS, "rect");
  bar.dataset.loanId = c.loanId;
  bar.setAttribute("x", x);
  bar.setAttribute("width", bw);
  bar.setAttribute("height", hVal);
  bar.setAttribute("fill", colors[c.loanId] || "#0ea5e9");

  bar.setAttribute("y", yUp - hVal);
  yUp -= hVal;

  svg.appendChild(bar);
});



    // X-axis labels (denser for KPI1, sparse for others)
    if ((denseXAxis && i % 4 === 0) || (!denseXAxis && i % 24 === 0)) {
      const lbl = document.createElementNS(svgNS, "text");
      lbl.textContent = r.date.toLocaleString("en-US", {
        month: "short",
        year: "numeric"
      });
      lbl.setAttribute("x", x + bw / 2);
      lbl.setAttribute("y", h - 4);
      lbl.setAttribute("font-size", "11");
      lbl.setAttribute("fill", "var(--text)");
      lbl.setAttribute("text-anchor", "middle");
      svg.appendChild(lbl);
    }
  });
// ==========================
// TODAY vertical dotted line
// (NOT for KPI4)
// ==========================
if (!isKpi4) {
  const TODAY = new Date();
  TODAY.setHours(0, 0, 0, 0);

  const firstDate = rows[0]?.date;
  const lastDate  = rows[rows.length - 1]?.date;

  if (firstDate && lastDate) {
    const totalMonths = monthDiff(firstDate, lastDate);
    let monthsToToday = monthDiff(firstDate, TODAY);

    if (!Number.isFinite(monthsToToday)) monthsToToday = 0;

    monthsToToday = Math.max(0, Math.min(monthsToToday, totalMonths));

    const ratio = totalMonths > 0 ? monthsToToday / totalMonths : 0;

    const todayX = padL + ratio * (w - padL - padR);

    const todayLine = document.createElementNS(svgNS, "line");
    todayLine.setAttribute("x1", todayX);
    todayLine.setAttribute("x2", todayX);
    todayLine.setAttribute("y1", padT);
    todayLine.setAttribute("y2", h - padB);
    todayLine.setAttribute("stroke", "#64748b");
    todayLine.setAttribute("stroke-dasharray", "4,3");
    todayLine.setAttribute("stroke-width", "1");
    todayLine.setAttribute("pointer-events", "none");

    svg.appendChild(todayLine);
  }
}


  
  container.appendChild(svg);

  // =======================
  // KPI Chart Hover System
  // (lens size matches KPI2 / drawer)
  // =======================
  let lensInstance = null;
  const lensRadius = 40;   // match KPI2 / loan drawer
  const lensScale = 1.5;

  function handleMove(e) {
    const rect = svg.getBoundingClientRect();
    const mouseX = ((e.clientX - rect.left) / rect.width) * w;
    const mouseY = ((e.clientY - rect.top) / rect.height) * h;

    const x = Math.max(lensRadius, Math.min(w - lensRadius, mouseX));
    const y = Math.max(lensRadius, Math.min(h - lensRadius, mouseY));

    if (!lensInstance) {
      lensInstance = createLens(svg, lensRadius, lensScale);
      const clones = Array.from(svg.querySelectorAll("rect"));
      clones.forEach(r => lensInstance.content.appendChild(r.cloneNode(true)));
      svg.appendChild(lensInstance.group);
    }

    updateLens(lensInstance, x, y);

    // Map lens X position â†’ month index
    const idx = Math.max(
      0,
      Math.min(rows.length - 1, Math.floor((x - padL) / barW))
    );
    const row = rows[idx];

    const principal = row.contributions
    .reduce((s, c) => s + (c.principal ?? 0), 0);

    const interest = row.contributions
    .reduce((s, c) => s + (c.interest ?? 0), 0);

    const fees = row.contributions
    .reduce((s, c) => s + (c.fees ?? 0), 0);

    const net = principal + interest - fees;

let tooltipLines;

if (isKpi4) {
  // KPI4 â€” Projected Avg Monthly Earnings
  const net = row.contributions
    .reduce((s, c) => s + (c.net ?? 0), 0);

  tooltipLines = [
    `Date: ${formatMonthYear(row.date)}`,
    `Projected Net: ${formatCurrency(net)}`
  ];
} else {
  // Other KPIs (unchanged behavior)
  tooltipLines = [
    `Date: ${formatMonthYear(row.date)}`,
    `Principal: ${formatCurrency(principal)}`,
    `Interest: ${formatCurrency(interest)}`,
    `Fees: -${formatCurrency(fees)}`,
    `Net: ${formatCurrency(net)}`
  ];
}

setMiniTooltipContent(tooltipLines);
positionMiniTooltip(e.clientX, e.clientY, lensRadius);

  }

  function handleLeave() {
    removeLens(svg, lensInstance);
    lensInstance = null;
    hideMiniTooltip();
  }

  svg.addEventListener("mousemove", handleMove);
  svg.addEventListener("mouseleave", handleLeave);
}

// =======================================================
// KPI4 table â†’ chart hover helpers
// =======================================================
function highlightLoanInKpiChart(container, loanId) {
  if (!container) return;

  container.querySelectorAll("rect[data-loan-id]").forEach(el => {
    if (el.dataset.loanId === loanId) {
      el.style.opacity = "1";
    } else {
      el.style.opacity = "0.15";
    }
  });
}

function clearKpiChartHighlight(container) {
  if (!container) return;

  container.querySelectorAll("rect[data-loan-id]").forEach(el => {
    el.style.opacity = "";
  });
}


    
function renderKpi3AvgLineChart(container, rows) {
  container.innerHTML = "";
  if (!rows || !rows.length) return;

  const svgNS = "http://www.w3.org/2000/svg";
  const w = container.clientWidth || 700;
  const h = container.clientHeight || 240;

  const padL = 60, padR = 20, padT = 20, padB = 52;

  const svg = document.createElementNS(svgNS, "svg");
  svg.setAttribute("viewBox", `0 0 ${w} ${h}`);
  svg.setAttribute("width", "100%");
  svg.setAttribute("height", "100%");

  const maxValRaw = Math.max(1, ...rows.map(r => Number(r.avg) || 0));
  const maxVal = maxValRaw * 1.15; // a little headroom like other charts

  const usableH = h - padT - padB;
  const usableW = w - padL - padR;

  const scaleY = usableH / maxVal;
  const stepX = usableW / Math.max(1, rows.length - 1);

  // Grid + Y labels
  for (let i = 0; i <= 4; i++) {
    const y = padT + i * (usableH / 4);
    const val = maxVal * (1 - i / 4);

    const line = document.createElementNS(svgNS, "line");
    line.setAttribute("x1", padL);
    line.setAttribute("x2", w - padR);
    line.setAttribute("y1", y);
    line.setAttribute("y2", y);
    line.setAttribute("stroke", "var(--grid-light)");
    svg.appendChild(line);

    const txt = document.createElementNS(svgNS, "text");
    txt.textContent = formatCurrency(val);
    txt.setAttribute("x", padL - 8);
    txt.setAttribute("y", y + 4);
    txt.setAttribute("font-size", "11");
    txt.setAttribute("text-anchor", "end");
    txt.setAttribute("fill", "var(--text)");
    svg.appendChild(txt);
  }

  // Line path
  let d = "";
  rows.forEach((r, i) => {
    const x = padL + i * stepX;
    const y = h - padB - (Number(r.avg) || 0) * scaleY;
    d += i === 0 ? `M ${x} ${y}` : ` L ${x} ${y}`;
  });

  const path = document.createElementNS(svgNS, "path");
  path.setAttribute("d", d);
  path.setAttribute("fill", "none");
  path.setAttribute("stroke", "var(--brand)");
  path.setAttribute("stroke-width", "3");
  svg.appendChild(path);

    // ----------------------------
  // X axis labels (every 12th month)
  // ----------------------------
  const xAxisY = h - padB + 18;

  for (let i = 0; i < rows.length; i += 12) {
    const x = padL + i * stepX;

    // small tick
    const tick = document.createElementNS(svgNS, "line");
    tick.setAttribute("x1", x);
    tick.setAttribute("x2", x);
    tick.setAttribute("y1", h - padB);
    tick.setAttribute("y2", h - padB + 6);
    tick.setAttribute("stroke", "var(--grid-light)");
    tick.setAttribute("stroke-width", "1");
    svg.appendChild(tick);

    // label
    const lbl = document.createElementNS(svgNS, "text");
    lbl.textContent = formatMonthYear(rows[i].date); // already used by your tooltip code :contentReference[oaicite:2]{index=2}
    lbl.setAttribute("x", x);
    lbl.setAttribute("y", xAxisY);
    lbl.setAttribute("font-size", "11");
    lbl.setAttribute("fill", "var(--muted)");
    lbl.setAttribute("text-anchor", "middle");
    svg.appendChild(lbl);
  }


  // Hover: vertical line + dot
  const vLine = document.createElementNS(svgNS, "line");
  vLine.setAttribute("y1", padT);
  vLine.setAttribute("y2", h - padB);
  vLine.setAttribute("stroke", "var(--text)");
  vLine.setAttribute("stroke-dasharray", "3 4");
  vLine.setAttribute("stroke-opacity", "0");
  svg.appendChild(vLine);

  const dot = document.createElementNS(svgNS, "circle");
  dot.setAttribute("r", "5");
  dot.setAttribute("fill", "var(--brand)");
  dot.setAttribute("stroke", "white");
  dot.setAttribute("stroke-width", "2");
  dot.setAttribute("opacity", "0");
  svg.appendChild(dot);

  container.appendChild(svg);

  function idxFromClientX(clientX) {
    const rect = svg.getBoundingClientRect();
    const x = ((clientX - rect.left) / rect.width) * w;
    const t = (x - padL) / stepX;
    return Math.max(0, Math.min(rows.length - 1, Math.round(t)));
  }

  function handleMove(e) {
    const idx = idxFromClientX(e.clientX);
    const r = rows[idx];

    const x = padL + idx * stepX;
    const y = h - padB - (Number(r.avg) || 0) * scaleY;

    vLine.setAttribute("x1", x);
    vLine.setAttribute("x2", x);
    vLine.setAttribute("stroke-opacity", "0.8");

    dot.setAttribute("cx", x);
    dot.setAttribute("cy", y);
    dot.setAttribute("opacity", "1");

    const tooltipLines = [
      `Date: ${formatMonthYear(r.date)}`,
      `Avg / Month: ${formatCurrency(r.avg)}`,
      `Net to Date: ${formatCurrency(r.netToDate)}`
    ];

    // uses your existing mini tooltip system (already in the file)
    setMiniTooltipContent(tooltipLines);
    positionMiniTooltip(e.clientX, e.clientY, 40);
  }

  function handleLeave() {
    vLine.setAttribute("stroke-opacity", "0");
    dot.setAttribute("opacity", "0");
    hideMiniTooltip();
  }

  svg.addEventListener("mousemove", handleMove);
  svg.addEventListener("mouseleave", handleLeave);
}


    
    // --------------------------
    // Drawer stacked chart (larger)
    // --------------------------
    function createDrawerStackedChart(containerEl, earningsSchedule, loan){
      containerEl.innerHTML = "";
      const svgNS = "http://www.w3.org/2000/svg";
      const rect = containerEl.getBoundingClientRect();
      const w = Math.max(360, rect.width || 700);
      const h = 260;
      const padL = 50, padR = 20, padT = 20, padB = 16;

      const data = earningsSchedule;

      let maxValue = 0;
      let minValue = 0;
      data.forEach(d => {
        const pos = d.cumPrincipal + d.cumInterest;
        const neg = -d.cumFees;
        maxValue = Math.max(maxValue, pos);
        minValue = Math.min(minValue, neg);
      });

      const yMax = Math.max(maxValue, 1);
      const yMin = minValue < -10 ? minValue : -(yMax * 0.10);
      const yRange = yMax - yMin || 1;
      const usableHeight = h - padT - padB;
      const scale = usableHeight / yRange;
      const yZero = padT + (yMax / yRange) * usableHeight;

      const count = data.length;
      const barW = (w - padL - padR) / Math.max(1, count);

      const svg = document.createElementNS(svgNS,"svg");
      svg.setAttribute("viewBox", `0 0 ${w} ${h}`);
      svg.setAttribute("width","100%");
      svg.setAttribute("height","100%");

      const gridBelowZero = 2;
      const gridAboveZero = 4;

      for (let gy = -gridBelowZero; gy <= gridAboveZero; gy++) {
        const y = yZero - gy * ((yZero - padT) / gridAboveZero);

        const gridLine = document.createElementNS(svgNS,"line");
        gridLine.setAttribute("x1",padL);
        gridLine.setAttribute("x2",w-padR);
        gridLine.setAttribute("y1",y);
        gridLine.setAttribute("y2",y);
        gridLine.setAttribute("stroke", gy >= 0 ? "var(--grid-strong)" : "var(--grid-light)");
        gridLine.setAttribute("stroke-width","0.7");
        svg.appendChild(gridLine);

        if(gy > 0){
          const lbl = document.createElementNS(svgNS,"text");
          const value = (yMax / gridAboveZero) * gy;
          lbl.textContent = "$" + Math.round(value).toLocaleString();
          lbl.setAttribute("x", padL - 10);
          lbl.setAttribute("y", y + 4);
          lbl.setAttribute("font-size","11");
          lbl.setAttribute("fill","var(--text)");
          lbl.setAttribute("text-anchor","end");
          svg.appendChild(lbl);
        }
      }

      const axis = document.createElementNS(svgNS,"line");
      axis.setAttribute("x1",padL);
      axis.setAttribute("x2",w-padR);
      axis.setAttribute("y1",yZero);
      axis.setAttribute("y2",yZero);
      axis.setAttribute("stroke","var(--grid-strong)");
      axis.setAttribute("stroke-width","1");
      svg.appendChild(axis);

      data.forEach((d, i) => {
        const stackedGroupId = `stack-drawer-${d.ownershipMonthIndex || d.monthIndex || i}`;
        const x = padL + i*barW;

        const principal = d.cumPrincipal;
        const interest = d.cumInterest;
        const negFees = -d.cumFees;

        const hPrin = principal * scale;
        const hInt  = interest  * scale;
        const hFees = Math.abs(negFees) * scale;

        const yInt  = yZero - hInt;
        const yPrin = yZero - hInt - hPrin;
        const yFee  = yZero;

        const barWidth = Math.max(2, barW-4);

        const rPrin = document.createElementNS(svgNS,"rect");
        rPrin.setAttribute("x", x+2);
        rPrin.setAttribute("y", yPrin);
        rPrin.setAttribute("width", barWidth);
        rPrin.setAttribute("height", hPrin);
        rPrin.setAttribute("fill","#0ea5e9");
        prepareStackedBar(rPrin, stackedGroupId, 0, true);

        const rInt = document.createElementNS(svgNS,"rect");
        rInt.setAttribute("x", x+2);
        rInt.setAttribute("y", yInt);
        rInt.setAttribute("width", barWidth);
        rInt.setAttribute("height", hInt);
        rInt.setAttribute("fill","#22c55e");
        prepareStackedBar(rInt, stackedGroupId, 1, true);

        const rFee = document.createElementNS(svgNS,"rect");
        rFee.setAttribute("x", x+2);
        rFee.setAttribute("y", yFee);
        rFee.setAttribute("width", barWidth);
        rFee.setAttribute("height", hFees);
        rFee.setAttribute("fill","#ef4444");
        prepareStackedBar(rFee, stackedGroupId, 2, false);

        svg.appendChild(rPrin);
        svg.appendChild(rInt);
        svg.appendChild(rFee);

        if(((d.ownershipMonthIndex || d.monthIndex) % 12) === 0 || (d.ownershipMonthIndex || d.monthIndex) === 1){
          const lbl = document.createElementNS(svgNS,"text");
          const dateLabel = d.ownershipDate || d.loanDate;
          lbl.textContent = formatMonthYear(dateLabel);
          lbl.setAttribute("x", x+barWidth/2);
          lbl.setAttribute("y", h-padB+16);
          lbl.setAttribute("font-size","11");
          lbl.setAttribute("fill","var(--text)");
          lbl.setAttribute("text-anchor","middle");
          svg.appendChild(lbl);
        }
      });

      // ==== Correct Today line using ownership start ====
const TODAY = new Date();

const firstOwnDate = new Date(loan.purchaseDate);
const lastOwnDate  = new Date(data[data.length - 1].ownershipDate);

// Total owned months
let totalOwnedMonths = monthDiff(firstOwnDate, lastOwnDate);
if (!Number.isFinite(totalOwnedMonths) || totalOwnedMonths <= 0) {
  totalOwnedMonths = data.length - 1;
}

// Months from purchase to today
let ownedMonthsToToday = monthDiff(firstOwnDate, TODAY);
if (!Number.isFinite(ownedMonthsToToday)) ownedMonthsToToday = 0;

// Clamp
ownedMonthsToToday = Math.max(0, Math.min(ownedMonthsToToday, totalOwnedMonths));

const ratio = totalOwnedMonths > 0 ? (ownedMonthsToToday / totalOwnedMonths) : 0;
const currentX = padL + ratio * (w - padL - padR);

const vline = document.createElementNS(svgNS, "line");
vline.setAttribute("x1", currentX);
vline.setAttribute("x2", currentX);
vline.setAttribute("y1", 0);
vline.setAttribute("y2", h);
vline.setAttribute("stroke", "#64748b");
vline.setAttribute("stroke-dasharray", "4,3");
vline.setAttribute("stroke-width", "1");
svg.appendChild(vline);

      containerEl.appendChild(svg);

      let lensInstance = null;
      let tooltipInstance = null;
      const lensRadius = 40;
      const lensScale = 1.5;

      function handleMove(e){
        const rect = svg.getBoundingClientRect();
        const mouseX = ((e.clientX - rect.left) / rect.width) * w;
        const mouseY = ((e.clientY - rect.top) / rect.height) * h;
        const x = Math.max(lensRadius, Math.min(w - lensRadius, mouseX));
        const y = Math.max(lensRadius, Math.min(h - lensRadius, mouseY));

        if(!lensInstance){
          lensInstance = createLens(svg, lensRadius, lensScale);
          const barClones = Array.from(svg.querySelectorAll("rect"))
            .filter(r => r.__value !== undefined || r.getAttribute("fill"));
          barClones.forEach(r => lensInstance.content.appendChild(r.cloneNode(true)));
          svg.appendChild(lensInstance.group);
        }

        if(!tooltipInstance){
          tooltipInstance = createTooltip(svg, true);
        }

        updateLens(lensInstance, x, y);

        const idx = Math.max(0, Math.min(data.length - 1, Math.floor((x - padL) / barW)));
        const row = data[idx];
        const tooltipLines = [
          `${currentLoan ? currentLoan.loanName : "Loan"} â€¢ ${formatDate(row.ownershipDate || row.loanDate)}`,
          `Principal: $${row.cumPrincipal.toFixed(2)}`,
          `Interest: $${row.cumInterest.toFixed(2)}`,
          `Fees: -$${row.cumFees.toFixed(2)}`,
          `Net: $${row.netEarnings.toFixed(2)}`
        ];

        updateTooltipContent(tooltipInstance, tooltipLines, true);
        updateTooltipPosition(tooltipInstance, x, y, lensRadius);
      }

      function handleLeave(){
        removeLens(svg, lensInstance);
        lensInstance = null;
        if(tooltipInstance){
          tooltipInstance.group.remove();
          tooltipInstance = null;
        }
      }

      svg.addEventListener("mousemove", handleMove);
      svg.addEventListener("mouseleave", handleLeave);
    }

    // --------------------------
    // Render KPI tiles
    // --------------------------
    const kpisEl = document.getElementById("kpis");
    const kpiCards = document.querySelectorAll('.kpi');

    // --- Correct KPI click binding (same pattern as amort page) ---
    kpiCards.forEach((card, idx) => {
      card.addEventListener("click", (e) => {
        e.stopPropagation();
        if (idx === 0) openKpi1();
        else if (idx === 1) openKpi2();
        else if (idx === 2) openKpi3();
        else if (idx === 3) openKpi4();
        openDrawer();   // ensure drawer opens
      });
    });


    // --------------------------
    // KPI drawers (shared drawer)
    // --------------------------
    function resetDrawerContent() {
      if (drawerChartArea) drawerChartArea.innerHTML = "";
      if (drawerExtra) drawerExtra.innerHTML = "";
    }

    function openDrawerBase() {
      drawer.classList.add("open");
      drawer.setAttribute("aria-hidden","false");
      drawer.scrollTop = 0;
    }

    // Wrapper to unify open behavior
    function openDrawer() {
      openDrawerBase();
    }

// Build aggregated rows for KPI charts (by month across loans)
// IMPORTANT: only owned months, and only up to TODAY
function buildPortfolioDrawerRows(loans) {
  const TODAY = new Date();
  TODAY.setHours(0, 0, 0, 0);

  const monthly = new Map(); // key: YYYY-MM

  loans.forEach(loan => {
    (loan.earningsSchedule || []).forEach(r => {
      // skip any non-owned rows, just in case
      if (!r.isOwned) return;

      // use ownershipDate when present (purchase-based timeline)
      const rawDate = r.ownershipDate || r.loanDate;
      if (!rawDate) return;

      const d = new Date(rawDate);
      d.setHours(0, 0, 0, 0);

      // do not show future months in the KPI drawers
      if (d > TODAY) return;

      const key = `${d.getFullYear()}-${d.getMonth() + 1}`;

      if (!monthly.has(key)) {
        monthly.set(key, {
          date: d,
          contributions: []
        });
      }

       monthly.get(key).contributions.push({
  loanId: loan.loanId,
  principal: r.principalPaid || 0,
  interest: r.interestPaid || 0,
  fees: r.feeThisMonth || 0,
  net: (r.principalPaid || 0) + (r.interestPaid || 0) - (r.feeThisMonth || 0),
  hasData: true
});


    });
  });

// convert Map â†’ sorted array BEFORE normalizing
const sorted = [...monthly.values()].sort((a, b) => a.date - b.date);

// Normalize alignment: every row must include every loan
const allLoanIds = loans.map(l => l.loanId);

for (let i = 0; i < sorted.length; i++) {
  const row = sorted[i];
  const present = new Set(row.contributions.map(c => c.loanId));

  allLoanIds.forEach(id => {
    if (!present.has(id)) {

      // carry forward the last known cumulative values for this loan
      let last = {
      principal: 0,
      interest: 0,
      fees: 0,
      net: 0
      };

      // IMPORTANT: look backward only in sorted order
      for (let j = i - 1; j >= 0; j--) {
      const prev = sorted[j].contributions.find(c => c.loanId === id);
      if (prev) {
      last = prev;
      break;
      }
    }
    row.contributions.push({
      loanId: id,
      principal: last.principal,
      interest: last.interest,
      fees: last.fees,
      net: last.net,
      hasData: false
    });
    }
  });
}

return sorted;
}

function buildProjectedDrawerRows(loans) {
  const monthly = new Map(); // key = ownership month index (1-based)

  // Anchor timeline to earliest purchase date
  const purchaseDates = loans
    .map(l => new Date(l.purchaseDate))
    .filter(d => !isNaN(d));

  const anchorDate = purchaseDates.length
    ? new Date(Math.min(...purchaseDates))
    : new Date();

  loans.forEach(loan => {
    (loan.earningsSchedule || []).forEach(r => {
      const m = r.ownershipMonthIndex;
      if (!Number.isFinite(m) || m < 1) return;

      if (!monthly.has(m)) {
        const d = new Date(anchorDate);
        d.setMonth(d.getMonth() + (m - 1));

        monthly.set(m, {
          date: d,                 // âœ… REQUIRED
          contributions: []
        });
      }

      monthly.get(m).contributions.push({
        loanId: loan.loanId,
        principal: r.cumPrincipal,
        interest: r.cumInterest,
        fees: r.cumFees,
        net: r.netEarnings,
        hasData: true
      });
    });
  });

  const sorted = [...monthly.values()].sort(
    (a, b) => a.date - b.date
  );

  // Normalize alignment (same as KPI1)
  const allLoanIds = loans.map(l => l.loanId);

  for (let i = 0; i < sorted.length; i++) {
    const row = sorted[i];
    const present = new Set(row.contributions.map(c => c.loanId));

    allLoanIds.forEach(id => {
      if (!present.has(id)) {
        let last = { principal: 0, interest: 0, fees: 0, net: 0 };

        for (let j = i - 1; j >= 0; j--) {
          const prev = sorted[j].contributions.find(c => c.loanId === id);
          if (prev) {
            last = prev;
            break;
          }
        }

        row.contributions.push({
          loanId: id,
          principal: last.principal,
          interest: last.interest,
          fees: last.fees,
          net: last.net,
          hasData: false
        });
      }
    });
  }

  return sorted;
}


function openKpi1(){
  currentLoan = null;

  drawerTitle.textContent = "Total Net Earnings to Date";
  drawerSub.textContent = "Portfolio-level earnings across all loans.";
  drawerPrimaryTitle.textContent = "Net Earnings to Date";
  drawerPrimary.textContent = formatCurrency(kpis.totalNetToDate);
  drawerSecondaryTitle.textContent = "Total Fees to Date";
  drawerSecondary.textContent = formatCurrency(kpis.totalFeesToDate);

  resetDrawerContent();

  const rows = buildPortfolioDrawerRows(loansWithEarnings);

// KPI1 uses dense x-axis
createKpiStackedChart(
  document.getElementById("drawerChartArea"),
  rows,
  { denseXAxis: true, thinBars: false }
);

  drawerExtra.innerHTML = `<div class="amort-wrap" id="drawerKpiTable"></div>`;
  renderKPI1Table(loansWithEarnings, "drawerKpiTable");

  openDrawer();
}  

function openKpi2() {
  currentLoan = null;

  drawerTitle.textContent = "Projected Total Net Earnings";
  drawerSub.textContent =
    "Projected lifetime earnings across all loans, assuming full term.";

  drawerPrimaryTitle.textContent = "Projected Net Earnings";
  drawerPrimary.textContent = formatCurrency(kpis.totalNetProjected);

  drawerSecondaryTitle.textContent = "Projected Total Fees";
  drawerSecondary.textContent = formatCurrency(kpis.totalFeesProjected);

  resetDrawerContent();

  // --- Chart ---
  renderKPI2Chart(loansWithEarnings);

  // âœ… ADD THIS BLOCK (missing today)
  drawerExtra.innerHTML = `
    <div class="amort-wrap" id="kpi2Table"></div>
  `;

  // âœ… Render table into the container you just created
  renderKPI2Table(loansWithEarnings, "kpi2Table");

  openDrawer();
}

function openKpi3() {
  currentLoan = null;

  drawerTitle.textContent = "Avg Monthly Earnings To Date";
  drawerSub.textContent =
    "Total net earnings divided by months since portfolio inception.";

  // PRIMARY = KPI tile value
  drawerPrimaryTitle.textContent = "Avg Monthly Earnings To Date";
  drawerPrimary.textContent = formatCurrency(kpis.avgMonthlyNet);

  // SECONDARY = months counted
  drawerSecondaryTitle.innerHTML = `
  Months Counted
  <span class="info-icon" title="Months counted is the total months each loan has been owned.">â“˜</span>
`;
  drawerSecondary.textContent = kpis.monthsCounted.toString();

  resetDrawerContent();

  // Active loans only
  const activeLoans = loansWithEarnings.filter(l => !hiddenLoans.has(l.loanId));

  // rows from your existing portfolio aggregator (may skip empty months)
  const rows = buildPortfolioDrawerRows(activeLoans);

  // Use the SAME portfolio start KPI3 uses
  const portfolioStart = window.__PORTFOLIO_START__
    ? new Date(window.__PORTFOLIO_START__)
    : (rows.length ? new Date(rows[0].date) : new Date());

  portfolioStart.setHours(0, 0, 0, 0);

  const TODAY = new Date();
  TODAY.setHours(0, 0, 0, 0);

  // Map existing rows by YYYY-MM
  const rowByMonth = new Map();
  rows.forEach(r => {
    const d = new Date(r.date);
    const key = `${d.getFullYear()}-${d.getMonth()}`;
    rowByMonth.set(key, r);
  });

  // Build FULL calendar months from portfolioStart â†’ TODAY
  const fullMonths = [];
  const cursor = new Date(portfolioStart.getFullYear(), portfolioStart.getMonth(), 1);
  const end = new Date(TODAY.getFullYear(), TODAY.getMonth(), 1);

  while (cursor <= end) {
    const key = `${cursor.getFullYear()}-${cursor.getMonth()}`;
    const existing = rowByMonth.get(key);

    fullMonths.push({
      date: new Date(cursor),
      contributions: existing?.contributions || []
    });

    cursor.setMonth(cursor.getMonth() + 1);
  }

// -----------------------------------
// Trim leading zero months for chart
// -----------------------------------
const firstNonZeroIdx = fullMonths.findIndex(
  m => (m.contributions || []).some(c => c.hasData)
);

const chartMonths =
  firstNonZeroIdx >= 0
    ? fullMonths.slice(firstNonZeroIdx)
    : fullMonths;

  
  // Compute avg rows using CALENDAR months elapsed (NOT i+1)
  let cumulativeNet = 0;

const avgRows = chartMonths.map(m => {
  const monthNet = (m.contributions || []).reduce(
    (sum, c) => sum + (c.hasData ? (Number(c.net) || 0) : 0),
    0
  );

  cumulativeNet += monthNet;

  const portfolioMonths =
  Math.max(1, monthDiff(window.__PORTFOLIO_START__, new Date()) + 1);

const avg = cumulativeNet / portfolioMonths;

  return {
    date: m.date,
    avg,
    netToDate: cumulativeNet,
  };
});


  // Draw chart
  renderKpi3AvgLineChart(
    document.getElementById("drawerChartArea"),
    avgRows
  );

  // Table
  drawerExtra.innerHTML = `<div class="amort-wrap" id="drawerKpiTable"></div>`;
  renderKPI3Table(activeLoans, "drawerKpiTable");

  document
  .getElementById("drawerKpiTable")
  ?.classList.add("kpi3-table");

  openDrawer();
}


function openKpi4(){
  console.assert(
  Number.isFinite(kpis.projectedAvgMonthlyNet),
  "âŒ KPI4 projectedAvgMonthlyNet missing or invalid"
);  
  currentLoan = null;
  drawerTitle.textContent = "Projected Avg Monthly Earnings";
  drawerSub.textContent = "Portfolio-level earnings across all loans.";
  drawerPrimaryTitle.textContent = "Avg / Month (Projected)";
  drawerPrimary.textContent =
  formatCurrency(kpis.projectedAvgMonthlyNet);
  drawerSecondaryTitle.textContent = "Total Fees to Date";
  drawerSecondary.textContent = formatCurrency(kpis.totalFeesToDate);
  resetDrawerContent();
  renderKPI4Chart(loansWithEarnings, "drawerChartArea");
  drawerExtra.innerHTML = `<div class="amort-wrap" id="drawerKpiTable"></div>`;
  renderKPI4Table(loansWithEarnings, "drawerKpiTable");

  // KPI4 table row hover â†’ highlight chart bars
drawerExtra.querySelectorAll("tr[data-loan-id]").forEach(row => {
  const loanId = row.dataset.loanId;

  row.addEventListener("mouseenter", () => {
    highlightLoanInKpiChart(drawerChartArea, loanId);
  });

  row.addEventListener("mouseleave", () => {
    clearKpiChartHighlight(drawerChartArea);
  });
});


// KPI4 table: swatch click toggles loan visibility
drawerExtra.querySelectorAll(".loan-swatch").forEach(el => {
  const loanId = el.dataset.loanId;

  el.style.cursor = "pointer";
  el.title = hiddenLoans.has(loanId) ? "Click to show loan" : "Click to hide loan";

  // Visual off-state
  if (hiddenLoans.has(loanId)) {
    el.style.opacity = "0.25";
  }

  el.addEventListener("click", (e) => {
    e.stopPropagation();
    toggleLoanVisibility(loanId);
  });
});

  
  openDrawer();

  const rows = [];

  loansWithEarnings.forEach(loan => {
    (loan.earningsSchedule || []).forEach((r, idx) => {
      const d = r.ownershipDate || r.loanDate;
      if (!d) return;

      const key = `${d.getFullYear()}-${d.getMonth()}`;

      let row = rows.find(x => x.key === key);
      if (!row) {
      row = {
        key,
        date: new Date(d),
        contributions: []
      };
        rows.push(row);
      }

      row.contributions.push({
        loanId: loan.loanId,
        net: r.netEarnings
      });
    });
  });

  rows.sort((a, b) => a.date - b.date);

   createKpiStackedChart(
  drawerChartArea,
  rows,
  { denseXAxis: false, isKpi4: true }
);
const tableEl = renderKpi4Table(loansWithEarnings, kpis);
drawerExtra.appendChild(tableEl);

  drawerExtra.querySelectorAll(".loan-swatch").forEach(el => {
  el.addEventListener("mouseenter", () => {
    const loanId = el.dataset.loanId;
    highlightLoanInChart(loanId);
  });

  el.addEventListener("mouseleave", () => {
    clearChartHighlight();
  });
});
 
}


    // ===========================
    // Drawer global variables
    // ===========================
    let currentLoan = null;
    let currentMode = null;
    
    // --------------------------
    // Tile + Drawer Element References (Earnings)
    // --------------------------
    const grid = document.getElementById("loanGrid");
    const drawer = document.getElementById("drawer");
    const drawerTitle = document.getElementById("drawerTitle");
    const drawerSub = document.getElementById("drawerSub");
    const drawerPrimaryTitle = document.getElementById("drawerPrimaryTitle");
    const drawerPrimary = document.getElementById("drawerPrimary");
    const drawerSecondaryTitle = document.getElementById("drawerSecondaryTitle");
    const drawerSecondary = document.getElementById("drawerSecondary");
    const drawerChartArea = document.getElementById("drawerChartArea");
    const drawerExtra = document.getElementById("drawerExtra");
    const amortBody = document.getElementById("amortBody");
    const closeBtn = document.getElementById("closeBtn");


    function renderLoanTiles() {
      grid.innerHTML = "";
      loansWithEarnings.forEach(loan => {
        const hasSchedule = loan.earningsSchedule.length > 0;
        const lastIdx = hasSchedule ? loan.earningsSchedule.length - 1 : 0;
        const fallbackRow = { netEarnings: 0, ownershipDate: new Date(loan.loanStartDate), loanDate: new Date(loan.loanStartDate) };
        const loanStart = new Date(loan.loanStartDate);
        const TODAY = new Date();
        const diffMonthsFromStartRaw = monthDiff(loanStart, TODAY);
        const diffMonthsFromStart = Number.isFinite(diffMonthsFromStartRaw)
          ? Math.max(1, diffMonthsFromStartRaw)
          : 1;
        const currentIdx = Math.max(0, Math.min(diffMonthsFromStart - 1, lastIdx));
        const atCurrent = hasSchedule
          ? loan.earningsSchedule[currentIdx] || loan.earningsSchedule[lastIdx]
          : fallbackRow;
        const currentMonthLabel = formatMonthYear(new Date());

        const tile = document.createElement("div");
        tile.className = "tile";
        tile.setAttribute("data-loan", loan.loanName);
        tile.innerHTML = `
  <div class="tile-left">

    <!-- Line 1: Loan Name -->
    <div class="loan-name" style="font-weight:700; font-size:14px;">
      ${loan.loanName}
    </div>

    <!-- Line 2: School -->
    <div class="loan-name" style="font-weight:700; font-size:14px; margin-top:2px;">
      ${loan.school || "No school listed"}
    </div>

    <!-- Line 3: Rate Â· Term Â· Matures -->
    <div class="loan-sub" style="margin-top:6px;">
      Rate: ${(loan.nominalRate * 100).toFixed(2)}% &nbsp;Â·&nbsp;
      Term: ${loan.termYears} yrs &nbsp;Â·&nbsp;
      Matures: ${formatMonthYear(addMonths(new Date(loan.loanStartDate), loan.termYears * 12))}
    </div>

    <!-- Line 4: Loan ID -->
    <div class="loan-sub" style="margin-top:4px;">
      Loan ${loan.loanId}
    </div>

  </div>

  <div class="chart-wrap">
    <div class="mini-label">
      Net Earnings ${currentMonthLabel}: $${atCurrent.netEarnings.toFixed(0)}
    </div>
    <div class="mini-chart"></div>
  </div>
`;
        grid.appendChild(tile);

        tile.addEventListener("click", () => openLoanDrawer(loan));

        const mini = tile.querySelector('.mini-chart');
        const series = portfolioViews?.earningsSeries?.[loan.id] || loan.earningsSchedule;
      createMiniStackedEarningsSVG(
        mini,
        loan.earningsSchedule,
        loan
      );

     });   
    }

    async function initPage() {
  await loadLoansFromBackend();
  rebuildLoansWithEarnings();

  // build portfolio-wide earnings series for charts (mini + drawer + KPI)
  portfolioViews = buildPortfolioViews(loansWithEarnings);

      buildLoanColorMap(loansWithEarnings);


  kpis = computeEarningsKPIs(loansWithEarnings);

document.getElementById("kpiNetToDate").textContent =
 formatCurrency(kpis.totalNetToDate);

document.getElementById("kpiNetProj").textContent =
  formatCurrency(kpis.totalNetProjected);

document.getElementById("kpiAvgMonth").textContent =
  formatCurrency(kpis.avgMonthlyNet);

document.getElementById("kpiFees").textContent =
  formatCurrency(kpis.projectedAvgMonthlyNet);


  renderLoanTiles();
}


    // --------------------------
    // Drawer behavior
    // --------------------------
    closeBtn.addEventListener("click", closeDrawer);
    document.addEventListener("keydown", e => {
      if(e.key === "Escape") closeDrawer();
    });

    function closeDrawer(){
      drawer.classList.remove("open");
      drawer.setAttribute("aria-hidden","true");
      currentLoan = null;
    }

    document.addEventListener("click", function(e){
      if (!drawer.classList.contains("open")) return;
      if (drawer.contains(e.target)) return;
      if (e.target.closest(".tile")) return;  // tile click = open another drawer, not close
      closeDrawer();
    });

    function openLoanDrawer(loan){
      currentLoan = loan;
      resetDrawerContent();
      const hasSchedule = loan.earningsSchedule.length > 0;
      const lastIdx = hasSchedule ? loan.earningsSchedule.length - 1 : 0;
      const fallbackRow = { netEarnings: 0, cumFees: 0, ownershipDate: new Date(loan.loanStartDate), loanDate: new Date(loan.loanStartDate) };
      const loanStart = new Date(loan.loanStartDate);
      const TODAY = new Date();
      const diffMonthsFromStartRaw = monthDiff(loanStart, TODAY);
      const diffMonthsFromStart = Number.isFinite(diffMonthsFromStartRaw)
        ? Math.max(1, diffMonthsFromStartRaw)
        : 1;
      const currentIdx = Math.max(0, Math.min(diffMonthsFromStart - 1, lastIdx));
      const atCurrent = hasSchedule
        ? loan.earningsSchedule[currentIdx] || loan.earningsSchedule[lastIdx]
        : fallbackRow;
      const atEnd = hasSchedule ? loan.earningsSchedule[lastIdx] : fallbackRow;

      drawerTitle.textContent = `${loan.loanName} â€” Earnings (${loan.school || "No school"})`;
      drawerSub.innerHTML = `
        <div>${loan.school || "No school"} â€¢ Purchased ${loan.purchaseDate} â€¢ $${loan.purchasePrice.toLocaleString()}</div>
        <div class="drawer-detail">Balance at Purchase: $${(loan.balanceAtPurchase || 0).toLocaleString()}</div>
      `;
      drawerPrimaryTitle.textContent = "Net Earnings to Date";
      drawerPrimary.textContent = `$${atCurrent.netEarnings.toFixed(2)}`;
      drawerSecondaryTitle.textContent = "Fees to Date";
      drawerSecondary.textContent = `$${atCurrent.cumFees.toFixed(2)}`;

// Fill unified stat boxes
document.getElementById("drawerPrimaryTitle").textContent = "Net Earnings To Date";
document.getElementById("drawerPrimary").textContent = `$${atCurrent.netEarnings.toLocaleString()}`;

document.getElementById("drawerSecondaryTitle").textContent = "Fees To Date";
document.getElementById("drawerSecondary").textContent = `$${atCurrent.cumFees.toLocaleString()}`;

      
      createDrawerStackedChart(
        drawerChartArea,
        loan.earningsSchedule,
        loan
    );


      // table
      let rowsHtml = "";
      loan.earningsSchedule.forEach(r => {
        rowsHtml += `
          <tr>
            <td>${formatDate(r.loanDate)}</td>
            <td>${r.isOwned ? formatDate(r.ownershipDate) : ""}</td>
            <td>$${r.cumPrincipal.toFixed(2)}</td>
            <td>$${r.cumInterest.toFixed(2)}</td>
            <td>-$${r.cumFees.toFixed(2)}</td>
            <td>$${r.netEarnings.toFixed(2)}</td>
          </tr>
        `;
      });

      drawerExtra.innerHTML = `
        <p style="margin:0 0 6px; font-size:13px; color:var(--muted);">
          ${loan.loanName} â€” ${loan.school || "No school"}
        </p>
        <h3 style="margin-top:12px;margin-bottom:8px;">Earnings Breakdown by Month</h3>
        <div class="amort-wrap">
          <table>
            <thead>
              <tr>
                <th>Loan Date</th>
                <th>Ownership Date</th>
                <th>Cumulative Principal</th>
                <th>Cumulative Interest</th>
                <th>Cumulative Fees</th>
                <th>Net Earnings</th>
              </tr>
            </thead>
            <tbody>
              ${rowsHtml}
            </tbody>
          </table>
        </div>
      `;
      openDrawerBase();
    }

    document.addEventListener("DOMContentLoaded", initPage);

    // --------------------------
    // Theme toggle
    // --------------------------
    const themeToggleBtn = document.getElementById("themeToggle");
    const root = document.documentElement;
    const THEME_KEY = "reportsTheme";

    function applyTheme(mode){
      const nextMode = mode === "dark" ? "dark" : "light";
      root.setAttribute("data-theme", nextMode);
      themeToggleBtn.textContent = nextMode === "dark" ? "â˜€ï¸" : "ðŸŒ™";
      themeToggleBtn.setAttribute("aria-label", nextMode === "dark" ? "Switch to light mode" : "Switch to dark mode");
      try { localStorage.setItem(THEME_KEY, nextMode); } catch(e){}
    }

    function initTheme(){
      let saved = null;
      try { saved = localStorage.getItem(THEME_KEY); } catch(e){}
      const prefersDark = window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches;
      applyTheme(saved || (prefersDark ? "dark" : "light"));
    }

    initTheme();

    themeToggleBtn.addEventListener("click", () => {
      const isDark = root.getAttribute("data-theme") === "dark";
      applyTheme(isDark ? "light" : "dark");
    });

    // ======================
    // KPI CHART RENDERERS
    // ======================
    const loanColors = ["#0ea5e9", "#22c55e", "#7c3aed", "#14b8a6", "#f59e0b", "#ef4444", "#6366f1", "#a855f7", "#f97316", "#06b6d4"];

    function buildKpiStackedChart(containerId, data, valueGetter, showCurrentLine = true, mode = null){
      const container = document.getElementById(containerId);
      if(!container) return;
      container.innerHTML = "";

      const key = mode || containerId;
      const TODAY = new Date();
      const startTimes = data.map(l => new Date(l.loanStartDate).getTime()).filter(t => Number.isFinite(t));
      const earliestLoanStart = startTimes.length
        ? new Date(Math.min(...startTimes))
        : new Date();

      const svgNS = "http://www.w3.org/2000/svg";
      const rect = container.getBoundingClientRect();
      const w = Math.max(360, rect.width || 700);
      const h = 260;
      const padL = 50, padR = 20, padT = 20, padB = 16;

      const maxMonths = Math.max(1, ...data.map(l => l.earningsSchedule.length));
      const months = Array.from({length:maxMonths}, (_,i) => {
        const sampleRow = data.find(l => l.earningsSchedule[i])?.earningsSchedule[i];
        const month = sampleRow?.ownershipMonthIndex || i+1;
        const monthDate = addMonths(earliestLoanStart, i);
        const contributions = data.map(loan => {
          const row = loan.earningsSchedule[Math.min(i, loan.earningsSchedule.length-1)];
          const value = valueGetter(row || {}, month, loan);
          return {
            loanId: loan.id,
            value,
            color: loanColors[(loan.id - 1) % loanColors.length]
          };
        });
        const posTotal = contributions.reduce((sum,c) => c.value > 0 ? sum + c.value : sum, 0);
        const negTotal = contributions.reduce((sum,c) => c.value < 0 ? sum + c.value : sum, 0);
        return { month, monthDate, contributions, posTotal, negTotal };
      });

      let maxValue = 0;
      let minValue = 0;
      months.forEach(m => {
        maxValue = Math.max(maxValue, m.posTotal);
        minValue = Math.min(minValue, m.negTotal);
      });

      const yMax = Math.max(maxValue, 1);
      const yMin = minValue < -10 ? minValue : - (yMax * 0.10);
      const yRange = yMax - yMin || 1;
      const usableHeight = h - padT - padB;
      const scale = usableHeight / yRange;
      const yZero = padT + (yMax / yRange) * usableHeight;

      const count = months.length;
      const barW = (w - padL - padR) / Math.max(1, count);

      const svg = document.createElementNS(svgNS, "svg");
      svg.setAttribute("viewBox", `0 0 ${w} ${h}`);
      svg.setAttribute("width","100%");
      svg.setAttribute("height","100%");

      const gridBelowZero = 2;
      const gridAboveZero = 4;

      for (let gy = -gridBelowZero; gy <= gridAboveZero; gy++) {
        const y = yZero - gy * ((yZero - padT) / gridAboveZero);

        const gridLine = document.createElementNS(svgNS,"line");
        gridLine.setAttribute("x1",padL);
        gridLine.setAttribute("x2",w-padR);
        gridLine.setAttribute("y1",y);
        gridLine.setAttribute("y2",y);
        gridLine.setAttribute("stroke", gy >= 0 ? "var(--grid-strong)" : "var(--grid-light)");
        gridLine.setAttribute("stroke-width","0.7");
        svg.appendChild(gridLine);

        if(gy > 0){
          const lbl = document.createElementNS(svgNS,"text");
          const value = (yMax / gridAboveZero) * gy;
          lbl.textContent = "$" + Math.round(value).toLocaleString();
          lbl.setAttribute("x", padL - 10);
          lbl.setAttribute("y", y + 4);
          lbl.setAttribute("font-size","11");
          lbl.setAttribute("fill","var(--text)");
          lbl.setAttribute("text-anchor","end");
          svg.appendChild(lbl);
        }
      }

      const axis = document.createElementNS(svgNS,"line");
      axis.setAttribute("x1",padL);
      axis.setAttribute("x2",w-padR);
      axis.setAttribute("y1",yZero);
      axis.setAttribute("y2",yZero);
      axis.setAttribute("stroke","var(--grid-strong)");
      axis.setAttribute("stroke-width","1");
      svg.appendChild(axis);

      months.forEach((m, idx) => {
        const stackedGroupId = `stack-kpi-${m.month}`;
        const x = padL + idx*barW;
        let yPos = yZero;
        let yNeg = yZero;
        const barWidth = Math.max(2, barW-4);

        m.contributions.forEach((c, loanIndex) => {
          const hVal = Math.abs(c.value) * scale;
          if(hVal <= 0) return;

          const r = document.createElementNS(svgNS,"rect");
          r.setAttribute("x", x+2);
          r.setAttribute("width", barWidth);
          r.setAttribute("fill", c.color);
          prepareStackedBar(r, stackedGroupId, loanIndex, c.value >= 0);

          if(c.value >= 0){
            yPos -= hVal;
            r.setAttribute("y", yPos);
            r.setAttribute("height", hVal);
          } else {
            r.setAttribute("y", yNeg);
            r.setAttribute("height", hVal);
            yNeg += hVal;
          }

          svg.appendChild(r);
        });

        // ------------------------------
// Date-based X-axis labels
// KPI1 â†’ every 3 months
// KPI2â€“4 â†’ every 12 months
// ------------------------------
const labelInterval =
  key === "kpi1" ? 3 :   // KPI1 = Net Earnings â†’ show more detail
  12;                    // Other KPIs â†’ annual labels

const monthIndex = idx;  // 0,1,2,â€¦

if (monthIndex % labelInterval === 0) {
  const lbl = document.createElementNS(svgNS, "text");
  lbl.textContent = m.monthDate.toLocaleString("en-US", {
    month: "short",
    year: "numeric"
  });
  lbl.setAttribute("x", x + barWidth / 2);
  lbl.setAttribute("y", h - padB + 16);
  lbl.setAttribute("font-size", "11");
  lbl.setAttribute("fill", "var(--text)");
  lbl.setAttribute("text-anchor", "middle");
  svg.appendChild(lbl);
}

      });

      if(showCurrentLine){
        // ---------------------------------------
// Correct Today-Line positioning by DATE
// ---------------------------------------
const todayIdx = months.findIndex(m =>
  m.monthDate.getFullYear() === TODAY.getFullYear() &&
  m.monthDate.getMonth() === TODAY.getMonth()
);

const todayIndex = todayIdx >= 0 ? todayIdx : months.length - 1;
const currentX = padL + todayIndex * barW;

        const vline = document.createElementNS(svgNS, "line");
        vline.setAttribute("x1", currentX);
        vline.setAttribute("x2", currentX);
        vline.setAttribute("y1", 0);
        vline.setAttribute("y2", h);
        vline.setAttribute("stroke", "#64748b");
        vline.setAttribute("stroke-dasharray", "4,3");
        vline.setAttribute("stroke-width", "1.5");
        svg.appendChild(vline);
      }

      container.appendChild(svg);

      let lensInstance = null;
      let tooltipInstance = null;
      const lensRadius = 40;
      const lensScale = 1.5;

      function handleMove(e){
        const rect = svg.getBoundingClientRect();
        const mouseX = ((e.clientX - rect.left) / rect.width) * w;
        const mouseY = ((e.clientY - rect.top) / rect.height) * h;
        const x = Math.max(lensRadius, Math.min(w - lensRadius, mouseX));
        const y = Math.max(lensRadius, Math.min(h - lensRadius, mouseY));

        if(!lensInstance){
          lensInstance = createLens(svg, lensRadius, lensScale);
          const barClones = Array.from(svg.querySelectorAll("rect"))
            .filter(r => r.__value !== undefined || r.getAttribute("fill"));
          barClones.forEach(r => lensInstance.content.appendChild(r.cloneNode(true)));
          svg.appendChild(lensInstance.group);
        }

        if(!tooltipInstance){
          tooltipInstance = createTooltip(svg, true);
        }

        updateLens(lensInstance, x, y);

        const idx = Math.max(0, Math.min(months.length - 1, Math.floor((x - padL) / barW)));
        const monthRow = months[idx];
        const month = monthRow.month;

        const aggregates = data.reduce((acc, loan) => {
          const row = loan.earningsSchedule[Math.min(idx, loan.earningsSchedule.length-1)] || {};
          acc.principal += row.cumPrincipal || 0;
          acc.interest += row.cumInterest || 0;
          acc.fees += row.cumFees || 0;
          acc.net += row.netEarnings || 0;
          return acc;
        }, {principal:0, interest:0, fees:0, net:0});

        let tooltipLines = [];
        if(key === "kpi1"){ // Net earnings to date
          tooltipLines = [
            `Date: ${formatMonthYear(monthRow.monthDate)}`,
  `Net: $${aggregates.net.toFixed(2)}`,
  `Principal: $${aggregates.principal.toFixed(2)}`,
  `Interest: $${aggregates.interest.toFixed(2)}`,
  `Fees: -$${aggregates.fees.toFixed(2)}`
          ];
        } else if(key === "kpi2"){ // Projected lifetime
          tooltipLines = [
            `Date: ${formatMonthYear(monthRow.monthDate)}`,
  `Projected Net: $${(monthRow.posTotal + monthRow.negTotal).toFixed(2)}`
          ];
} else if (key === "kpi3") { // Average monthly
  // Use TRUE portfolio lifetime (calendar months)
  const portfolioStart = window.__PORTFOLIO_START__;

  const monthsElapsed = portfolioStart
    ? Math.max(1, monthDiff(portfolioStart, monthRow.monthDate) + 1)
    : 1;

  const avg = aggregates.net / monthsElapsed;

  tooltipLines = [
    `Date: ${formatMonthYear(monthRow.monthDate)}`,
    `Avg / Month: $${avg.toFixed(2)}`,
    `Net to Date: $${aggregates.net.toFixed(2)}`
  ];
}

          tooltipLines = [
            `Date: ${formatMonthYear(monthRow.monthDate)}`,
  `Fees: -$${aggregates.fees.toFixed(2)}`,
  `Net: $${aggregates.net.toFixed(2)}`
          ];

        updateTooltipContent(tooltipInstance, tooltipLines, true);
        updateTooltipPosition(tooltipInstance, x, y, lensRadius);
      }

      function handleLeave(){
        removeLens(svg, lensInstance);
        lensInstance = null;
        if(tooltipInstance){
          tooltipInstance.group.remove();
          tooltipInstance = null;
        }
      }

      svg.addEventListener("mousemove", handleMove);
      svg.addEventListener("mouseleave", handleLeave);
    }


    // KPI 1: Total Net Earnings to Date (portfolio stacked chart)
function renderKPI1Chart(loans, containerId = "drawerChartArea") {
  const containerEl = document.getElementById(containerId);
  if (!containerEl) return;

  // Build portfolio-level monthly rows using ownership dates,
  // and only up to TODAY
  const rows = buildPortfolioDrawerRows(loans);

  // Use the new aggregated stacked chart engine which already
  // uses window.KPI_COLOR_MAP for colors
  createKpiStackedChart(drawerChartArea, portfolioViews.rows, { denseXAxis: true });

}
    function renderKPI2Chart(loans) {
  const rows = buildProjectedDrawerRows(loans);

  createKpiStackedChart(
    document.getElementById("drawerChartArea"),
    rows,
    {
      denseXAxis: false,     // monthly ticks (M1, M12, M24â€¦)
      thinBars: true,        // long horizon looks better thinner
      projected: true        // flag for styling if needed later
    }
  );
}

    
    function renderKPI3Chart(data, containerId = "kpi3Chart"){
      buildKpiStackedChart(containerId, data, (row, month) => {
        const net = row.netEarnings || 0;
        return month > 0 ? net / month : 0;
      }, true, "kpi3");
    }
    
    function renderKPI4Chart(data, containerId = "kpi4Chart"){
      buildKpiStackedChart(containerId, data, row => -(row.cumFees || 0), true, "kpi4");
    }

    // ======================
    // KPI TABLE RENDERERS
    // ======================
function renderKpiTable(containerId, headers, rows) {
  const container = document.getElementById(containerId);
  if (!container) return;

  const colors = window.KPI_COLOR_MAP || {};

  let html = `<table><thead><tr>`;
  headers.forEach(h => html += `<th>${h}</th>`);
  html += `</tr></thead><tbody>`;

  rows.forEach(r => {
    const color = colors[r.loanId] || "var(--text)";

    // âœ… Set color ON THE ROW (not the cells)
    html += `
      <tr
        data-loan-id="${r.loanId}"
        style="--loan-color:${color}; color:var(--loan-color)"
      >
    `;

    r.cells.forEach(c => {
      html += `<td>${c}</td>`;
    });

    html += `</tr>`;
  });

  html += `</tbody></table>`;
  container.innerHTML = html;
}


    
function renderKPI1Table(data, containerId = "kpi1Table") {
  const rows = data.map(l => {
    const { row: atCur } = getCurrentEarningsRow(l);
    const color = window.KPI_COLOR_MAP?.[l.loanId] || "#64748b";

    return {
      loanId: l.loanId,
      cells: [
        // Color swatch
        `<div
          class="loan-swatch"
          data-loan-id="${l.loanId}"
          title="Toggle loan"
          style="
            width:10px;
            height:10px;
            border-radius:2px;
            background:${color};
            margin:4px auto;
            cursor:pointer;
          "
        ></div>`,

        l.loanName,
        formatCurrency(atCur.netEarnings),
        formatCurrency(atCur.cumPrincipal),
        formatCurrency(atCur.cumInterest),
        "-" + formatCurrency(atCur.cumFees)
      ]
    };
  });

  renderKpiTable(
  containerId,
  [
    `<span title="Hover to highlight loan â€¢ Click to toggle loan on/off">
      Loan On/Off
     </span>`,
    "Loan",
    "Net Earnings",
    "Principal",
    "Interest",
    "Fees"
  ],
  rows
);


  const table = document.getElementById(containerId);
  if (!table) return;

  // -------------------------
  // Row hover â†’ highlight chart
  // -------------------------
  table.querySelectorAll("tr[data-loan-id]").forEach(tr => {
    const loanId = tr.dataset.loanId;

    tr.addEventListener("mouseenter", () => {
      document
        .querySelectorAll("#drawerChartArea svg rect")
        .forEach(r => {
          r.style.opacity =
            r.dataset.loanId === loanId ? "1" : "0.2";
        });
    });

    tr.addEventListener("mouseleave", () => {
      document
        .querySelectorAll("#drawerChartArea svg rect")
        .forEach(r => {
          r.style.opacity = "1";
        });
    });
  });

  // -------------------------
  // Swatch click â†’ toggle loan
  // -------------------------
  table.querySelectorAll(".loan-swatch").forEach(sw => {
    const loanId = sw.dataset.loanId;

    sw.addEventListener("click", e => {
      e.stopPropagation();

      if (hiddenLoans.has(loanId)) {
        hiddenLoans.delete(loanId);
        sw.style.opacity = "1";
      } else {
        hiddenLoans.add(loanId);
        sw.style.opacity = "0.3";
      }

      const rows = buildPortfolioDrawerRows(loansWithEarnings);
      createKpiStackedChart(
        document.getElementById("drawerChartArea"),
        rows,
        { denseXAxis: true, thinBars: false }
      );
    });
  });
}

function toggleLoanVisibility(loanId) {
  if (hiddenLoans.has(loanId)) {
    hiddenLoans.delete(loanId);
  } else {
    hiddenLoans.add(loanId);
  }

  // Re-open KPI4 to fully re-render chart + table
  openKpi4();
}



function renderKPI2Table(data, containerId = "kpi2Table") {
  const rows = data.map(l => {
    const sched = l.earningsSchedule || [];
    if (!sched.length) return null;

    const last = sched[sched.length - 1];
    const color = window.KPI_COLOR_MAP?.[l.loanId] || "#64748b";

    return {
      loanId: l.loanId,
      cells: [
        // Color swatch (toggle + hover)
        `<div
          class="loan-swatch"
          data-loan-id="${l.loanId}"
          title="Toggle loan"
          style="
            width:10px;
            height:10px;
            border-radius:2px;
            background:${color};
            margin:4px auto;
            cursor:pointer;
          "
        ></div>`,

        l.loanName,
        formatCurrency(last.netEarnings),
        formatCurrency(last.cumPrincipal),
        formatCurrency(last.cumInterest),
        "-" + formatCurrency(last.cumFees)
      ]
    };
  }).filter(Boolean);

  renderKpiTable(
    containerId,
    ["Loan On/Off", "Loan", "Projected Net", "Principal", "Interest", "Fees"],
    rows
  );

  // -------------------------
  // KPI2 table interactions
  // -------------------------
  const table = document.getElementById(containerId);
  if (!table) return;

  // Row hover â†’ highlight chart bands (same as KPI1)
  table.querySelectorAll("tr[data-loan-id]").forEach(tr => {
    const loanId = tr.dataset.loanId;

    tr.addEventListener("mouseenter", () => {
      document.querySelectorAll("#drawerChartArea svg rect").forEach(r => {
        r.style.opacity = (r.dataset.loanId === loanId) ? "1" : "0.25";
      });
    });

    tr.addEventListener("mouseleave", () => {
      document.querySelectorAll("#drawerChartArea svg rect").forEach(r => {
        r.style.opacity = "1";
      });
    });
  });

  // Swatch click â†’ toggle loan visibility
  table.querySelectorAll(".loan-swatch").forEach(sw => {
    const loanId = sw.dataset.loanId;

    sw.addEventListener("click", e => {
      e.stopPropagation();

      if (hiddenLoans.has(loanId)) {
        hiddenLoans.delete(loanId);
        sw.style.opacity = "1";
      } else {
        hiddenLoans.add(loanId);
        sw.style.opacity = "0.25";
      }

      // Re-render KPI2 chart (added next step)
      renderKPI2Chart(loansWithEarnings);
    });
  });
}

function renderKPI3Table(data, containerId = "kpi3Table") {
  const rows = data.map(l => {
    // Total net earnings to date for this loan
    const sched = l.earningsSchedule || [];
    const netToDate = sched.length
      ? Number(sched[sched.length - 1].netEarnings || 0)
      : 0;

    // KPI3-aligned average:
    // loan contribution spread across portfolio months
    const avg = kpis.monthsCounted
      ? netToDate / kpis.monthsCounted
      : 0;

    return {
      loanId: l.loanId,
      cells: [
      l.loanName,
      l.school || "â€”",
      formatCurrency(
      (getCurrentEarningsRow(l).row.netEarnings || 0) /
      Math.max(
        1,
        monthDiff(window.__PORTFOLIO_START__, new Date()) + 1
      )
    ),
  formatDate(new Date(l.purchaseDate))
]

    };
  });

  renderKpiTable(
    containerId,
    ["Loan", "School", "Avg Monthly Earnings To Date", "Purchase Date"],
    rows
  );
}

function renderKPI4Table(loans, containerId = "drawerKpiTable") {
  const container = document.getElementById(containerId);
  if (!container) return;

  const rows = loans.map(l => {
    const sched = l.earningsSchedule || [];
    if (!sched.length) return null;

    const last = sched[sched.length - 1];
    const months = sched.length;
    const avg = months > 0 ? last.netEarnings / months : 0;

    const color = window.KPI_COLOR_MAP?.[l.loanId] || "#64748b";

    return {
      loanId: l.loanId,
      cells: [
        // Color swatch
        `
        <div
          class="loan-swatch"
          data-loan-id="${l.loanId}"
          style="
            width:10px;
            height:10px;
            border-radius:2px;
            background:${color};
            margin:4px auto;
          ">
        </div>
        `,
        l.loanName,
        formatCurrency(avg),
        formatCurrency(last.netEarnings),
        `${months} mo`
      ]
    };
  }).filter(Boolean);

  container.innerHTML = `
    <table class="kpi4-table">
      <thead>
        <tr>
          <th style="width:42px">Loan On / Off</th>
          <th>Loan</th>
          <th>Avg / Month (Projected)</th>
          <th>Projected Net</th>
          <th>Months</th>
        </tr>
      </thead>
      <tbody>
        ${rows.map(r => `
          <tr data-loan-id="${r.loanId}" style="--loan-color:${window.KPI_COLOR_MAP?.[r.loanId] || 'var(--text)'}">
            ${r.cells.map(c => `<td>${c}</td>`).join("")}
          </tr>
        `).join("")}
      </tbody>
    </table>
  `;
}




    function createLens(svg, radius = 40, scale = 1.5, borderColor = "#94a3b8", borderWidth = 1.5, bgFill = "rgba(255,255,255,0.7)"){
      const svgNS = "http://www.w3.org/2000/svg";
      const defs = svg.querySelector("defs") || (()=>{ const d = document.createElementNS(svgNS,"defs"); svg.insertBefore(d, svg.firstChild); return d; })();
      const clipId = `lens-clip-${Math.random().toString(36).slice(2)}`;
      const clipPath = document.createElementNS(svgNS,"clipPath");
      clipPath.setAttribute("id", clipId);
      const clipCircle = document.createElementNS(svgNS,"circle");
      clipCircle.setAttribute("r", radius);
      clipPath.appendChild(clipCircle);
      defs.appendChild(clipPath);

      const group = document.createElementNS(svgNS,"g");
      group.setAttribute("pointer-events","none");

      const bgCircle = document.createElementNS(svgNS,"circle");
      bgCircle.setAttribute("r", radius);
      bgCircle.setAttribute("fill", bgFill);
      bgCircle.setAttribute("stroke", borderColor);
      bgCircle.setAttribute("stroke-width", borderWidth);
      bgCircle.setAttribute("opacity","0.95");

      const content = document.createElementNS(svgNS,"g");
      content.setAttribute("clip-path", `url(#${clipId})`);

      const outline = document.createElementNS(svgNS,"circle");
      outline.setAttribute("r", radius);
      outline.setAttribute("fill","none");
      outline.setAttribute("stroke", borderColor);
      outline.setAttribute("stroke-width", borderWidth);

      group.appendChild(bgCircle);
      group.appendChild(content);
      group.appendChild(outline);

      return { group, content, outline, bgCircle, clipCircle, clipPath, scale, radius };
    }

    function updateLens(lens, x, y){
      if(!lens) return;
      const tx = x - x * lens.scale;
      const ty = y - y * lens.scale;
      lens.clipCircle.setAttribute("cx", x);
      lens.clipCircle.setAttribute("cy", y);
      lens.bgCircle.setAttribute("cx", x);
      lens.bgCircle.setAttribute("cy", y);
      lens.outline.setAttribute("cx", x);
      lens.outline.setAttribute("cy", y);
      lens.content.setAttribute("transform", `translate(${tx}, ${ty}) scale(${lens.scale})`);
    }

    function removeLens(svg, lens){
      if(!lens) return;
      if(lens.group && lens.group.parentNode === svg) svg.removeChild(lens.group);
      if(lens.clipPath && lens.clipPath.parentNode) lens.clipPath.parentNode.removeChild(lens.clipPath);
    }

    function createTooltip(svg, large = false){
      const svgNS = "http://www.w3.org/2000/svg";
      const group = document.createElementNS(svgNS,"g");
      group.setAttribute("pointer-events","none");
      group.setAttribute("opacity","0.95");

      const rect = document.createElementNS(svgNS,"rect");
      rect.setAttribute("rx", large ? 8 : 6);
      rect.setAttribute("ry", large ? 8 : 6);
      rect.setAttribute("fill","rgba(15,23,42,0.92)");
      rect.setAttribute("stroke","#0ea5e9");
      rect.setAttribute("stroke-width","0.6");

      const textGroup = document.createElementNS(svgNS,"g");
      textGroup.setAttribute("fill","#fff");
      textGroup.setAttribute("font-size", large ? "12" : "11");
      textGroup.setAttribute("font-weight","600");

      group.appendChild(rect);
      group.appendChild(textGroup);
      svg.appendChild(group);

      return { group, rect, textGroup, lines: [], large, width:0, height:0 };
    }

    function updateTooltipContent(tooltip, lines, large = false){
      if(!tooltip) return;
      tooltip.large = large;
      tooltip.rect.setAttribute("rx", large ? 8 : 6);
      tooltip.rect.setAttribute("ry", large ? 8 : 6);
      tooltip.textGroup.setAttribute("font-size", large ? "12" : "11");
      while(tooltip.lines.length < lines.length){
        const t = document.createElementNS("http://www.w3.org/2000/svg","text");
        tooltip.textGroup.appendChild(t);
        tooltip.lines.push(t);
      }
      while(tooltip.lines.length > lines.length){
        const t = tooltip.lines.pop();
        t.remove();
      }

      const lineHeight = large ? 15 : 14;
      let maxWidth = 0;
      tooltip.lines.forEach((t, idx) => {
        t.textContent = lines[idx];
        t.setAttribute("x", 6);
        t.setAttribute("y", 12 + idx * lineHeight);
        maxWidth = Math.max(maxWidth, t.getBBox().width);
      });

      const paddingX = 10;
      const paddingY = 8;
      const width = maxWidth + paddingX * 2;
      const height = lines.length * lineHeight + paddingY;

      tooltip.rect.setAttribute("width", width);
      tooltip.rect.setAttribute("height", height);
      tooltip.rect.setAttribute("x", 0);
      tooltip.rect.setAttribute("y", 0);
      tooltip.width = width;
      tooltip.height = height;
    }

    function updateTooltipPosition(tooltip, cx, cy, radius){
      if(!tooltip) return;
      const width = tooltip.width || 0;
      const height = tooltip.height || 0;

      let dx = radius * 0.45;
      let dy = -radius * 0.85;

      let tooltipX = cx + dx;
      let tooltipY = cy + dy;
      const minX = cx + 2;
      const maxX = cx + radius - width - 2;
      const maxY = cy - height - 2;
      const circleLimit = radius - 3;

      tooltipX = Math.min(Math.max(tooltipX, minX), maxX);
      tooltipY = Math.min(tooltipY, maxY);

      for(let i = 0; i < 10; i++){
        const corners = [
          {x: tooltipX, y: tooltipY},
          {x: tooltipX + width, y: tooltipY},
          {x: tooltipX, y: tooltipY + height},
          {x: tooltipX + width, y: tooltipY + height}
        ];

        let adjusted = false;

        for(const corner of corners){
          const distance = Math.hypot(corner.x - cx, corner.y - cy);
          if(distance >= circleLimit){
            const push = distance - circleLimit + 0.5;
            const nx = (cx - corner.x) / distance;
            const ny = (cy - corner.y) / distance;
            tooltipX += nx * push;
            tooltipY += ny * push;
            adjusted = true;
          }
        }

        tooltipX = Math.min(Math.max(tooltipX, minX), maxX);
        tooltipY = Math.min(tooltipY, maxY);

        if(!adjusted) break;
      }

      tooltipX = Math.max(tooltipX, cx + 2);
      tooltipY = Math.min(tooltipY, cy - height - 2);

      tooltip.group.setAttribute("transform", `translate(${tooltipX}, ${tooltipY})`);
    }

    // Shared drawer behavior handled above for both KPI and loan content.

    // CSV download handler
    document.body.addEventListener("click", (e) => {
      if (e.target.matches("#downloadCsvBtn") || e.target.matches("[data-download-csv]")) {
        downloadCurrentDrawerCsv();
      }
    });

    // Copy CSV
    document.body.addEventListener("click", (e) => {
      if (e.target.matches("#copyCsvBtn")) {
        navigator.clipboard.writeText(currentCsvData || "");
        alert("CSV copied to clipboard.");
      }
    });

    // Print
    document.body.addEventListener("click", (e) => {
      if (e.target.matches("#printBtn")) {
        window.print();
      }
    });

    // CSV download utility
    function downloadCurrentDrawerCsv() {
      const blob = new Blob([currentCsvData || ""], { type: "text/csv" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = "drawer-data.csv";
      a.click();
      URL.revokeObjectURL(url);
    }
  </script>
</body>
</html>
